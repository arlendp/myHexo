<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[移动web开发中的viewport]]></title>
      <url>http://arlendp.me/web/html/meta-viewport/</url>
      <content type="html"><![CDATA[<p>在对移动端做响应式布局时，一般都是直接对meta标签进行设置，然后通过媒体查询来对不同尺寸的设备进行样式的调整。但是为什么meta标签要这么设置，以及它与视口(viewport)有什么关系一直不是很理解，因此花了一点时间对这个问题进行了整理，也对其有了更深入的了解。<br><a id="more"></a></p>
<h2 id="CSS中的像素和设备像素"><a href="#CSS中的像素和设备像素" class="headerlink" title="CSS中的像素和设备像素"></a>CSS中的像素和设备像素</h2><p>css中的像素理解起来很简单，就是我们在css文件中设置的像素值，如<code>width: 500px</code>。而设备像素就是电脑或者手机屏幕的物理像素，而css像素和设备像素又有什么关系呢，这就涉及到一个属性<code>devicePixelRatio</code>，它是window对象下的属性，可以直接通过<code>window.devicePixelRatio</code>来读取它。对于一般情况下这个值都是1，在retina屏上则是2。这个属性表示的是<strong>css中的一个像素对应的设备像素数</strong>，因此一般情况下，css中的一个像素就对应设备上的一个像素，只有在某些特殊的显示屏上才会有css的一个像素对应多个像素的情况。</p>
<h2 id="视口的概念"><a href="#视口的概念" class="headerlink" title="视口的概念"></a>视口的概念</h2><p>我们一般认为视口就是设备的可视区域，也就是用来显示网页的那一块区域。随着移动设备的出现，不同的设备可能有着不同的可视区域大小，具体可以通过<a href="http://viewportsizes.com/" target="_blank" rel="external">viewportsize</a>来查看，或者直接通过浏览器的开发工具来查看。</p>
<p>但在开发过程中会发现视口显示的像素并不是设备的可视区域的像素，举个例子：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container-1</span> &#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</div><div class="line">   	<span class="attribute">background-color</span>: <span class="number">#abccbb</span>;</div><div class="line"> &#125;</div><div class="line"> <span class="selector-class">.contaienr-2</span> &#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</div><div class="line">   	<span class="attribute">background-color</span>: <span class="number">#343421</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在iphone6的显示下效果如图：</p>
<p><img src="/images/viewport/1.png" alt="1"></p>
<p>这里会看到，当两个container的宽度适应屏幕大小时显示的是980px，而不是设备的375px。不同的设备下这个值也不同，主要大小有980和1024，可以通过<code>document.documentElement.clientWidth</code>来得到。而至于这里为什么和设备像素不同，又会涉及到以下meta标签中viewport的知识。</p>
<h2 id="meta标签中的viewport"><a href="#meta标签中的viewport" class="headerlink" title="meta标签中的viewport"></a>meta标签中的viewport</h2><p>在做移动端web开发时都会对这个值进行设置，一般会设置成<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale = 1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</code>。这样设置会使得viewport宽度等于设备的宽度并且同时不允许用户进行手势缩放。</p>
<p><img src="/images/viewport/2.png" alt="2"></p>
<p>这样再次查看上面这张图会发现它的视口宽度和设备宽度已经相等了。在开发过程中我们需要的就是这种效果。</p>
<p>在meta标签的viewport中，允许设置以下六种值：</p>
<ul>
<li>width：设置视口宽度，可以为具体的像素值或者是device-width</li>
<li>height：设置视口的高度，一般不使用</li>
<li>initial-scale：设置视口的初始缩放值</li>
<li>minimum-scale：设置视口最大缩放值</li>
<li>maximum-scale：设置视口最小缩放值</li>
<li>user-scalable：设置用户是否可以手势缩放</li>
</ul>
<p>因此这里可以看出，通过上面常用的meta viewport的设置可以使得视口宽度和设备宽度相等。这里要注意，<strong>initial-scale、minimum-scale和maximum-scale指的是设备大小和视口大小的比值</strong>。</p>
<p>现在来看图一的问题也就好理解了，iphone默认对视口进行了调整，即将视口调整到了980px，这里使用的是initial-scale来对其进行调整，可以计算出<code>375/980=0.38</code>即是这里的初始缩放值。</p>
<p>另一点需要注意的是既然width和user-scale都可以设置视口大小，那么两个同时使用则浏览器采用的是哪一个呢，经过测试最终效果使用的是两个中尺寸更大的那一个值。但两者有一个区别是：如果较大值是width，则无论设为多少，视口的大小就是这个值；但如果较大值是initial-scale，则视口的大小是有限制的，对于不同设备不全相同。</p>
<p>下面测试一下，不同情况下的显示效果：</p>
<p>css都设置为以下值：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container-1</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">1200px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#abccbb</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container-2</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#343421</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有设置meta viewport属性：</p>
<p><img src="/images/viewport/3.png" alt="3"></p>
<p>可以看到，元素完全显示在屏幕当中，无横向滑动框，即可视区域大小为1200px。但这里注意body的大小被限制在了980px。可见视口大小还是980px。因此可以认为<strong>meta viewport标签设置的尺寸就是视口大小，即文档尺寸大小</strong>。而此时屏幕大小则是由浏览器自动计算缩放值来使得网页不会出现滚动条来得到的。</p>
<p>设置meta viewport属性为<code>&lt;meta name=&#39;viewport&#39; content=&#39;width=1000, initial-scale=1.0&#39;&gt;</code>:</p>
<p><img src="/images/viewport/4.png" alt="4"></p>
<p>可以看到，文档宽度为1000px，超出屏幕宽度并出现滚动条。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从以上过程可以看出，css的像素和设备像素概念上是不同的，在移动设备上不同设备的尺寸也不尽相同。为了能在开发时对设备像素和css像素进行统一，我们会采用通过<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</code>的方式来限制。对于width和initial-scale两个的区别，可以认为<strong>initial-scale设置了当前屏幕可视区域下可以显示的尺寸，width则设置了html元素尺寸</strong>。总的来说，在移动web开发中设置meta viewport则是为了让设备的视口大小和设备大小相等，从而方便通过根据不同设备的尺寸进行响应式设计。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js中几种位置和大小的理解]]></title>
      <url>http://arlendp.me/web/js/js-size-and-position/</url>
      <content type="html"><![CDATA[<p>在js的计算过程中，经常会用到元素的各种位置和大小信息，js中提供了多种方法。本文总结了js中经常容易混淆的位置和大小的概念，如clientWidth、offsetLeft、scrollLeft等等。<br><a id="more"></a></p>
<h2 id="几种位置和宽高的理解"><a href="#几种位置和宽高的理解" class="headerlink" title="几种位置和宽高的理解"></a>几种位置和宽高的理解</h2><ul>
<li>js<ul>
<li>clientLeft（元素左边框宽度）、clientTop（元素上边框的宽度）、clientWidth（元素内容宽度加上左右两端padding宽度，行内元素为0）、clientHeight（元素内容宽度加上上下两端padding宽度，行内元素为0）</li>
<li>offsetParent<ul>
<li>对于非定位元素是其根元素（标准模式下是html，怪异模式下是body）</li>
<li>对于定位元素是其最近的定位父元素</li>
</ul>
</li>
<li>offsetLeft（元素的外padding到offsetParent的外padding的距离。对于inline元素则是从外border到offsetParent的外padding）、offsetTop、offsetWidth（包含元素的宽度、padding以及滚动条（元素宽度会留一部分给滚动条）、offsetHeight</li>
<li>scrollLeft（元素内容向右滚动的距离）、scrollTop（元素内容向下滚动的距离）、scrollWidth（元素内容宽度与元素本身宽度的较大值，本身宽度包括padding）、scrollHeight</li>
<li>getBoundingClientRect（元素的宽高：除了margin以外的宽高。元素的位置：除了margin外元素的左上角与视口的左上角的相对位置。对于可滚动的元素，其内容在滚动过程中坐标会变化）</li>
</ul>
</li>
<li>jquery<ul>
<li>position（相对于offset parent的位置）</li>
<li>scrollTop（与js中scrollTop相同）</li>
<li>width、height<ul>
<li>只包含内容宽度和高度，与<code>$().css(&#39;width&#39;)</code>返回的结果相同，只是类型是number，后者以’px’为单位。</li>
</ul>
</li>
<li>offset（相对于<code>docuemnt</code>的位置，与scrollLeft、scrollTop相同）</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[d3.js源码分析——Requests]]></title>
      <url>http://arlendp.me/web/js/d3-source-code-requests/</url>
      <content type="html"><![CDATA[<p>文件的加载对于很多应用都格外重要，对d3来说也是如此。对于绘制结构简单、数据量不大的图形，尚且可以将数据和js代码存放在一起，但是对于数据结构复杂、数据量庞大的情况，数据集应该被单独存放于独立的文件中，因此这里就涉及到了文件的读取问题。该模块用于对原生的<code>XMLHttpRequest</code>进行封装，可用于加载文件。<br><a id="more"></a></p>
<h2 id="d3-request"><a href="#d3-request" class="headerlink" title="d3.request"></a>d3.request</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line">// d3.request</div><div class="line">function request(url, callback) &#123;</div><div class="line">    var request,</div><div class="line">        event = dispatch(&quot;beforesend&quot;, &quot;progress&quot;, &quot;load&quot;, &quot;error&quot;),</div><div class="line">        mimeType,</div><div class="line">        headers = map$1(),</div><div class="line">        xhr = new XMLHttpRequest,</div><div class="line">        user = null,</div><div class="line">        password = null,</div><div class="line">        response,</div><div class="line">        responseType,</div><div class="line">        timeout = 0;</div><div class="line"></div><div class="line">    // 对于不支持跨域资源共享的IE浏览器，采用XDomainRequest</div><div class="line">    if (typeof XDomainRequest !== &quot;undefined&quot;</div><div class="line">        &amp;&amp; !(&quot;withCredentials&quot; in xhr)</div><div class="line">        &amp;&amp; /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest;</div><div class="line">    //如果支持onload回调方法则绑定该方法，否则使用onreadystatechange方法</div><div class="line">    &quot;onload&quot; in xhr</div><div class="line">        //三种事件分别是请求成功完成、请求失败和请求时限到期未完成</div><div class="line">        ? xhr.onload = xhr.onerror = xhr.ontimeout = respond</div><div class="line">        : xhr.onreadystatechange = function(o) &#123; xhr.readyState &gt; 3 &amp;&amp; respond(o); &#125;;</div><div class="line"></div><div class="line">    function respond(o) &#123;</div><div class="line">      var status = xhr.status, result;</div><div class="line">      if (!status &amp;&amp; hasResponse(xhr)</div><div class="line">          || status &gt;= 200 &amp;&amp; status &lt; 300</div><div class="line">          || status === 304) &#123;</div><div class="line">        if (response) &#123;</div><div class="line">          try &#123;</div><div class="line">            //先通过response函数对返回结果进行处理</div><div class="line">            result = response.call(request, xhr);</div><div class="line">          &#125; catch (e) &#123;</div><div class="line">            event.call(&quot;error&quot;, request, e);</div><div class="line">            return;</div><div class="line">          &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">          result = xhr;</div><div class="line">        &#125;</div><div class="line">        event.call(&quot;load&quot;, request, result);</div><div class="line">      &#125; else &#123;</div><div class="line">        event.call(&quot;error&quot;, request, o);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    xhr.onprogress = function(e) &#123;</div><div class="line">      event.call(&quot;progress&quot;, request, e);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    request = &#123;</div><div class="line">      //设置请求头信息</div><div class="line">      header: function(name, value) &#123;</div><div class="line">        name = (name + &quot;&quot;).toLowerCase();</div><div class="line">        if (arguments.length &lt; 2) return headers.get(name);</div><div class="line">        if (value == null) headers.remove(name);</div><div class="line">        else headers.set(name, value + &quot;&quot;);</div><div class="line">        return request;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      // 设置服务器返回数据类型，用于accept请求头和overrideMimeType方法</div><div class="line">      mimeType: function(value) &#123;</div><div class="line">        if (!arguments.length) return mimeType;</div><div class="line">        mimeType = value == null ? null : value + &quot;&quot;;</div><div class="line">        return request;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      /* 指定返回值类型，可以为以下几种值：</div><div class="line">       * ”“：字符串（默认值）</div><div class="line">       * “arraybuffer”：ArrayBuffer对象</div><div class="line">       * “blob”：Blob对象</div><div class="line">       * “document”：Document对象</div><div class="line">       * “json”：JSON对象</div><div class="line">       * “text”：字符串</div><div class="line">       */</div><div class="line">      responseType: function(value) &#123;</div><div class="line">        if (!arguments.length) return responseType;</div><div class="line">        responseType = value;</div><div class="line">        return request;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      timeout: function(value) &#123;</div><div class="line">        if (!arguments.length) return timeout;</div><div class="line">        timeout = +value;</div><div class="line">        return request;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      user: function(value) &#123;</div><div class="line">        return arguments.length &lt; 1 ? user : (user = value == null ? null : value + &quot;&quot;, request);</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      password: function(value) &#123;</div><div class="line">        return arguments.length &lt; 1 ? password : (password = value == null ? null : value + &quot;&quot;, request);</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      //将返回内容转化成指定类型</div><div class="line">      response: function(value) &#123;</div><div class="line">        response = value;</div><div class="line">        return request;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      // 使用GET方法发送请求</div><div class="line">      get: function(data, callback) &#123;</div><div class="line">        return request.send(&quot;GET&quot;, data, callback);</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      // 使用POST方法发送请求</div><div class="line">      post: function(data, callback) &#123;</div><div class="line">        return request.send(&quot;POST&quot;, data, callback);</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      // 修改请求头信息，设置服务器返回数据类型，监听error和load事件并设置回调函数</div><div class="line">      send: function(method, data, callback) &#123;</div><div class="line">        xhr.open(method, url, true, user, password);</div><div class="line">        if (mimeType != null &amp;&amp; !headers.has(&quot;accept&quot;)) headers.set(&quot;accept&quot;, mimeType + &quot;,*/*&quot;);</div><div class="line">        //设置请求头</div><div class="line">        if (xhr.setRequestHeader) headers.each(function(value, name) &#123; xhr.setRequestHeader(name, value); &#125;);</div><div class="line">        //指定服务器返回数据类型</div><div class="line">        if (mimeType != null &amp;&amp; xhr.overrideMimeType) xhr.overrideMimeType(mimeType);</div><div class="line">        if (responseType != null) xhr.responseType = responseType;</div><div class="line">        if (timeout &gt; 0) xhr.timeout = timeout;</div><div class="line">        if (callback == null &amp;&amp; typeof data === &quot;function&quot;) callback = data, data = null;</div><div class="line">        if (callback != null &amp;&amp; callback.length === 1) callback = fixCallback(callback);</div><div class="line">        if (callback != null) request.on(&quot;error&quot;, callback).on(&quot;load&quot;, function(xhr) &#123; callback(null, xhr); &#125;);</div><div class="line">        //调用beforesend监听事件</div><div class="line">        event.call(&quot;beforesend&quot;, request, xhr);</div><div class="line">        //发送请求</div><div class="line">        xhr.send(data == null ? null : data);</div><div class="line">        return request;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      abort: function() &#123;</div><div class="line">        xhr.abort();</div><div class="line">        return request;</div><div class="line">      &#125;,</div><div class="line">      //设置事件监听函数，只能是以下类型：beforesend、progress、load和error</div><div class="line">      on: function() &#123;</div><div class="line">        var value = event.on.apply(event, arguments);</div><div class="line">        return value === event ? request : value;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    //如果callback参数被传入，则会立即将请求发送出去，若没有传入callback则可继续配置request</div><div class="line">    if (callback != null) &#123;</div><div class="line">      if (typeof callback !== &quot;function&quot;) throw new Error(&quot;invalid callback: &quot; + callback);</div><div class="line">      return request.get(callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return request;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="d3-csv"><a href="#d3-csv" class="headerlink" title="d3.csv"></a>d3.csv</h2><p>用于读取指定URL中的csv文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//d3.csv</div><div class="line">var csv$1 = dsv$1(&quot;text/csv&quot;, csvParse);</div><div class="line"></div><div class="line">function dsv$1(defaultMimeType, parse) &#123;</div><div class="line">    return function(url, row, callback) &#123;</div><div class="line">      //可以省略row函数</div><div class="line">      if (arguments.length &lt; 3) callback = row, row = null;</div><div class="line">      var r = request(url).mimeType(defaultMimeType);</div><div class="line">      //设置row函数</div><div class="line">      r.row = function(_) &#123; return arguments.length ? r.response(responseOf(parse, row = _)) : row; &#125;;</div><div class="line">      r.row(row);</div><div class="line">      return callback ? r.get(callback) : r;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">//返回解析函数</div><div class="line">function responseOf(parse, row) &#123;</div><div class="line">    return function(request) &#123;</div><div class="line">      return parse(request.responseText, row);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这部分是直接调用request方法来读取文件，修改了服务器返回数据类型和response方法。与以下方法等同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d3.request(url)</div><div class="line">    .mimeType(&quot;text/csv&quot;)</div><div class="line">    .response(function(xhr) &#123; return d3.csvParse(xhr.responseText, row); &#125;)</div><div class="line">    .get(callback);</div></pre></td></tr></table></figure></p>
<h2 id="d3-html"><a href="#d3-html" class="headerlink" title="d3.html"></a>d3.html</h2><p>用于读取HTML文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var html = type(&quot;text/html&quot;, function(xhr) &#123;</div><div class="line">    return document.createRange().createContextualFragment(xhr.responseText);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>将返回的字符串构造成document fragment，形成一个DOM节点可以对其进行操作。</p>
<h2 id="d3-json"><a href="#d3-json" class="headerlink" title="d3.json"></a>d3.json</h2><p>读取JSON文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//d3.json</div><div class="line">var json = type(&quot;application/json&quot;, function(xhr) &#123;</div><div class="line">    return JSON.parse(xhr.responseText);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>通过<code>JSON.parse</code>方法对返回的字符串进行处理，转化成json格式的数据。</p>
<h2 id="d3-tsv"><a href="#d3-tsv" class="headerlink" title="d3.tsv"></a>d3.tsv</h2><p>用于读取tsv文件，和上述<code>d3.csv</code>类似。<br>等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d3.request(url)</div><div class="line">    .mimeType(&quot;text/tab-separated-values&quot;)</div><div class="line">    .response(function(xhr) &#123; return d3.tsvParse(xhr.responseText, row); &#125;)</div><div class="line">    .get(callback);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[d3.js源码分析——Dispatches]]></title>
      <url>http://arlendp.me/web/js/d3js-source-code-dispatches/</url>
      <content type="html"><![CDATA[<p>d3的dispatch模块是对原生事件处理的封装，通过该模块可以注册自定义的事件并绑定回调函数。<br><a id="more"></a></p>
<h2 id="d3-dispatch"><a href="#d3-dispatch" class="headerlink" title="d3.dispatch"></a>d3.dispatch</h2><p>该模块用于注册自定义名称的回调函数，并且可以调用这些函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">function dispatch() &#123;</div><div class="line">    /*将传入的参数作为键值存入Dispatch对象中，参数以数组的形式传入并且不能有重复的元素</div><div class="line">     *初始化时参数只包含类型，不应包含名称，并入初始化时可以传入[&apos;click&apos;, &apos;drag&apos;]，在之后调用on方法时可以通过on(&apos;click.my1 drag.my2 hover&apos;, callback)这种方式来绑定回调函数</div><div class="line">     *在dispatch中是以如下方式存储：</div><div class="line">     *</div><div class="line">     *  &#123;</div><div class="line">     *    &apos;click&apos;: [</div><div class="line">     *      &#123;</div><div class="line">     *        name: &apos;my1&apos;,</div><div class="line">     *        value: callback</div><div class="line">     *      &#125;</div><div class="line">     *    ],</div><div class="line">     *    &apos;drag&apos;: [</div><div class="line">     *      &#123;</div><div class="line">     *        name: &apos;my2&apos;,</div><div class="line">     *        value: callback</div><div class="line">     *      &#125;</div><div class="line">     *    ],</div><div class="line">     *    &apos;hover&apos;: [</div><div class="line">     *      &#123;</div><div class="line">     *        name: &apos;&apos;,</div><div class="line">     *        value: callback</div><div class="line">     *      &#125;</div><div class="line">     *    ]</div><div class="line">     *  &#125;</div><div class="line">     */</div><div class="line">    for (var i = 0, n = arguments.length, _ = &#123;&#125;, t; i &lt; n; ++i) &#123;</div><div class="line">        if (!(t = arguments[i] + &quot;&quot;) || (t in _)) throw new Error(&quot;illegal type: &quot; + t);</div><div class="line">        _[t] = [];</div><div class="line">    &#125;</div><div class="line">    return new Dispatch(_);</div><div class="line">&#125;</div><div class="line">//Dispatch构造函数</div><div class="line">function Dispatch(_) &#123;</div><div class="line">    this._ = _;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将传入的事件类型存入dispatch对象中。</p>
<h3 id="dispatch-on-typenames-callback"><a href="#dispatch-on-typenames-callback" class="headerlink" title="dispatch.on(typenames[, callback])"></a>dispatch.on(typenames[, callback])</h3><p>用于将事件和回调函数进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">//绑定事件类型和回调函数</div><div class="line">  on: function(typename, callback) &#123;</div><div class="line">      var _ = this._,</div><div class="line">          T = parseTypenames(typename + &quot;&quot;, _),</div><div class="line">          t,</div><div class="line">          i = -1,</div><div class="line">          n = T.length;</div><div class="line"></div><div class="line">      // 如果没有callback参数，则返回以指定type和name注册的callback函数。</div><div class="line">      if (arguments.length &lt; 2) &#123;</div><div class="line">        while (++i &lt; n) if ((t = (typename = T[i]).type) &amp;&amp; (t = get(_[t], typename.name))) return t;</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 如果传入了callback函数，则对指定的type和name设置该回调函数。</div><div class="line">      // 如果callback为null，则可以移除指定的回调函数</div><div class="line">      if (callback != null &amp;&amp; typeof callback !== &quot;function&quot;) throw new Error(&quot;invalid callback: &quot; + callback);</div><div class="line">      while (++i &lt; n) &#123;</div><div class="line">        if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);</div><div class="line">        else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return this;</div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  //获取回调函数</div><div class="line">  function get(type, name) &#123;</div><div class="line">    for (var i = 0, n = type.length, c; i &lt; n; ++i) &#123;</div><div class="line">      if ((c = type[i]).name === name) &#123;</div><div class="line">        return c.value;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //设置回调函数</div><div class="line">  function set$1(type, name, callback) &#123;</div><div class="line">    for (var i = 0, n = type.length; i &lt; n; ++i) &#123;</div><div class="line">      if (type[i].name === name) &#123;</div><div class="line">        //如果type中已有指定的name，则将其从type数组中移除</div><div class="line">        type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    if (callback != null) type.push(&#123;name: name, value: callback&#125;);</div><div class="line">    return type;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>其他方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//对dispatch进行拷贝，对拷贝后的内容进行修改不会影响之前的内容</div><div class="line">copy: function() &#123;</div><div class="line">    var copy = &#123;&#125;, _ = this._;</div><div class="line">    for (var t in _) copy[t] = _[t].slice();</div><div class="line">    return new Dispatch(copy);</div><div class="line">&#125;,</div><div class="line">call: function(type, that) &#123;</div><div class="line">    //第二个参数之后的参数会传入callback函数中</div><div class="line">    if ((n = arguments.length - 2) &gt; 0) for (var args = new Array(n), i = 0, n, t; i &lt; n; ++i) args[i] = arguments[i + 2];</div><div class="line">    if (!this._.hasOwnProperty(type)) throw new Error(&quot;unknown type: &quot; + type);</div><div class="line">    //会调用type下的所有回调函数</div><div class="line">    for (t = this._[type], i = 0, n = t.length; i &lt; n; ++i) t[i].value.apply(that, args);</div><div class="line">&#125;,</div><div class="line">apply: function(type, that, args) &#123;</div><div class="line">    if (!this._.hasOwnProperty(type)) throw new Error(&quot;unknown type: &quot; + type);</div><div class="line">    for (var t = this._[type], i = 0, n = t.length; i &lt; n; ++i) t[i].value.apply(that, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[d3.js源码分析——Hierarchies]]></title>
      <url>http://arlendp.me/web/js/d3js-source-code-hierarchies/</url>
      <content type="html"><![CDATA[<p>d3的hierarchy模块用于层级图的计算，会将输入的数据计算并转换成指定的层级格式提供给开发者使用。为了表示这种数据间的层级关系，该模块在内部使用了四叉树这种数据结构。<br><a id="more"></a></p>
<h2 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h2><p>用于计算层级数据，在层级图中使用。</p>
<h3 id="d3-hierarchy"><a href="#d3-hierarchy" class="headerlink" title="d3.hierarchy"></a>d3.hierarchy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * 处理层级数据</div><div class="line">   * @param  &#123;object&#125; data     输入的数据</div><div class="line">   * @param  &#123;function&#125; children 用于获取data中的children数据的函数</div><div class="line">   * @return &#123;object&#125;          处理后的层级数据</div><div class="line">   */</div><div class="line">function hierarchy(data, children) &#123;</div><div class="line">    var root = new Node(data),</div><div class="line">        valued = +data.value &amp;&amp; (root.value = data.value),</div><div class="line">        node,</div><div class="line">        nodes = [root],</div><div class="line">        child,</div><div class="line">        childs,</div><div class="line">        i,</div><div class="line">        n;</div><div class="line"></div><div class="line">    if (children == null) children = defaultChildren;</div><div class="line">    //先处理父节点，后处理子节点，构造成node对象</div><div class="line">    while (node = nodes.pop()) &#123;</div><div class="line">      if (valued) node.value = +node.data.value;</div><div class="line">      if ((childs = children(node.data)) &amp;&amp; (n = childs.length)) &#123;</div><div class="line">        node.children = new Array(n);</div><div class="line">        for (i = n - 1; i &gt;= 0; --i) &#123;</div><div class="line">          nodes.push(child = node.children[i] = new Node(childs[i]));</div><div class="line">          child.parent = node;</div><div class="line">          child.depth = node.depth + 1;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return root.eachBefore(computeHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>node用于表示hierarchy中的节点对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* node构造函数</div><div class="line">   * data: 该node相关联的数据</div><div class="line">   * depth: 该节点所在的层级数，根节点为0，子节点逐渐递增</div><div class="line">   * height: 该节点与其最远的子节点之间的距离，叶子节点为0</div><div class="line">   * parent: 该节点的父节点</div><div class="line">   */</div><div class="line">function Node(data) &#123;</div><div class="line">    this.data = data;</div><div class="line">    this.depth =</div><div class="line">    this.height = 0;</div><div class="line">    this.parent = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>node的原型方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//返回当前节点的所有父级节点，以当前节点开始逐级向上查找直至根节点</div><div class="line">  function node_ancestors() &#123;</div><div class="line">    var node = this, nodes = [node];</div><div class="line">    while (node = node.parent) &#123;</div><div class="line">      nodes.push(node);</div><div class="line">    &#125;</div><div class="line">    return nodes;</div><div class="line">  &#125;</div><div class="line">  //返回当前节点的所有子节点，包括当前节点</div><div class="line">  function node_descendants() &#123;</div><div class="line">    var nodes = [];</div><div class="line">    this.each(function(node) &#123;</div><div class="line">      nodes.push(node);</div><div class="line">    &#125;);</div><div class="line">    return nodes;</div><div class="line">  &#125;</div><div class="line">  //返回当前节点包含的所有叶子节点</div><div class="line">  function node_leaves() &#123;</div><div class="line">    var leaves = [];</div><div class="line">    this.eachBefore(function(node) &#123;</div><div class="line">      if (!node.children) &#123;</div><div class="line">        leaves.push(node);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    return leaves;</div><div class="line">  &#125;</div><div class="line">  //以节点的父节点和本身构成一个新的对象，返回包含所有该种对象的数组</div><div class="line">  function node_links() &#123;</div><div class="line">    var root = this, links = [];</div><div class="line">    root.each(function(node) &#123;</div><div class="line">      if (node !== root) &#123; // Don’t include the root’s parent, if any.</div><div class="line">        links.push(&#123;source: node.parent, target: node&#125;);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    return links;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>根据node的不同的遍历方式而有不同的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//广度优先？？？</div><div class="line">  function node_each(callback) &#123;</div><div class="line">    var node = this, current, next = [node], children, i, n;</div><div class="line">    do &#123;</div><div class="line">      current = next.reverse(), next = [];</div><div class="line">      while (node = current.pop()) &#123;</div><div class="line">        callback(node), children = node.children;</div><div class="line">        if (children) for (i = 0, n = children.length; i &lt; n; ++i) &#123;</div><div class="line">          next.push(children[i]);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; while (next.length);</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line">  // 先处理回调函数，后访问子节点</div><div class="line">  function node_eachBefore(callback) &#123;</div><div class="line">    var node = this, nodes = [node], children, i;</div><div class="line">    while (node = nodes.pop()) &#123;</div><div class="line">      callback(node), children = node.children;</div><div class="line">      if (children) for (i = children.length - 1; i &gt;= 0; --i) &#123;</div><div class="line">        nodes.push(children[i]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line">  //先访问所有节点，之后逐个执行回调</div><div class="line">  function node_eachAfter(callback) &#123;</div><div class="line">    var node = this, nodes = [node], next = [], children, i, n;</div><div class="line">    while (node = nodes.pop()) &#123;</div><div class="line">      next.push(node), children = node.children;</div><div class="line">      if (children) for (i = 0, n = children.length; i &lt; n; ++i) &#123;</div><div class="line">        nodes.push(children[i]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    while (node = next.pop()) &#123;</div><div class="line">      callback(node);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>而在这些遍历方法的基础上构造出来的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">//通过value函数对每个节点的data进行计算，节点的value值为其自己的value值加上所有子节点的value值之和。</div><div class="line">  function node_sum(value) &#123;</div><div class="line">    return this.eachAfter(function(node) &#123;</div><div class="line">      var sum = +value(node.data) || 0,</div><div class="line">          children = node.children,</div><div class="line">          i = children &amp;&amp; children.length;</div><div class="line">      while (--i &gt;= 0) sum += children[i].value;</div><div class="line">      node.value = sum;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  //对所有节点的子节点进行排序，内部调用Array的原型链方法</div><div class="line">  function node_sort(compare) &#123;</div><div class="line">    return this.eachBefore(function(node) &#123;</div><div class="line">      if (node.children) &#123;</div><div class="line">        node.children.sort(compare);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  //计算当前node到end的最短路径，返回的数组从当前节点的父节点开始到公共节点，然后到目标节点</div><div class="line">  function node_path(end) &#123;</div><div class="line">    var start = this,</div><div class="line">        ancestor = leastCommonAncestor(start, end),</div><div class="line">        nodes = [start];</div><div class="line">    //从start开始向上查找至ancestor</div><div class="line">    while (start !== ancestor) &#123;</div><div class="line">      start = start.parent;</div><div class="line">      nodes.push(start);</div><div class="line">    &#125;</div><div class="line">    var k = nodes.length;</div><div class="line">    while (end !== ancestor) &#123;</div><div class="line"></div><div class="line">      nodes.splice(k, 0, end);</div><div class="line">      end = end.parent;</div><div class="line">    &#125;</div><div class="line">    return nodes;</div><div class="line">  &#125;</div><div class="line">  //返回最近的相同的祖先节点</div><div class="line">  function leastCommonAncestor(a, b) &#123;</div><div class="line">    if (a === b) return a;</div><div class="line">    var aNodes = a.ancestors(),</div><div class="line">        bNodes = b.ancestors(),</div><div class="line">        c = null;</div><div class="line">    a = aNodes.pop();</div><div class="line">    b = bNodes.pop();</div><div class="line">    while (a === b) &#123;</div><div class="line">      c = a;</div><div class="line">      a = aNodes.pop();</div><div class="line">      b = bNodes.pop();</div><div class="line">    &#125;</div><div class="line">    return c;</div><div class="line">  &#125;</div><div class="line">  //复制一份相同的node</div><div class="line">  function node_copy() &#123;</div><div class="line">    return hierarchy(this).eachBefore(copyData);</div><div class="line">  &#125;</div><div class="line">  function copyData(node) &#123;</div><div class="line">    node.data = node.data.data;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Stratify"><a href="#Stratify" class="headerlink" title="Stratify"></a>Stratify</h2><p>将数据转化为层级形式。若数据格式已经是如下形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var data = &#123;</div><div class="line">        &quot;name&quot;: &quot;中国&quot;,</div><div class="line">        &quot;children&quot;: [&#123;</div><div class="line">                &quot;name&quot;: &quot;浙江&quot;,</div><div class="line">                &quot;children&quot;: [&#123;</div><div class="line">                    &quot;name&quot;: &quot;杭州&quot;</div><div class="line">                &#125;, &#123;</div><div class="line">                    &quot;name&quot;: &quot;宁波&quot;</div><div class="line">                &#125;, &#123;</div><div class="line">                    &quot;name&quot;: &quot;温州&quot;</div><div class="line">                &#125;, &#123;</div><div class="line">                    &quot;name&quot;: &quot;绍兴&quot;</div><div class="line">                &#125;]</div><div class="line">            &#125;,</div><div class="line"></div><div class="line">            &#123;</div><div class="line">                &quot;name&quot;: &quot;广西&quot;,</div><div class="line">                &quot;children&quot;: [&#123;</div><div class="line">                    &quot;name&quot;: &quot;桂林&quot;</div><div class="line">                &#125;, &#123;</div><div class="line">                    &quot;name&quot;: &quot;南宁&quot;</div><div class="line">                &#125;, &#123;</div><div class="line">                    &quot;name&quot;: &quot;柳州&quot;</div><div class="line">                &#125;, &#123;</div><div class="line">                    &quot;name&quot;: &quot;防城港&quot;</div><div class="line">                &#125;]</div><div class="line">            &#125;]</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>则可以直接传入上述<code>d3.hierarchy</code>方法来构造层级数据。若不是则用<code>d3.stratify</code>方法来处理，其关键部分是’id’和’parentId’方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">//d3.stratify</div><div class="line">function stratify() &#123;</div><div class="line">    var id = defaultId,</div><div class="line">        parentId = defaultParentId;</div><div class="line"></div><div class="line">    function stratify(data) &#123;</div><div class="line">      var d,</div><div class="line">          i,</div><div class="line">          n = data.length,</div><div class="line">          root,</div><div class="line">          parent,</div><div class="line">          node,</div><div class="line">          nodes = new Array(n),</div><div class="line">          nodeId,</div><div class="line">          nodeKey,</div><div class="line">          nodeByKey = &#123;&#125;;</div><div class="line"></div><div class="line">      for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">        //将data中每个数据构造成node对象</div><div class="line">        d = data[i], node = nodes[i] = new Node(d);</div><div class="line">        //根据id函数获取data的id</div><div class="line">        if ((nodeId = id(d, i, data)) != null &amp;&amp; (nodeId += &quot;&quot;)) &#123;</div><div class="line">          nodeKey = keyPrefix$1 + (node.id = nodeId);</div><div class="line">          nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">        node = nodes[i], nodeId = parentId(data[i], i, data);</div><div class="line">        //parentId为空时认为该node为根节点，但只能存在一个parentId为空的节点</div><div class="line">        if (nodeId == null || !(nodeId += &quot;&quot;)) &#123;</div><div class="line">          if (root) throw new Error(&quot;multiple roots&quot;);</div><div class="line">          root = node;</div><div class="line">        &#125; else &#123;</div><div class="line">          parent = nodeByKey[keyPrefix$1 + nodeId];</div><div class="line">          //如果记录中没有parentId，则抛出异常</div><div class="line">          if (!parent) throw new Error(&quot;missing: &quot; + nodeId);</div><div class="line">          if (parent === ambiguous) throw new Error(&quot;ambiguous: &quot; + nodeId);</div><div class="line">          //将该节点添加至parentId对应节点的children属性中</div><div class="line">          if (parent.children) parent.children.push(node);</div><div class="line">          else parent.children = [node];</div><div class="line">          //为node节点添加parent属性</div><div class="line">          node.parent = parent;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (!root) throw new Error(&quot;no root&quot;);</div><div class="line">      root.parent = preroot;</div><div class="line">      //计算节点的depth和height值</div><div class="line">      root.eachBefore(function(node) &#123; node.depth = node.parent.depth + 1; --n; &#125;).eachBefore(computeHeight);</div><div class="line">      root.parent = null;</div><div class="line">      if (n &gt; 0) throw new Error(&quot;cycle&quot;);</div><div class="line"></div><div class="line">      return root;</div><div class="line">    &#125;</div><div class="line">    //设置获取id的函数</div><div class="line">    stratify.id = function(x) &#123;</div><div class="line">      return arguments.length ? (id = required(x), stratify) : id;</div><div class="line">    &#125;;</div><div class="line">    //设置获取父节点id的函数</div><div class="line">    stratify.parentId = function(x) &#123;</div><div class="line">      return arguments.length ? (parentId = required(x), stratify) : parentId;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return stratify;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p>用于绘制集群图，它会将所有的叶子节点放置在相同的深度，即所有的叶子节点会对齐。这里返回的结果包含(x, y)坐标，即可以直接用于绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">//d3.cluster</div><div class="line">function cluster() &#123;</div><div class="line">    var separation = defaultSeparation,</div><div class="line">        dx = 1,</div><div class="line">        dy = 1,</div><div class="line">        nodeSize = false;</div><div class="line"></div><div class="line">    function cluster(root) &#123;</div><div class="line">      var previousNode,</div><div class="line">          x = 0;</div><div class="line"></div><div class="line">      root.eachAfter(function(node) &#123;</div><div class="line">        var children = node.children;</div><div class="line">        if (children) &#123;</div><div class="line">          //计算非叶子节点的x、y坐标，与其子节点相关</div><div class="line">          node.x = meanX(children);</div><div class="line">          node.y = maxY(children);</div><div class="line">        &#125; else &#123;</div><div class="line">          // 如果是叶子节点，则其y坐标为0，x坐标则根据当前节点与前一个节点是否含有相同的父节点来设置</div><div class="line">          node.x = previousNode ? x += separation(node, previousNode) : 0;</div><div class="line">          node.y = 0;</div><div class="line">          previousNode = node;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      var left = leafLeft(root),</div><div class="line">          right = leafRight(root),</div><div class="line">          x0 = left.x - separation(left, right) / 2,</div><div class="line">          x1 = right.x + separation(right, left) / 2;</div><div class="line"></div><div class="line">      // 根据size大小对节点的x, y坐标进行调整</div><div class="line">      return root.eachAfter(nodeSize ? function(node) &#123;</div><div class="line">        //nodeSize为true时，将root放置于(0, 0)位置</div><div class="line">        node.x = (node.x - root.x) * dx;</div><div class="line">        node.y = (root.y - node.y) * dy;</div><div class="line">      &#125; : function(node) &#123;</div><div class="line">        //否则，按比例对节点坐标进行调整</div><div class="line">        node.x = (node.x - x0) / (x1 - x0) * dx;</div><div class="line">        node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    //separation用于将相邻的叶子节点进行分离</div><div class="line">    cluster.separation = function(x) &#123;</div><div class="line">      return arguments.length ? (separation = x, cluster) : separation;</div><div class="line">    &#125;;</div><div class="line">    //以数组的形式设置cluster的范围大小</div><div class="line">    cluster.size = function(x) &#123;</div><div class="line">      return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    cluster.nodeSize = function(x) &#123;</div><div class="line">      return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return cluster;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p>用于产生树状布局，以根节点位置为基准，逐级对齐。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<h2 id="Treemap"><a href="#Treemap" class="headerlink" title="Treemap"></a>Treemap</h2><p>用于产生矩形式树状结构图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">//d3.treemap</div><div class="line">function index$1() &#123;</div><div class="line">    var tile = squarify,</div><div class="line">        round = false,</div><div class="line">        dx = 1,</div><div class="line">        dy = 1,</div><div class="line">        paddingStack = [0],</div><div class="line">        paddingInner = constantZero,</div><div class="line">        paddingTop = constantZero,</div><div class="line">        paddingRight = constantZero,</div><div class="line">        paddingBottom = constantZero,</div><div class="line">        paddingLeft = constantZero;</div><div class="line"></div><div class="line">    function treemap(root) &#123;</div><div class="line">      root.x0 =</div><div class="line">      root.y0 = 0;</div><div class="line">      root.x1 = dx;</div><div class="line">      root.y1 = dy;</div><div class="line">      root.eachBefore(positionNode);</div><div class="line">      paddingStack = [0];</div><div class="line">      if (round) root.eachBefore(roundNode);</div><div class="line">      return root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function positionNode(node) &#123;</div><div class="line">      var p = paddingStack[node.depth],</div><div class="line">          //将有效区域根据padding来缩小</div><div class="line">          x0 = node.x0 + p,</div><div class="line">          y0 = node.y0 + p,</div><div class="line">          x1 = node.x1 - p,</div><div class="line">          y1 = node.y1 - p;</div><div class="line">      //处理padding过大的情况</div><div class="line">      if (x1 &lt; x0) x0 = x1 = (x0 + x1) / 2;</div><div class="line">      if (y1 &lt; y0) y0 = y1 = (y0 + y1) / 2;</div><div class="line">      node.x0 = x0;</div><div class="line">      node.y0 = y0;</div><div class="line">      node.x1 = x1;</div><div class="line">      node.y1 = y1;</div><div class="line">      if (node.children) &#123;</div><div class="line">        p = paddingStack[node.depth + 1] = paddingInner(node) / 2;</div><div class="line">        //在调整了范围的基础上根据特定的padding再次进行调整</div><div class="line">        x0 += paddingLeft(node) - p;</div><div class="line">        y0 += paddingTop(node) - p;</div><div class="line">        x1 -= paddingRight(node) - p;</div><div class="line">        y1 -= paddingBottom(node) - p;</div><div class="line">        if (x1 &lt; x0) x0 = x1 = (x0 + x1) / 2;</div><div class="line">        if (y1 &lt; y0) y0 = y1 = (y0 + y1) / 2;</div><div class="line">        tile(node, x0, y0, x1, y1);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    treemap.round = function(x) &#123;</div><div class="line">      return arguments.length ? (round = !!x, treemap) : round;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    treemap.size = function(x) &#123;</div><div class="line">      return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];</div><div class="line">    &#125;;</div><div class="line">    //设置tile函数，默认是d3.treemapSquarify，即按黄金分割比进行划分</div><div class="line">    treemap.tile = function(x) &#123;</div><div class="line">      return arguments.length ? (tile = required(x), treemap) : tile;</div><div class="line">    &#125;;</div><div class="line">    //同时设置paddingInner和paddingOuter</div><div class="line">    treemap.padding = function(x) &#123;</div><div class="line">      return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    treemap.paddingInner = function(x) &#123;</div><div class="line">      return arguments.length ? (paddingInner = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingInner;</div><div class="line">    &#125;;</div><div class="line">    //paddingOuter是由四个方向的padding构成</div><div class="line">    treemap.paddingOuter = function(x) &#123;</div><div class="line">      return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    treemap.paddingTop = function(x) &#123;</div><div class="line">      return arguments.length ? (paddingTop = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingTop;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    treemap.paddingRight = function(x) &#123;</div><div class="line">      return arguments.length ? (paddingRight = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingRight;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    treemap.paddingBottom = function(x) &#123;</div><div class="line">      return arguments.length ? (paddingBottom = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingBottom;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    treemap.paddingLeft = function(x) &#123;</div><div class="line">      return arguments.length ? (paddingLeft = typeof x === &quot;function&quot; ? x : constant$5(+x), treemap) : paddingLeft;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return treemap;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>d3.treemap</code>中会对node进行区块划分，其中主要是用到<code>tile</code>函数来实现模块划分的逻辑，默认是<code>d3.treemapSquarify</code>即按黄金分割比进行区块的分割。</p>
<h3 id="d3-treemapSquarify"><a href="#d3-treemapSquarify" class="headerlink" title="d3.treemapSquarify"></a>d3.treemapSquarify</h3><p>通过黄金分割比来对treemap进行分割。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">//黄金分割比</div><div class="line">var phi = (1 + Math.sqrt(5)) / 2;</div><div class="line">//按黄金分割比对treenode区块进行划分</div><div class="line">var squarify = (function custom(ratio) &#123;</div><div class="line"></div><div class="line">    function squarify(parent, x0, y0, x1, y1) &#123;</div><div class="line">      squarifyRatio(ratio, parent, x0, y0, x1, y1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    squarify.ratio = function(x) &#123;</div><div class="line">      return custom((x = +x) &gt; 1 ? x : 1);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return squarify;</div><div class="line">&#125;)(phi);</div><div class="line"></div><div class="line">function squarifyRatio(ratio, parent, x0, y0, x1, y1) &#123;</div><div class="line">    var rows = [],</div><div class="line">        nodes = parent.children,</div><div class="line">        row,</div><div class="line">        nodeValue,</div><div class="line">        i0 = 0,</div><div class="line">        i1,</div><div class="line">        n = nodes.length,</div><div class="line">        dx, dy,</div><div class="line">        value = parent.value,</div><div class="line">        sumValue,</div><div class="line">        minValue,</div><div class="line">        maxValue,</div><div class="line">        newRatio,</div><div class="line">        minRatio,</div><div class="line">        alpha,</div><div class="line">        beta;</div><div class="line"></div><div class="line">    while (i0 &lt; n) &#123;</div><div class="line">      dx = x1 - x0, dy = y1 - y0;</div><div class="line">      minValue = maxValue = sumValue = nodes[i0].value;</div><div class="line">      //根据长宽比和黄金分割比计算alpha，其值不受子节点影响</div><div class="line">      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);</div><div class="line">      beta = sumValue * sumValue * alpha;</div><div class="line">      minRatio = Math.max(maxValue / beta, beta / minValue);</div><div class="line"></div><div class="line">      // 当ratio不增加时，添加node</div><div class="line">      for (i1 = i0 + 1; i1 &lt; n; ++i1) &#123;</div><div class="line">        sumValue += nodeValue = nodes[i1].value;</div><div class="line">        if (nodeValue &lt; minValue) minValue = nodeValue;</div><div class="line">        if (nodeValue &gt; maxValue) maxValue = nodeValue;</div><div class="line">        beta = sumValue * sumValue * alpha;</div><div class="line">        newRatio = Math.max(maxValue / beta, beta / minValue);</div><div class="line">        //不会添加使ratio增加的node，如果不满足退出循环</div><div class="line">        if (newRatio &gt; minRatio) &#123; sumValue -= nodeValue; break; &#125;</div><div class="line">        minRatio = newRatio;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 调整node的范围并确定分割的方向</div><div class="line">      rows.push(row = &#123;value: sumValue, dice: dx &lt; dy, children: nodes.slice(i0, i1)&#125;);</div><div class="line">      //当node区域长比宽短时</div><div class="line">      if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);</div><div class="line">      //当node区域宽比长短时</div><div class="line">      else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);</div><div class="line">      //value等于剩余未分配位置的node的value之和，i0也从未分配的node开始</div><div class="line">      value -= sumValue, i0 = i1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return rows;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-treemapBinary"><a href="#d3-treemapBinary" class="headerlink" title="d3.treemapBinary"></a>d3.treemapBinary</h3><p>将treemap区域根据value值大致进行二等分，使两边的value值之和尽量相近。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">//d3.treemapBinary</div><div class="line">function binary(parent, x0, y0, x1, y1) &#123;</div><div class="line">    var nodes = parent.children,</div><div class="line">        i, n = nodes.length,</div><div class="line">        sum, sums = new Array(n + 1);</div><div class="line"></div><div class="line">    for (sums[0] = sum = i = 0; i &lt; n; ++i) &#123;</div><div class="line">      sums[i + 1] = sum += nodes[i].value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    partition(0, n, parent.value, x0, y0, x1, y1);</div><div class="line"></div><div class="line">    function partition(i, j, value, x0, y0, x1, y1) &#123;</div><div class="line">      if (i &gt;= j - 1) &#123;</div><div class="line">        var node = nodes[i];</div><div class="line">        node.x0 = x0, node.y0 = y0;</div><div class="line">        node.x1 = x1, node.y1 = y1;</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var valueOffset = sums[i],</div><div class="line">          //加上前面的已经计算过的value值作为偏移量，这样才能将sums[mid]跟valueTarget进行比较</div><div class="line">          valueTarget = (value / 2) + valueOffset,</div><div class="line">          k = i + 1,</div><div class="line">          hi = j - 1;</div><div class="line">      //二分法查找</div><div class="line">      while (k &lt; hi) &#123;</div><div class="line">        var mid = k + hi &gt;&gt;&gt; 1;</div><div class="line">        if (sums[mid] &lt; valueTarget) k = mid + 1;</div><div class="line">        else hi = mid;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var valueLeft = sums[k] - valueOffset,</div><div class="line">          valueRight = value - valueLeft;</div><div class="line">      //当矩形较高时，进行上下分割</div><div class="line">      if ((y1 - y0) &gt; (x1 - x0)) &#123;</div><div class="line">        //根据左右的value和进行坐标划分</div><div class="line">        var yk = (y0 * valueRight + y1 * valueLeft) / value;</div><div class="line">        partition(i, k, valueLeft, x0, y0, x1, yk);</div><div class="line">        partition(k, j, valueRight, x0, yk, x1, y1);</div><div class="line">      &#125; </div><div class="line">      //否则进行左右分割</div><div class="line">      else &#123;</div><div class="line">        var xk = (x0 * valueRight + x1 * valueLeft) / value;</div><div class="line">        partition(i, k, valueLeft, x0, y0, xk, y1);</div><div class="line">        partition(k, j, valueRight, xk, y0, x1, y1);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><p>节点以矩形区域的形式展现，节点间的相对位置可以看出其层级关系。同时区块的大小可以反映value值大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//d3.partition</div><div class="line">function partition() &#123;</div><div class="line">    var dx = 1,</div><div class="line">        dy = 1,</div><div class="line">        padding = 0,</div><div class="line">        round = false;</div><div class="line"></div><div class="line">    function partition(root) &#123;</div><div class="line">      var n = root.height + 1;</div><div class="line">      root.x0 =</div><div class="line">      root.y0 = padding;</div><div class="line">      root.x1 = dx;</div><div class="line">      root.y1 = dy / n;</div><div class="line">      root.eachBefore(positionNode(dy, n));</div><div class="line">      if (round) root.eachBefore(roundNode);</div><div class="line">      return root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function positionNode(dy, n) &#123;</div><div class="line">      return function(node) &#123;</div><div class="line">        if (node.children) &#123;</div><div class="line">          treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);</div><div class="line">        &#125;</div><div class="line">        var x0 = node.x0,</div><div class="line">            y0 = node.y0,</div><div class="line">            //这里减去padding用于与下个兄弟节点分开</div><div class="line">            x1 = node.x1 - padding,</div><div class="line">            y1 = node.y1 - padding;</div><div class="line">        if (x1 &lt; x0) x0 = x1 = (x0 + x1) / 2;</div><div class="line">        if (y1 &lt; y0) y0 = y1 = (y0 + y1) / 2;</div><div class="line">        node.x0 = x0;</div><div class="line">        node.y0 = y0;</div><div class="line">        node.x1 = x1;</div><div class="line">        node.y1 = y1;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    partition.round = function(x) &#123;</div><div class="line">      return arguments.length ? (round = !!x, partition) : round;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    partition.size = function(x) &#123;</div><div class="line">      return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];</div><div class="line">    &#125;;</div><div class="line">    //padding用于将节点的相邻子节点分开</div><div class="line">    partition.padding = function(x) &#123;</div><div class="line">      return arguments.length ? (padding = +x, partition) : padding;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return partition;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Pack"><a href="#Pack" class="headerlink" title="Pack"></a>Pack</h2><p>通过多个封闭圆来表现层级图。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[d3.js源码分析——Quadtrees]]></title>
      <url>http://arlendp.me/web/js/d3js-source-code-quadtrees/</url>
      <content type="html"><![CDATA[<p>四叉树算法用于将二维空间划分成更多的矩形部分，将每个矩形划分成四个大小相等的区域，常用于碰撞检测算法，d3中的forceCollide、forceManyBody等都用到了该数据结构。<br><a id="more"></a></p>
<h2 id="d3-quadtree"><a href="#d3-quadtree" class="headerlink" title="d3.quadtree"></a>d3.quadtree</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * d3.quadtree用于生成四叉树</div><div class="line">   * @param  &#123;object&#125; nodes 将要添加到quadtree中的所有节点</div><div class="line">   * @param  &#123;function&#125; x     用于获取节点的x坐标的函数</div><div class="line">   * @param  &#123;function&#125; y     用于获取节点的y坐标的函数</div><div class="line">   * @return &#123;object&#125;       该quadtree对象</div><div class="line">   */</div><div class="line">function quadtree(nodes, x, y) &#123;</div><div class="line">    var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);</div><div class="line">    return nodes == null ? tree : tree.addAll(nodes);</div><div class="line">&#125;</div><div class="line">  /**</div><div class="line">   * 四叉树的构造函数</div><div class="line">   * @param &#123;function&#125; x  获取x坐标</div><div class="line">   * @param &#123;function&#125; y  获取y坐标</div><div class="line">   * @param &#123;number&#125; x0 [x0, y0]到[x1, y1]为该quadtree的矩形区域的范围</div><div class="line">   * @param &#123;number&#125; y0 [x0, y0]到[x1, y1]为该quadtree的矩形区域的范围</div><div class="line">   * @param &#123;number&#125; x1 [x0, y0]到[x1, y1]为该quadtree的矩形区域的范围</div><div class="line">   * @param &#123;number&#125; y1 [x0, y0]到[x1, y1]为该quadtree的矩形区域的范围</div><div class="line">   */</div><div class="line">function Quadtree(x, y, x0, y0, x1, y1) &#123;</div><div class="line">    this._x = x;</div><div class="line">    this._y = y;</div><div class="line">    this._x0 = x0;</div><div class="line">    this._y0 = y0;</div><div class="line">    this._x1 = x1;</div><div class="line">    this._y1 = y1;</div><div class="line">    this._root = undefined;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-add"><a href="#quadtree-add" class="headerlink" title="quadtree.add"></a>quadtree.add</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">function tree_add(d) &#123;</div><div class="line">    var x = +this._x.call(null, d),</div><div class="line">        y = +this._y.call(null, d);</div><div class="line">    return add(this.cover(x, y), x, y, d);</div><div class="line">  &#125;</div><div class="line">  /* d3.quadtree的add方法，用于添加node</div><div class="line">   * add方法的执行流程如下：</div><div class="line">   * 1. 首次添加data0时，由于_root不存在，直接对其赋值data并返回。</div><div class="line">   * 2. 第二次添加data1时，node中此时是第一次添加的data0，执行do while循环，为_root赋值一个空数组。判断data1和data0是否是在一个象限(这里将一个区域划分成的四块叫做象限)，如果不在则根据索引分别添加至数组中；</div><div class="line">   * 如果在则对该象限再次划分四个区域，继续判断是否在同一个象限。</div><div class="line">   * 3. 之后每次添加data时，都会先查找该节点属于哪个象限，根据索引查找node，如果是数组则说明该区域有节点且已经再次划分了象限，则继续进入查找；如果是对象，则说明该区域只有一个节点，此时会对该区域进行划分执行步骤2中的过程；如果是undefined则直接插入该出。</div><div class="line">   * </div><div class="line">   */</div><div class="line">function add(tree, x, y, d) &#123;</div><div class="line">    if (isNaN(x) || isNaN(y)) return tree;</div><div class="line"></div><div class="line">    var parent,</div><div class="line">        node = tree._root,</div><div class="line">        leaf = &#123;data: d&#125;,</div><div class="line">        x0 = tree._x0,</div><div class="line">        y0 = tree._y0,</div><div class="line">        x1 = tree._x1,</div><div class="line">        y1 = tree._y1,</div><div class="line">        //(xm, ym)表示该区域的中心点</div><div class="line">        xm,</div><div class="line">        ym,</div><div class="line">        xp,</div><div class="line">        yp,</div><div class="line">        right,</div><div class="line">        bottom,</div><div class="line">        i,</div><div class="line">        j;</div><div class="line"></div><div class="line">    // 如果treenode当前不包含任何node，将leaf作为其节点</div><div class="line">    if (!node) return tree._root = leaf, tree;</div><div class="line"></div><div class="line">    // 看(x, y)是否和已有的点在一个象限中，若不是则直接插入，否则往下继续执行</div><div class="line">    while (node.length) &#123;</div><div class="line">      if (right = x &gt;= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;</div><div class="line">      if (bottom = y &gt;= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;</div><div class="line">      if (parent = node, !(node = node[i = bottom &lt;&lt; 1 | right])) return parent[i] = leaf, tree;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 判断(x, y)是否已存在当前节点中</div><div class="line">    xp = +tree._x.call(null, node.data);</div><div class="line">    yp = +tree._y.call(null, node.data);</div><div class="line">    if (x === xp &amp;&amp; y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;</div><div class="line"></div><div class="line">    // 将当前区域进行划分，直至(x, y)和之前的节点不在同一个象限内</div><div class="line">    do &#123;</div><div class="line">      //parent = parent[i] = new Array(4)会为parent赋值一个空数组，但是由于node = parent，node会形成一个多维数组</div><div class="line">      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);</div><div class="line">      if (right = x &gt;= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;</div><div class="line">      if (bottom = y &gt;= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;</div><div class="line">    &#125; while ((i = bottom &lt;&lt; 1 | right) === (j = (yp &gt;= ym) &lt;&lt; 1 | (xp &gt;= xm)));</div><div class="line">    return parent[j] = node, parent[i] = leaf, tree;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-addAll"><a href="#quadtree-addAll" class="headerlink" title="quadtree.addAll"></a>quadtree.addAll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//d3.quadtree的addAll方法，先计算数据的范围调整quadtree，之后再添加数据</div><div class="line">function addAll(data) &#123;</div><div class="line">    var d, i, n = data.length,</div><div class="line">        x,</div><div class="line">        y,</div><div class="line">        xz = new Array(n),</div><div class="line">        yz = new Array(n),</div><div class="line">        x0 = Infinity,</div><div class="line">        y0 = Infinity,</div><div class="line">        x1 = -Infinity,</div><div class="line">        y1 = -Infinity;</div><div class="line"></div><div class="line">    // 根据_x和_y方法计算data值，得到x、y的范围[x0, x1]和[y0, y1]，即矩形区域的范围</div><div class="line">    for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">      // this._x和this._y是quadtree中定义的获取x、y坐标的方法</div><div class="line">      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;</div><div class="line">      xz[i] = x;</div><div class="line">      yz[i] = y;</div><div class="line">      if (x &lt; x0) x0 = x;</div><div class="line">      if (x &gt; x1) x1 = x;</div><div class="line">      if (y &lt; y0) y0 = y;</div><div class="line">      if (y &gt; y1) y1 = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 无效点时的处理</div><div class="line">    if (x1 &lt; x0) x0 = this._x0, x1 = this._x1;</div><div class="line">    if (y1 &lt; y0) y0 = this._y0, y1 = this._y1;</div><div class="line"></div><div class="line">    // 为quadtree添加范围</div><div class="line">    this.cover(x0, y0).cover(x1, y1);</div><div class="line"></div><div class="line">    // 添加node</div><div class="line">    for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">      add(this, xz[i], yz[i], data[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-cover"><a href="#quadtree-cover" class="headerlink" title="quadtree.cover"></a>quadtree.cover</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">//为quadtree设置区域范围</div><div class="line">function tree_cover(x, y) &#123;</div><div class="line">    if (isNaN(x = +x) || isNaN(y = +y)) return this;</div><div class="line"></div><div class="line">    var x0 = this._x0,</div><div class="line">        y0 = this._y0,</div><div class="line">        x1 = this._x1,</div><div class="line">        y1 = this._y1;</div><div class="line"></div><div class="line">    // 如果该quadtree范围不存在，则根据当前的(x, y)坐标取范围</div><div class="line">    if (isNaN(x0)) &#123;</div><div class="line">      x1 = (x0 = Math.floor(x)) + 1;</div><div class="line">      y1 = (y0 = Math.floor(y)) + 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果(x, y)在当前范围之外，则扩展当前范围</div><div class="line">    else if (x0 &gt; x || x &gt; x1 || y0 &gt; y || y &gt; y1) &#123;</div><div class="line">      var z = x1 - x0,</div><div class="line">          node = this._root,</div><div class="line">          parent,</div><div class="line">          i;</div><div class="line">      //将该矩形区域的中心看做坐标轴原点，根据x、y坐标轴划分成大小相等的四块区域，0表示右下方，1表示左下方，2表示右上方，3表示左上方。</div><div class="line">      //成倍的增长z，扩大当前范围直至(x, y)在当前区域内，在扩大范围的同时不断的构造node数组</div><div class="line">      switch (i = (y &lt; (y0 + y1) / 2) &lt;&lt; 1 | (x &lt; (x0 + x1) / 2)) &#123;</div><div class="line">        case 0: &#123;</div><div class="line">          do parent = new Array(4), parent[i] = node, node = parent;</div><div class="line">          while (z *= 2, x1 = x0 + z, y1 = y0 + z, x &gt; x1 || y &gt; y1);</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">        case 1: &#123;</div><div class="line">          do parent = new Array(4), parent[i] = node, node = parent;</div><div class="line">          while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 &gt; x || y &gt; y1);</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">        case 2: &#123;</div><div class="line">          do parent = new Array(4), parent[i] = node, node = parent;</div><div class="line">          while (z *= 2, x1 = x0 + z, y0 = y1 - z, x &gt; x1 || y0 &gt; y);</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">        case 3: &#123;</div><div class="line">          do parent = new Array(4), parent[i] = node, node = parent;</div><div class="line">          while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 &gt; x || y0 &gt; y);</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (this._root &amp;&amp; this._root.length) this._root = node;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果(x, y)已经在当前范围内，则直接返回</div><div class="line">    else return this;</div><div class="line"></div><div class="line">    this._x0 = x0;</div><div class="line">    this._y0 = y0;</div><div class="line">    this._x1 = x1;</div><div class="line">    this._y1 = y1;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-extend"><a href="#quadtree-extend" class="headerlink" title="quadtree.extend"></a>quadtree.extend</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//若有参数且_ = [[x0, y0], [x1, y1]]用于通过cover方法设置quadtree的范围[x0, y0]和[x1, y1]；若没有参数，则以同样的数组形式返回当前区域的范围。</div><div class="line">function tree_extent(_) &#123;</div><div class="line">    return arguments.length</div><div class="line">        ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])</div><div class="line">        : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-data"><a href="#quadtree-data" class="headerlink" title="quadtree.data"></a>quadtree.data</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//返回quadtree中所有的node</div><div class="line">function tree_data() &#123;</div><div class="line">    var data = [];</div><div class="line">    this.visit(function(node) &#123;</div><div class="line">      if (!node.length) do data.push(node.data); while (node = node.next)</div><div class="line">    &#125;);</div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-find"><a href="#quadtree-find" class="headerlink" title="quadtree.find"></a>quadtree.find</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">//查找以(x, y)为中心，radius为半径的范围内离中心最近的点</div><div class="line">function tree_find(x, y, radius) &#123;</div><div class="line">    var data,</div><div class="line">      //(x0, y0)和(x3, y3)表示以(x, y)为中心的矩形搜索区域</div><div class="line">        x0 = this._x0,</div><div class="line">        y0 = this._y0,</div><div class="line">      //(x1, y1)和(x2, y2)表示当前node所在的区域范围</div><div class="line">        x1,</div><div class="line">        y1,</div><div class="line">        x2,</div><div class="line">        y2,</div><div class="line">        x3 = this._x1,</div><div class="line">        y3 = this._y1,</div><div class="line">        quads = [],</div><div class="line">        node = this._root,</div><div class="line">        q,</div><div class="line">        i;</div><div class="line"></div><div class="line">    if (node) quads.push(new Quad(node, x0, y0, x3, y3));</div><div class="line">    //若没有设置radius则默认为Infinity</div><div class="line">    if (radius == null) radius = Infinity;</div><div class="line">    else &#123;</div><div class="line">      x0 = x - radius, y0 = y - radius;</div><div class="line">      x3 = x + radius, y3 = y + radius;</div><div class="line">      radius *= radius;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while (q = quads.pop()) &#123;</div><div class="line"></div><div class="line">      // 如果node不存在或者(x, y)在该node范围外则跳过执行</div><div class="line">      if (!(node = q.node)</div><div class="line">          //node所在区域与搜索区域不重叠</div><div class="line">          //</div><div class="line">          //</div><div class="line">          || (x1 = q.x0) &gt; x3</div><div class="line">          || (y1 = q.y0) &gt; y3</div><div class="line">          || (x2 = q.x1) &lt; x0</div><div class="line">          || (y2 = q.y1) &lt; y0) continue;</div><div class="line"></div><div class="line">      // 如果node为数组说明已对其进行了区域划分，开始递归查找</div><div class="line">      if (node.length) &#123;</div><div class="line">        var xm = (x1 + x2) / 2,</div><div class="line">            ym = (y1 + y2) / 2;</div><div class="line">        // node数组中0表示区域左上角，1表示右上角，2表示左下角，3表示右下角</div><div class="line">        quads.push(</div><div class="line">          new Quad(node[3], xm, ym, x2, y2),</div><div class="line">          new Quad(node[2], x1, ym, xm, y2),</div><div class="line">          new Quad(node[1], xm, y1, x2, ym),</div><div class="line">          new Quad(node[0], x1, y1, xm, ym)</div><div class="line">        );</div><div class="line"></div><div class="line">        // 判断(x, y)所在的象限，并将该象限对应的node与栈顶的数据交换位置，如果是左上角区域及表示已是栈顶则不用处理</div><div class="line">        if (i = (y &gt;= ym) &lt;&lt; 1 | (x &gt;= xm)) &#123;</div><div class="line">          q = quads[quads.length - 1];</div><div class="line">          quads[quads.length - 1] = quads[quads.length - 1 - i];</div><div class="line">          quads[quads.length - 1 - i] = q;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 当查找到在搜索范围内的点后，缩小搜索范围</div><div class="line">      else &#123;</div><div class="line">        var dx = x - +this._x.call(null, node.data),</div><div class="line">            dy = y - +this._y.call(null, node.data),</div><div class="line">            d2 = dx * dx + dy * dy;</div><div class="line">        if (d2 &lt; radius) &#123;</div><div class="line">          var d = Math.sqrt(radius = d2);</div><div class="line">          x0 = x - d, y0 = y - d;</div><div class="line">          x3 = x + d, y3 = y + d;</div><div class="line">          data = node.data;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-remove"><a href="#quadtree-remove" class="headerlink" title="quadtree.remove"></a>quadtree.remove</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">function tree_remove(d) &#123;</div><div class="line">    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; </div><div class="line"></div><div class="line">    var parent,</div><div class="line">        node = this._root,</div><div class="line">        retainer,</div><div class="line">        previous,</div><div class="line">        next,</div><div class="line">        x0 = this._x0,</div><div class="line">        y0 = this._y0,</div><div class="line">        x1 = this._x1,</div><div class="line">        y1 = this._y1,</div><div class="line">        x,</div><div class="line">        y,</div><div class="line">        xm,</div><div class="line">        ym,</div><div class="line">        right,</div><div class="line">        bottom,</div><div class="line">        i,</div><div class="line">        j;</div><div class="line"></div><div class="line">    if (!node) return this;</div><div class="line"></div><div class="line">    // 当node中有多个点时，进入查找</div><div class="line">    if (node.length) while (true) &#123;</div><div class="line">      //计算(x, y)所在的象限</div><div class="line">      if (right = x &gt;= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;</div><div class="line">      if (bottom = y &gt;= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;</div><div class="line">      //如果对应的象限中没有点，则说明查找不到该点，直接返回。</div><div class="line">      if (!(parent = node, node = node[i = bottom &lt;&lt; 1 | right])) return this;</div><div class="line">      //如果该象限只有一个点则跳出循环往下执行。</div><div class="line">      if (!node.length) break;</div><div class="line">      //</div><div class="line">      if (parent[(i + 1) &amp; 3] || parent[(i + 2) &amp; 3] || parent[(i + 3) &amp; 3]) retainer = parent, j = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // TODO: 这里存在一个问题，由于node.data和d都为数组，但是两个数据是不同的指针，因此这里不会相等</div><div class="line">    while (node.data !== d) if (!(previous = node, node = node.next)) return this;</div><div class="line">    if (next = node.next) delete node.next;</div><div class="line"></div><div class="line">    // If there are multiple coincident points, remove just the point.</div><div class="line">    if (previous) return (next ? previous.next = next : delete previous.next), this;</div><div class="line"></div><div class="line">    // If this is the root point, remove it.</div><div class="line">    if (!parent) return this._root = next, this;</div><div class="line"></div><div class="line">    // Remove this leaf.</div><div class="line">    next ? parent[i] = next : delete parent[i];</div><div class="line"></div><div class="line">    // If the parent now contains exactly one leaf, collapse superfluous parents.</div><div class="line">    if ((node = parent[0] || parent[1] || parent[2] || parent[3])</div><div class="line">        &amp;&amp; node === (parent[3] || parent[2] || parent[1] || parent[0])</div><div class="line">        &amp;&amp; !node.length) &#123;</div><div class="line">      if (retainer) retainer[j] = node;</div><div class="line">      else this._root = node;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-visit"><a href="#quadtree-visit" class="headerlink" title="quadtree.visit"></a>quadtree.visit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//采用先序遍历的方式，如果callback返回true，则执行不再访问其子节点；否则继续访问其子节点</div><div class="line">function tree_visit(callback) &#123;</div><div class="line">    var quads = [], q, node = this._root, child, x0, y0, x1, y1;</div><div class="line">    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));</div><div class="line">    while (q = quads.pop()) &#123;</div><div class="line">      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) &amp;&amp; node.length) &#123;</div><div class="line">        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;</div><div class="line">        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));</div><div class="line">        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));</div><div class="line">        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));</div><div class="line">        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-visitAfter"><a href="#quadtree-visitAfter" class="headerlink" title="quadtree.visitAfter"></a>quadtree.visitAfter</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//采用后序遍历的方式，先将所有节点存入数组中，然后依次对所有节点进行操作。</div><div class="line">function tree_visitAfter(callback) &#123;</div><div class="line">    var quads = [], next = [], q;</div><div class="line">    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));</div><div class="line">    while (q = quads.pop()) &#123;</div><div class="line">      var node = q.node;</div><div class="line">      if (node.length) &#123;</div><div class="line">        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;</div><div class="line">        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));</div><div class="line">        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));</div><div class="line">        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));</div><div class="line">        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));</div><div class="line">      &#125;</div><div class="line">      next.push(q);</div><div class="line">    &#125;</div><div class="line">    while (q = next.pop()) &#123;</div><div class="line">      callback(q.node, q.x0, q.y0, q.x1, q.y1);</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quadtree-copy"><a href="#quadtree-copy" class="headerlink" title="quadtree.copy"></a>quadtree.copy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//对quadtree进行复制，但是是通过引用来复制的而不是复制值。</div><div class="line">treeProto.copy = function() &#123;</div><div class="line">    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),</div><div class="line">        node = this._root,</div><div class="line">        nodes,</div><div class="line">        child;</div><div class="line"></div><div class="line">    if (!node) return copy;</div><div class="line"></div><div class="line">    if (!node.length) return copy._root = leaf_copy(node), copy;</div><div class="line"></div><div class="line">    nodes = [&#123;source: node, target: copy._root = new Array(4)&#125;];</div><div class="line">    while (node = nodes.pop()) &#123;</div><div class="line">      for (var i = 0; i &lt; 4; ++i) &#123;</div><div class="line">        if (child = node.source[i]) &#123;</div><div class="line">          if (child.length) nodes.push(&#123;source: child, target: node.target[i] = new Array(4)&#125;);</div><div class="line">          else node.target[i] = leaf_copy(child);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return copy;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//复制叶子节点</div><div class="line">function leaf_copy(leaf) &#123;</div><div class="line">    var copy = &#123;data: leaf.data&#125;, next = copy;</div><div class="line">    while (leaf = leaf.next) next = next.next = &#123;data: leaf.data&#125;;</div><div class="line">    return copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="quad对象"><a href="#quad对象" class="headerlink" title="quad对象"></a>quad对象</h2><p>在quadtree的一些方法中使用到了quad对象用于存储quadtree中的node信息，包括node的值和其所在区域的坐标范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * Quad构造函数</div><div class="line">   * @param &#123;object&#125; node 节点数据</div><div class="line">   * @param &#123;number&#125; x0   该节点的区域坐标范围</div><div class="line">   * @param &#123;number&#125; y0   该节点的区域坐标范围</div><div class="line">   * @param &#123;number&#125; x1   该节点的区域坐标范围</div><div class="line">   * @param &#123;number&#125; y1   该节点的区域坐标范围</div><div class="line">   *</div><div class="line">   * quad对象在quadtree的node中的位置如下：</div><div class="line">   * </div><div class="line">   *        |</div><div class="line">   *    0   |    1</div><div class="line">   *        |</div><div class="line">   * -------|--------</div><div class="line">   *        |</div><div class="line">   *    2   |    3</div><div class="line">   *        |</div><div class="line">   */</div><div class="line">function Quad(node, x0, y0, x1, y1) &#123;</div><div class="line">    this.node = node;</div><div class="line">    this.x0 = x0;</div><div class="line">    this.y0 = y0;</div><div class="line">    this.x1 = x1;</div><div class="line">    this.y1 = y1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[d3.js源码分析——Force]]></title>
      <url>http://arlendp.me/web/js/d3js-source-code-force/</url>
      <content type="html"><![CDATA[<p>该模块用于模拟在粒子上的物理作用力，常用于网络图和层级图。<br><a id="more"></a></p>
<h2 id="Simulation"><a href="#Simulation" class="headerlink" title="Simulation"></a>Simulation</h2><h3 id="d3-forceSimulation"><a href="#d3-forceSimulation" class="headerlink" title="d3.forceSimulation"></a>d3.forceSimulation</h3><p>根据指定的nodes值创建一个新的simulation，此时还没有设置force函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line">//d3.forceSimulation用于设置节点和相关参数</div><div class="line">function simulation(nodes) &#123;</div><div class="line">    var simulation,</div><div class="line">        //alpha表示simulation当前的状态</div><div class="line">        alpha = 1,</div><div class="line">        alphaMin = 0.001,</div><div class="line">        //alphaDecay表示alpha每次的衰减率</div><div class="line">        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),</div><div class="line">        //alphaTarget表示最终要稳定时的状态</div><div class="line">        alphaTarget = 0,</div><div class="line">        //velocityDecay表示速度的衰退率</div><div class="line">        velocityDecay = 0.6,</div><div class="line">        //用于存储force函数</div><div class="line">        forces = map$1(),</div><div class="line">        stepper = timer(step),</div><div class="line">        //simulation包含以下两种类型的事件</div><div class="line">        event = dispatch(&quot;tick&quot;, &quot;end&quot;);</div><div class="line"></div><div class="line">    if (nodes == null) nodes = [];</div><div class="line"></div><div class="line">    function step() &#123;</div><div class="line">      tick();</div><div class="line">      //自定义的tick函数，在这里被调用</div><div class="line">      event.call(&quot;tick&quot;, simulation);</div><div class="line">      //当alpha小于临界值即alphaMin时，停止计时</div><div class="line">      if (alpha &lt; alphaMin) &#123;</div><div class="line">        stepper.stop();</div><div class="line">        //自定义的end函数在这里调用</div><div class="line">        event.call(&quot;end&quot;, simulation);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function tick() &#123;</div><div class="line">      var i, n = nodes.length, node;</div><div class="line"></div><div class="line">      alpha += (alphaTarget - alpha) * alphaDecay;</div><div class="line">      //alpha用于force中对速度vx和vy进行设置</div><div class="line">      forces.each(function(force) &#123;</div><div class="line">        force(alpha);</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">        node = nodes[i];</div><div class="line">        //fx和fy是node的固定点，如果设置了该属性则node会固定在该位置</div><div class="line">        //这里简化了物理作用力，将当前位置坐标加上当前速度得到下一步的位置坐标</div><div class="line">        if (node.fx == null) node.x += node.vx *= velocityDecay;</div><div class="line">        else node.x = node.fx, node.vx = 0;</div><div class="line">        if (node.fy == null) node.y += node.vy *= velocityDecay;</div><div class="line">        else node.y = node.fy, node.vy = 0;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    //对nodes进行处理</div><div class="line">    function initializeNodes() &#123;</div><div class="line">      for (var i = 0, n = nodes.length, node; i &lt; n; ++i) &#123;</div><div class="line">        node = nodes[i], node.index = i;</div><div class="line">        //如果node中不含x、 y值，则按默认方法计算。</div><div class="line">        if (isNaN(node.x) || isNaN(node.y)) &#123;</div><div class="line">          var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;</div><div class="line">          node.x = radius * Math.cos(angle);</div><div class="line">          node.y = radius * Math.sin(angle);</div><div class="line">        &#125;</div><div class="line">        //如果不含vx、vy值，则默认为0。</div><div class="line">        if (isNaN(node.vx) || isNaN(node.vy)) &#123;</div><div class="line">          node.vx = node.vy = 0;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function initializeForce(force) &#123;</div><div class="line">      if (force.initialize) force.initialize(nodes);</div><div class="line">      return force;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    initializeNodes();</div><div class="line"></div><div class="line">    return simulation = &#123;</div><div class="line">      tick: tick,</div><div class="line"></div><div class="line">      restart: function() &#123;</div><div class="line">        return stepper.restart(step), simulation;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      stop: function() &#123;</div><div class="line">        return stepper.stop(), simulation;</div><div class="line">      &#125;,</div><div class="line">      //设置nodes时会对所有的force进行初始化</div><div class="line">      nodes: function(_) &#123;</div><div class="line">        return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      alpha: function(_) &#123;</div><div class="line">        return arguments.length ? (alpha = +_, simulation) : alpha;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      alphaMin: function(_) &#123;</div><div class="line">        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      alphaDecay: function(_) &#123;</div><div class="line">        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      alphaTarget: function(_) &#123;</div><div class="line">        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      velocityDecay: function(_) &#123;</div><div class="line">        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      force: function(name, _) &#123;</div><div class="line">        return arguments.length &gt; 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      find: function(x, y, radius) &#123;</div><div class="line">        var i = 0,</div><div class="line">            n = nodes.length,</div><div class="line">            dx,</div><div class="line">            dy,</div><div class="line">            d2,</div><div class="line">            node,</div><div class="line">            closest;</div><div class="line"></div><div class="line">        if (radius == null) radius = Infinity;</div><div class="line">        else radius *= radius;</div><div class="line"></div><div class="line">        for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">          node = nodes[i];</div><div class="line">          dx = x - node.x;</div><div class="line">          dy = y - node.y;</div><div class="line">          d2 = dx * dx + dy * dy;</div><div class="line">          if (d2 &lt; radius) closest = node, radius = d2;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return closest;</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      on: function(name, _) &#123;</div><div class="line">        return arguments.length &gt; 1 ? (event.on(name, _), simulation) : event.on(name);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述方法对nodes进行处理，计算其x和y值以及初始化vx、vy值，其中很重要的一部分是force函数，该函数用来模拟物理作用力来改变nodes的位置和速度。</p>
<h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><p>force函数在定时器执行过程中会重复调用，用于控制nodes的坐标和速度。</p>
<h3 id="d3-forceLink"><a href="#d3-forceLink" class="headerlink" title="d3.forceLink"></a>d3.forceLink</h3><p>forceLink主要用于nodes之间的联系即links，每个link会将两个不同的node以source和target的方式进行连接，同时内部会对vx、vy进行调整。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">/* d3.forceLink</div><div class="line">   * force用于控制节点之间的联系</div><div class="line">   * !将于节点相连的link的数量记作该节点的权值</div><div class="line">   */</div><div class="line">function link(links) &#123;</div><div class="line">    var id = index$2,</div><div class="line">        strength = defaultStrength,</div><div class="line">        strengths,</div><div class="line">        //默认link的长度都为30</div><div class="line">        distance = constant$6(30),</div><div class="line">        distances,</div><div class="line">        nodes,</div><div class="line">        //count记录跟每个节点有关联的节点数量，即该节点的权值</div><div class="line">        count,</div><div class="line">        //bias存储每条link对应的source的权值与source和target权值和的比值</div><div class="line">        bias,</div><div class="line">        iterations = 1;</div><div class="line"></div><div class="line">    if (links == null) links = [];</div><div class="line">    //默认计算link的强度的方法</div><div class="line">    function defaultStrength(link) &#123;</div><div class="line">      return 1 / Math.min(count[link.source.index], count[link.target.index]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function force(alpha) &#123;</div><div class="line">      for (var k = 0, n = links.length; k &lt; iterations; ++k) &#123;</div><div class="line">        for (var i = 0, link, source, target, x, y, l, b; i &lt; n; ++i) &#123;</div><div class="line">          link = links[i], source = link.source, target = link.target;</div><div class="line">          x = target.x + target.vx - source.x - source.vx || jiggle();</div><div class="line">          y = target.y + target.vy - source.y - source.vy || jiggle();</div><div class="line">          //target和source的距离为l</div><div class="line">          l = Math.sqrt(x * x + y * y);</div><div class="line">          l = (l - distances[i]) / l * alpha * strengths[i];</div><div class="line">          x *= l, y *= l;</div><div class="line">          //对target和source的速度进行调整</div><div class="line">          target.vx -= x * (b = bias[i]);</div><div class="line">          target.vy -= y * b;</div><div class="line">          source.vx += x * (b = 1 - b);</div><div class="line">          source.vy += y * b;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function initialize() &#123;</div><div class="line">      if (!nodes) return;</div><div class="line"></div><div class="line">      var i,</div><div class="line">          n = nodes.length,</div><div class="line">          m = links.length,</div><div class="line">          //对nodes中每个值设置id作为键值</div><div class="line">          nodeById = map$1(nodes, id),</div><div class="line">          link;</div><div class="line"></div><div class="line">      for (i = 0, count = new Array(n); i &lt; n; ++i) &#123;</div><div class="line">        count[i] = 0;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      for (i = 0; i &lt; m; ++i) &#123;</div><div class="line">        link = links[i], link.index = i;</div><div class="line">        //将link中的source和target值作为id来查找node</div><div class="line">        if (typeof link.source !== &quot;object&quot;) link.source = nodeById.get(link.source);</div><div class="line">        if (typeof link.target !== &quot;object&quot;) link.target = nodeById.get(link.target);</div><div class="line">        ++count[link.source.index], ++count[link.target.index];</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      for (i = 0, bias = new Array(m); i &lt; m; ++i) &#123;</div><div class="line">        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      strengths = new Array(m), initializeStrength();</div><div class="line">      distances = new Array(m), initializeDistance();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function initializeStrength() &#123;</div><div class="line">      if (!nodes) return;</div><div class="line"></div><div class="line">      for (var i = 0, n = links.length; i &lt; n; ++i) &#123;</div><div class="line">        strengths[i] = +strength(links[i], i, links);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function initializeDistance() &#123;</div><div class="line">      if (!nodes) return;</div><div class="line"></div><div class="line">      for (var i = 0, n = links.length; i &lt; n; ++i) &#123;</div><div class="line">        distances[i] = +distance(links[i], i, links);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    force.initialize = function(_) &#123;</div><div class="line">      nodes = _;</div><div class="line">      initialize();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.links = function(_) &#123;</div><div class="line">      return arguments.length ? (links = _, initialize(), force) : links;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.id = function(_) &#123;</div><div class="line">      return arguments.length ? (id = _, force) : id;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.iterations = function(_) &#123;</div><div class="line">      return arguments.length ? (iterations = +_, force) : iterations;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.strength = function(_) &#123;</div><div class="line">      return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initializeStrength(), force) : strength;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.distance = function(_) &#123;</div><div class="line">      return arguments.length ? (distance = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initializeDistance(), force) : distance;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return force;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-forceCenter"><a href="#d3-forceCenter" class="headerlink" title="d3.forceCenter"></a>d3.forceCenter</h3><p>forceCenter根据设置的(x, y)坐标而将node的坐标向其移动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//d3.forceCenter</div><div class="line">function center$1(x, y) &#123;</div><div class="line">    var nodes;</div><div class="line"></div><div class="line">    if (x == null) x = 0;</div><div class="line">    if (y == null) y = 0;</div><div class="line"></div><div class="line">    function force() &#123;</div><div class="line">      var i,</div><div class="line">          n = nodes.length,</div><div class="line">          node,</div><div class="line">          sx = 0,</div><div class="line">          sy = 0;</div><div class="line"></div><div class="line">      for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">        node = nodes[i], sx += node.x, sy += node.y;</div><div class="line">      &#125;</div><div class="line">      //这里简化了粒子的质量，认为都相等，通过sx / n和sy / n得到所有粒子的重心</div><div class="line">      for (sx = sx / n - x, sy = sy / n - y, i = 0; i &lt; n; ++i) &#123;</div><div class="line">        //将所有粒子的坐标向中心点靠近</div><div class="line">        node = nodes[i], node.x -= sx, node.y -= sy;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    force.initialize = function(_) &#123;</div><div class="line">      nodes = _;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.x = function(_) &#123;</div><div class="line">      return arguments.length ? (x = +_, force) : x;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.y = function(_) &#123;</div><div class="line">      return arguments.length ? (y = +_, force) : y;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return force;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-forceCollide"><a href="#d3-forceCollide" class="headerlink" title="d3.forceCollide"></a>d3.forceCollide</h3><p>forceCollide方法将nodes不再看做一个点而是一个指定半径的圆形，防止不同的节点发生碰撞即要满足两个圆心的距离大于两个圆形半径之和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">//d3.forceCollide</div><div class="line">function collide(radius) &#123;</div><div class="line">    var nodes,</div><div class="line">        radii,</div><div class="line">        strength = 1,</div><div class="line">        iterations = 1;</div><div class="line">    //如果没有设置radius，则默认为1</div><div class="line">    if (typeof radius !== &quot;function&quot;) radius = constant$6(radius == null ? 1 : +radius);</div><div class="line"></div><div class="line">    function force() &#123;</div><div class="line">      var i, n = nodes.length,</div><div class="line">          tree,</div><div class="line">          node,</div><div class="line">          xi,</div><div class="line">          yi,</div><div class="line">          ri,</div><div class="line">          ri2;</div><div class="line"></div><div class="line">      for (var k = 0; k &lt; iterations; ++k) &#123;</div><div class="line">        //visitAfter函数使得对每个node都执行prepare。这里采用后续遍历的方法，因为只有知道了孩子节点的半径才能确定根节点半径</div><div class="line">        tree = quadtree(nodes, x$1, y$1).visitAfter(prepare);</div><div class="line">        //依次访问所有的node节点，判断其他节点是否可能与其重叠</div><div class="line">        for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">          node = nodes[i];</div><div class="line">          ri = radii[i], ri2 = ri * ri;</div><div class="line">          xi = node.x + node.vx;</div><div class="line">          yi = node.y + node.vy;</div><div class="line">          tree.visit(apply);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      //这里用于对重叠的节点进行处理，如果当前节点为根节点则判断node是否与该根节点的范围有重叠，如果没有则返回true，不再访问其子节点；否则继续访问其子节点。</div><div class="line">      //如果当前节点为叶子节点，</div><div class="line">      function apply(quad, x0, y0, x1, y1) &#123;</div><div class="line">        var data = quad.data, rj = quad.r, r = ri + rj;</div><div class="line">        if (data) &#123;</div><div class="line">          // 只比较index大于i的，可防止重复比较</div><div class="line">          if (data.index &gt; i) &#123;</div><div class="line">            var x = xi - data.x - data.vx,</div><div class="line">                y = yi - data.y - data.vy,</div><div class="line">                l = x * x + y * y;</div><div class="line">            if (l &lt; r * r) &#123;</div><div class="line">              if (x === 0) x = jiggle(), l += x * x;</div><div class="line">              if (y === 0) y = jiggle(), l += y * y;</div><div class="line">              l = (r - (l = Math.sqrt(l))) / l * strength;</div><div class="line">              //根据两个节点间的距离和两个节点的半径对node和data的速度进行调整</div><div class="line">              //TODO: 为什么这样调整？？？</div><div class="line">              node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));</div><div class="line">              node.vy += (y *= l) * r;</div><div class="line">              data.vx -= x * (r = 1 - r);</div><div class="line">              data.vy -= y * r;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          return;</div><div class="line">        &#125;</div><div class="line">        return x0 &gt; xi + r || x1 &lt; xi - r || y0 &gt; yi + r || y1 &lt; yi - r;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    //为所有节点设置半径</div><div class="line">    function prepare(quad) &#123;</div><div class="line">      if (quad.data) return quad.r = radii[quad.data.index];</div><div class="line">      //quad是一个数组，即quad不是叶子节点时，将其所有子节点的最大半径复制给quad.r</div><div class="line">      for (var i = quad.r = 0; i &lt; 4; ++i) &#123;</div><div class="line">        if (quad[i] &amp;&amp; quad[i].r &gt; quad.r) &#123;</div><div class="line">          quad.r = quad[i].r;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    //初始化时通过radius函数处理nodes得到每个node的半径</div><div class="line">    force.initialize = function(_) &#123;</div><div class="line">      var i, n = (nodes = _).length; radii = new Array(n);</div><div class="line">      for (i = 0; i &lt; n; ++i) radii[i] = +radius(nodes[i], i, nodes);</div><div class="line">    &#125;;</div><div class="line">    //iteration值越大，node节点重叠情况就会越小</div><div class="line">    force.iterations = function(_) &#123;</div><div class="line">      return arguments.length ? (iterations = +_, force) : iterations;</div><div class="line">    &#125;;</div><div class="line">    //strength用于在两个节点重叠时调整节点的速度</div><div class="line">    force.strength = function(_) &#123;</div><div class="line">      return arguments.length ? (strength = +_, force) : strength;</div><div class="line">    &#125;;</div><div class="line">    //设置节点的获取半径的函数</div><div class="line">    force.radius = function(_) &#123;</div><div class="line">      return arguments.length ? (radius = typeof _ === &quot;function&quot; ? _ : constant$6(+_), force) : radius;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return force;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-forceManyBody"><a href="#d3-forceManyBody" class="headerlink" title="d3.forceManyBody"></a>d3.forceManyBody</h3><p>用于模拟所有粒子间的作用力，例如模拟重力或者静电力。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">//d3.forceManyBody</div><div class="line">function manyBody() &#123;</div><div class="line">    var nodes,</div><div class="line">        node,</div><div class="line">        alpha,</div><div class="line">        //当strength为正值时粒子间会互相吸引，当为负值时粒子间会互相排斥</div><div class="line">        //在这里表现为当strength为正值时，两个互相作用的粒子速度会增加，互相靠近；为负值时，两个粒子速度减小，互相远离。</div><div class="line">        strength = constant$6(-30),</div><div class="line">        strengths,</div><div class="line">        distanceMin2 = 1,</div><div class="line">        distanceMax2 = Infinity,</div><div class="line">        //theta用于判断距离远近而采取不同的方法对粒子的速度进行处理</div><div class="line">        theta2 = 0.81;</div><div class="line"></div><div class="line">    function force(_) &#123;</div><div class="line">      var i, n = nodes.length, tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);</div><div class="line">      for (alpha = _, i = 0; i &lt; n; ++i) node = nodes[i], tree.visit(apply);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function initialize() &#123;</div><div class="line">      if (!nodes) return;</div><div class="line">      var i, n = nodes.length;</div><div class="line">      strengths = new Array(n);</div><div class="line">      for (i = 0; i &lt; n; ++i) strengths[i] = +strength(nodes[i], i, nodes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function accumulate(quad) &#123;</div><div class="line">      var strength = 0, q, c, x, y, i;</div><div class="line"></div><div class="line">      // 对于根节点，根据其子节点来计算</div><div class="line">      if (quad.length) &#123;</div><div class="line">        for (x = y = i = 0; i &lt; 4; ++i) &#123;</div><div class="line">          if ((q = quad[i]) &amp;&amp; (c = q.value)) &#123;</div><div class="line">            strength += c, x += c * q.x, y += c * q.y;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        quad.x = x / strength;</div><div class="line">        quad.y = y / strength;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 对于叶子节点，根据其是否有相同节点来计算strength值</div><div class="line">      else &#123;</div><div class="line">        q = quad;</div><div class="line">        q.x = q.data.x;</div><div class="line">        q.y = q.data.y;</div><div class="line">        do strength += strengths[q.data.index];</div><div class="line">        while (q = q.next);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      quad.value = strength;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function apply(quad, x1, _, x2) &#123;</div><div class="line">      if (!quad.value) return true;</div><div class="line"></div><div class="line">      var x = quad.x - node.x,</div><div class="line">          y = quad.y - node.y,</div><div class="line">          w = x2 - x1,</div><div class="line">          l = x * x + y * y;</div><div class="line"></div><div class="line">      // 如果quad和node间的距离较远则根据value、alpha和l来调整node的速度</div><div class="line">      if (w * w / theta2 &lt; l) &#123;</div><div class="line">        if (l &lt; distanceMax2) &#123;</div><div class="line">          if (x === 0) x = jiggle(), l += x * x;</div><div class="line">          if (y === 0) y = jiggle(), l += y * y;</div><div class="line">          if (l &lt; distanceMin2) l = Math.sqrt(distanceMin2 * l);</div><div class="line">          node.vx += x * quad.value * alpha / l;</div><div class="line">          node.vy += y * quad.value * alpha / l;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 如果quad为根节点则返回去访问其子节点</div><div class="line">      else if (quad.length || l &gt;= distanceMax2) return;</div><div class="line">      //quad和node相同时不会执行以下过程</div><div class="line">      //当quad和node间距离较近时，同时要考虑strength来调整node的速度</div><div class="line">      </div><div class="line">      if (quad.data !== node || quad.next) &#123;</div><div class="line">        if (x === 0) x = jiggle(), l += x * x;</div><div class="line">        if (y === 0) y = jiggle(), l += y * y;</div><div class="line">        if (l &lt; distanceMin2) l = Math.sqrt(distanceMin2 * l);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      do if (quad.data !== node) &#123;</div><div class="line">        w = strengths[quad.data.index] * alpha / l;</div><div class="line">        node.vx += x * w;</div><div class="line">        node.vy += y * w;</div><div class="line">      &#125; while (quad = quad.next);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    force.initialize = function(_) &#123;</div><div class="line">      nodes = _;</div><div class="line">      initialize();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.strength = function(_) &#123;</div><div class="line">      return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initialize(), force) : strength;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.distanceMin = function(_) &#123;</div><div class="line">      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.distanceMax = function(_) &#123;</div><div class="line">      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.theta = function(_) &#123;</div><div class="line">      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return force;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-forceX"><a href="#d3-forceX" class="headerlink" title="d3.forceX"></a>d3.forceX</h3><p>使所有的节点向指定的x坐标处靠近。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//d3.forceX</div><div class="line">function x$3(x) &#123;</div><div class="line">    var strength = constant$6(0.1),</div><div class="line">        nodes,</div><div class="line">        strengths,</div><div class="line">        xz;</div><div class="line"></div><div class="line">    if (typeof x !== &quot;function&quot;) x = constant$6(x == null ? 0 : +x);</div><div class="line"></div><div class="line">    function force(alpha) &#123;</div><div class="line">      for (var i = 0, n = nodes.length, node; i &lt; n; ++i) &#123;</div><div class="line">        //通过xz和strength来改变node的x轴方向的速度，使得节点像xz处靠近。strength的值越大，node的速度改变的越快，即会更快的到达指定坐标位置而趋于稳定</div><div class="line">        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function initialize() &#123;</div><div class="line">      if (!nodes) return;</div><div class="line">      var i, n = nodes.length;</div><div class="line">      strengths = new Array(n);</div><div class="line">      xz = new Array(n);</div><div class="line">      for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">        //对每个node分别计算x坐标存入xz数组中，同时计算strength值</div><div class="line">        strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    force.initialize = function(_) &#123;</div><div class="line">      nodes = _;</div><div class="line">      initialize();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.strength = function(_) &#123;</div><div class="line">      return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initialize(), force) : strength;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    force.x = function(_) &#123;</div><div class="line">      return arguments.length ? (x = typeof _ === &quot;function&quot; ? _ : constant$6(+_), initialize(), force) : x;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return force;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[d3.js源码分析——Shape]]></title>
      <url>http://arlendp.me/web/js/d3js-source-code-shape/</url>
      <content type="html"><![CDATA[<p>shape模块提供各种形状的生成器，这些形状的产生是数据驱动的，通过控制输入数据来形成一种视觉的表现。<br><a id="more"></a></p>
<h2 id="Pies"><a href="#Pies" class="headerlink" title="Pies"></a>Pies</h2><p>饼图生成器不直接产生图形，而是计算出需要的角度信息，然后传入<code>d3.arc</code>中进行绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">  // 绘制饼图</div><div class="line">function pie() &#123;</div><div class="line">    var value = identity$1,</div><div class="line">        sortValues = descending$1,</div><div class="line">        sort = null,</div><div class="line">        startAngle = constant$1(0),</div><div class="line">        endAngle = constant$1(tau$2),</div><div class="line">        padAngle = constant$1(0);</div><div class="line"></div><div class="line">    function pie(data) &#123;</div><div class="line">      var i,</div><div class="line">          n = data.length,</div><div class="line">          j,</div><div class="line">          k,</div><div class="line">          //统计data数组中的数据和</div><div class="line">          sum = 0,</div><div class="line">          index = new Array(n),</div><div class="line">          arcs = new Array(n),</div><div class="line">          a0 = +startAngle.apply(this, arguments),</div><div class="line">          //将|endAngle - startAngle|限定在 2 * PI之间</div><div class="line">          da = Math.min(tau$2, Math.max(-tau$2, endAngle.apply(this, arguments) - a0)),</div><div class="line">          a1,</div><div class="line">          //限定padAngle的范围</div><div class="line">          p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),</div><div class="line">          // da&lt;0表示弧线为逆时针方向，pa的值也应进行相应处理</div><div class="line">          pa = p * (da &lt; 0 ? -1 : 1),</div><div class="line">          v;</div><div class="line"></div><div class="line">      for (i = 0; i &lt; n; ++i) &#123;</div><div class="line">        if ((v = arcs[index[i] = i] = +value(data[i], i, data)) &gt; 0) &#123;</div><div class="line">          sum += v;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 按照处理后的arcs数据大小对index进行排序，或者直接对data进行排序</div><div class="line">      if (sortValues != null) index.sort(function(i, j) &#123; return sortValues(arcs[i], arcs[j]); &#125;);</div><div class="line">      else if (sort != null) index.sort(function(i, j) &#123; return sort(data[i], data[j]); &#125;);</div><div class="line"></div><div class="line">      // 计算arcs，按照排序后的index来逐个计算</div><div class="line">      for (i = 0, k = sum ? (da - n * pa) / sum : 0; i &lt; n; ++i, a0 = a1) &#123;</div><div class="line">        j = index[i], v = arcs[j], a1 = a0 + (v &gt; 0 ? v * k : 0) + pa, arcs[j] = &#123;</div><div class="line">          data: data[j],</div><div class="line">          index: i,</div><div class="line">          value: v,</div><div class="line">          startAngle: a0,</div><div class="line">          endAngle: a1,</div><div class="line">          padAngle: p</div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return arcs;</div><div class="line">    &#125;</div><div class="line">    //设置value函数或数值，value函数会被依次传入data[i]、i和data。</div><div class="line">    pie.value = function(_) &#123;</div><div class="line">      return arguments.length ? (value = typeof _ === &quot;function&quot; ? _ : constant$1(+_), pie) : value;</div><div class="line">    &#125;;</div><div class="line">    //设置数值的排序方式</div><div class="line">    pie.sortValues = function(_) &#123;</div><div class="line">      return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    pie.sort = function(_) &#123;</div><div class="line">      return arguments.length ? (sort = _, sortValues = null, pie) : sort;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    pie.startAngle = function(_) &#123;</div><div class="line">      return arguments.length ? (startAngle = typeof _ === &quot;function&quot; ? _ : constant$1(+_), pie) : startAngle;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    pie.endAngle = function(_) &#123;</div><div class="line">      return arguments.length ? (endAngle = typeof _ === &quot;function&quot; ? _ : constant$1(+_), pie) : endAngle;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    pie.padAngle = function(_) &#123;</div><div class="line">      return arguments.length ? (padAngle = typeof _ === &quot;function&quot; ? _ : constant$1(+_), pie) : padAngle;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return pie;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Lines"><a href="#Lines" class="headerlink" title="Lines"></a>Lines</h2><p>可以产生样条曲线或者多段线。</p>
<h3 id="d3-line"><a href="#d3-line" class="headerlink" title="d3.line"></a>d3.line</h3><p>默认的设置是构造多条直线段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//d3.line()，绘制多条直线段，中间可能断开</div><div class="line">  function line() &#123;</div><div class="line">    var x$$ = x,</div><div class="line">        y$$ = y,</div><div class="line">        defined = constant$1(true),</div><div class="line">        context = null,</div><div class="line">        curve = curveLinear,</div><div class="line">        output = null;</div><div class="line"></div><div class="line">    function line(data) &#123;</div><div class="line">      var i,</div><div class="line">          n = data.length,</div><div class="line">          d,</div><div class="line">          defined0 = false,</div><div class="line">          buffer;</div><div class="line"></div><div class="line">      if (context == null) output = curve(buffer = path());</div><div class="line"></div><div class="line">      for (i = 0; i &lt;= n; ++i) &#123;</div><div class="line">        if (!(i &lt; n &amp;&amp; defined(d = data[i], i, data)) === defined0) &#123;</div><div class="line">          if (defined0 = !defined0) output.lineStart();</div><div class="line">          else output.lineEnd();</div><div class="line">        &#125;</div><div class="line">        if (defined0) output.point(+x$$(d, i, data), +y$$(d, i, data));</div><div class="line">      &#125;</div><div class="line">    // 返回path的计算结果</div><div class="line">      if (buffer) return output = null, buffer + &quot;&quot; || null;</div><div class="line">    &#125;</div><div class="line">    // 设置获取x的函数</div><div class="line">    line.x = function(_) &#123;</div><div class="line">      return arguments.length ? (x$$ = typeof _ === &quot;function&quot; ? _ : constant$1(+_), line) : x$$;</div><div class="line">    &#125;;</div><div class="line">    // 设置获取y的函数</div><div class="line">    line.y = function(_) &#123;</div><div class="line">      return arguments.length ? (y$$ = typeof _ === &quot;function&quot; ? _ : constant$1(+_), line) : y$$;</div><div class="line">    &#125;;</div><div class="line">    // defined函数用于判断当前点是否已被定义，若为true，则会计算x、y坐标和绘制直线；否则会跳过当前点，结束当前直线的绘制。</div><div class="line">    line.defined = function(_) &#123;</div><div class="line">      return arguments.length ? (defined = typeof _ === &quot;function&quot; ? _ : constant$1(!!_), line) : defined;</div><div class="line">    &#125;;</div><div class="line">    // 设置curve函数</div><div class="line">    line.curve = function(_) &#123;</div><div class="line">      return arguments.length ? (curve = _, context != null &amp;&amp; (output = curve(context)), line) : curve;</div><div class="line">    &#125;;</div><div class="line">    // 设置context</div><div class="line">    line.context = function(_) &#123;</div><div class="line">      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return line;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-radialLine"><a href="#d3-radialLine" class="headerlink" title="d3.radialLine"></a>d3.radialLine</h3><p>构造放射线，与上述<code>d3.line</code>类似，只是将x、y函数替换成角度和半径函数，并且改放射线总是相对于(0, 0)进行绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// d3.radialLine，在d3.line的基础上进行修改，主要的差别是curve函数和坐标系。</div><div class="line">function radialLine$1() &#123;</div><div class="line">    return radialLine(line().curve(curveRadialLinear));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 构造放射线，分别构造线性和放射状曲线</div><div class="line">var curveRadialLinear = curveRadial(curveLinear);</div><div class="line"></div><div class="line">//线性的curve函数</div><div class="line">function curveLinear(context) &#123;</div><div class="line">    return new Linear(context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将当前curve函数包装成放射状curve</div><div class="line">function curveRadial(curve) &#123;</div><div class="line">    function radial(context) &#123;</div><div class="line">      return new Radial(curve(context));</div><div class="line">    &#125;</div><div class="line">    radial._curve = curve;</div><div class="line">    return radial;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将line中的(x, y)坐标替换成(angle, radius)</div><div class="line">function radialLine(l) &#123;</div><div class="line">    var c = l.curve;</div><div class="line"></div><div class="line">    l.angle = l.x, delete l.x;</div><div class="line">    l.radius = l.y, delete l.y;</div><div class="line"></div><div class="line">    l.curve = function(_) &#123;</div><div class="line">      return arguments.length ? c(curveRadial(_)) : c()._curve;</div><div class="line">    &#125;;</div><div class="line">    return l;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Areas"><a href="#Areas" class="headerlink" title="Areas"></a>Areas</h2><p>用于产生一块区域。</p>
<h3 id="d3-area"><a href="#d3-area" class="headerlink" title="d3.area"></a>d3.area</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">/* d3.area</div><div class="line"> * 首先根据x1, y1函数进行绘制，完成后根据x0, y0函数来反方向绘制，整个图形的绘制过程是顺时针方向。</div><div class="line"> * 默认绘制的是x0 = x1，y0 = 0的一块区域。</div><div class="line"> */</div><div class="line"> function area$1() &#123;</div><div class="line">    var x0 = x,</div><div class="line">        x1 = null,</div><div class="line">        y0 = constant$1(0),</div><div class="line">        y1 = y,</div><div class="line">        defined = constant$1(true),</div><div class="line">        context = null,</div><div class="line">        curve = curveLinear,</div><div class="line">        output = null;</div><div class="line"></div><div class="line">    function area(data) &#123;</div><div class="line">      var i,</div><div class="line">          j,</div><div class="line">          k,</div><div class="line">          n = data.length,</div><div class="line">          d,</div><div class="line">          defined0 = false,</div><div class="line">          buffer,</div><div class="line">          x0z = new Array(n),</div><div class="line">          y0z = new Array(n);</div><div class="line"></div><div class="line">      if (context == null) output = curve(buffer = path());</div><div class="line"></div><div class="line">      for (i = 0; i &lt;= n; ++i) &#123;</div><div class="line">        if (!(i &lt; n &amp;&amp; defined(d = data[i], i, data)) === defined0) &#123;</div><div class="line">          //defined0由false变为true时，表示绘制开始，相反表示绘制结束</div><div class="line">          if (defined0 = !defined0) &#123;</div><div class="line">            j = i;</div><div class="line">            output.areaStart();</div><div class="line">            output.lineStart();</div><div class="line">          &#125; else &#123;</div><div class="line">            output.lineEnd();</div><div class="line">            output.lineStart();</div><div class="line">            //反向绘制x0z, y0z，绘制方向为顺时针方向</div><div class="line">            for (k = i - 1; k &gt;= j; --k) &#123;</div><div class="line">              output.point(x0z[k], y0z[k]);</div><div class="line">            &#125;</div><div class="line">            output.lineEnd();</div><div class="line">            // 关闭绘制区域</div><div class="line">            output.areaEnd();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        //defined0为true时可以绘制</div><div class="line">        if (defined0) &#123;</div><div class="line">          x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);</div><div class="line">          //优先使用x1和y1函数进行计算</div><div class="line">          output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (buffer) return output = null, buffer + &quot;&quot; || null;</div><div class="line">    &#125;</div><div class="line">    // 返回与当前area有相同defined、curve和context的line构造器</div><div class="line">    function arealine() &#123;</div><div class="line">      return line().defined(defined).curve(curve).context(context);</div><div class="line">    &#125;</div><div class="line">    // 设置x函数，将该函数赋值给x0，null赋值给x1</div><div class="line">    area.x = function(_) &#123;</div><div class="line">      return arguments.length ? (x0 = typeof _ === &quot;function&quot; ? _ : constant$1(+_), x1 = null, area) : x0;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    area.x0 = function(_) &#123;</div><div class="line">      return arguments.length ? (x0 = typeof _ === &quot;function&quot; ? _ : constant$1(+_), area) : x0;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    area.x1 = function(_) &#123;</div><div class="line">      return arguments.length ? (x1 = _ == null ? null : typeof _ === &quot;function&quot; ? _ : constant$1(+_), area) : x1;</div><div class="line">    &#125;;</div><div class="line">    // 设置y函数，将该函数赋值给y0，null赋值给y1</div><div class="line">    area.y = function(_) &#123;</div><div class="line">      return arguments.length ? (y0 = typeof _ === &quot;function&quot; ? _ : constant$1(+_), y1 = null, area) : y0;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    area.y0 = function(_) &#123;</div><div class="line">      return arguments.length ? (y0 = typeof _ === &quot;function&quot; ? _ : constant$1(+_), area) : y0;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    area.y1 = function(_) &#123;</div><div class="line">      return arguments.length ? (y1 = _ == null ? null : typeof _ === &quot;function&quot; ? _ : constant$1(+_), area) : y1;</div><div class="line">    &#125;;</div><div class="line">    // 分别对line构造器设置x和y函数</div><div class="line">    area.lineX0 =</div><div class="line">    area.lineY0 = function() &#123;</div><div class="line">      return arealine().x(x0).y(y0);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    area.lineY1 = function() &#123;</div><div class="line">      return arealine().x(x0).y(y1);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    area.lineX1 = function() &#123;</div><div class="line">      return arealine().x(x1).y(y0);</div><div class="line">    &#125;;</div><div class="line">    // defined函数用来判断是否绘制当前点。这样可以生成离散的图形。</div><div class="line">    area.defined = function(_) &#123;</div><div class="line">      return arguments.length ? (defined = typeof _ === &quot;function&quot; ? _ : constant$1(!!_), area) : defined;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    area.curve = function(_) &#123;</div><div class="line">      return arguments.length ? (curve = _, context != null &amp;&amp; (output = curve(context)), area) : curve;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    area.context = function(_) &#123;</div><div class="line">      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return area;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="d3-radialArea"><a href="#d3-radialArea" class="headerlink" title="d3.radialArea"></a>d3.radialArea</h3><p>绘制放射状区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * d3.radialArea</div><div class="line"> * 在area的基础上修改curve函数，将x,y坐标转换为angle,radius坐标，其余绘制方式不变</div><div class="line"> */</div><div class="line">function radialArea() &#123;</div><div class="line">    var a = area$1().curve(curveRadialLinear),</div><div class="line">        c = a.curve,</div><div class="line">        x0 = a.lineX0,</div><div class="line">        x1 = a.lineX1,</div><div class="line">        y0 = a.lineY0,</div><div class="line">        y1 = a.lineY1;</div><div class="line">    // 将d3.area中的(x0, y0)和(x1, y1)转化成(startAngle, innerRadius)和(endAngle, outerRadius)</div><div class="line">    a.angle = a.x, delete a.x;</div><div class="line">    a.startAngle = a.x0, delete a.x0;</div><div class="line">    a.endAngle = a.x1, delete a.x1;</div><div class="line">    a.radius = a.y, delete a.y;</div><div class="line">    a.innerRadius = a.y0, delete a.y0;</div><div class="line">    a.outerRadius = a.y1, delete a.y1;</div><div class="line">    a.lineStartAngle = function() &#123; return radialLine(x0()); &#125;, delete a.lineX0;</div><div class="line">    a.lineEndAngle = function() &#123; return radialLine(x1()); &#125;, delete a.lineX1;</div><div class="line">    a.lineInnerRadius = function() &#123; return radialLine(y0()); &#125;, delete a.lineY0;</div><div class="line">    a.lineOuterRadius = function() &#123; return radialLine(y1()); &#125;, delete a.lineY1;</div><div class="line">    // 对自定义的curve函数进行包装，防止计算时方法不能使用</div><div class="line">    a.curve = function(_) &#123;</div><div class="line">      return arguments.length ? c(curveRadial(_)) : c()._curve;</div><div class="line">    &#125;;</div><div class="line">    return a;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h2><p>curve的功能就是将离散的点进行连接，形成一个连续的图形，它并不是直接使用，而是传入上述如<code>d3.line</code>、<code>d3.area</code>等函数的<code>curve</code>函数中来控制这些离散的点的连接方式。</p>
<h3 id="d3-curveBasis"><a href="#d3-curveBasis" class="headerlink" title="d3.curveBasis"></a>d3.curveBasis</h3><p>通过特定控制点的贝塞尔曲线将离散的点进行连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">function point(that, x, y) &#123;</div><div class="line">    that._context.bezierCurveTo(</div><div class="line">      (2 * that._x0 + that._x1) / 3,</div><div class="line">      (2 * that._y0 + that._y1) / 3,</div><div class="line">      (that._x0 + 2 * that._x1) / 3,</div><div class="line">      (that._y0 + 2 * that._y1) / 3,</div><div class="line">      (that._x0 + 4 * that._x1 + x) / 6,</div><div class="line">      (that._y0 + 4 * that._y1 + y) / 6</div><div class="line">    );</div><div class="line">&#125;</div><div class="line">function Basis(context) &#123;</div><div class="line">    this._context = context;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Basis.prototype = &#123;</div><div class="line">    areaStart: function() &#123;</div><div class="line">      this._line = 0;</div><div class="line">    &#125;,</div><div class="line">    areaEnd: function() &#123;</div><div class="line">      this._line = NaN;</div><div class="line">    &#125;,</div><div class="line">    lineStart: function() &#123;</div><div class="line">      this._x0 = this._x1 =</div><div class="line">      this._y0 = this._y1 = NaN;</div><div class="line">      this._point = 0;</div><div class="line">    &#125;,</div><div class="line">    lineEnd: function() &#123;</div><div class="line">      switch (this._point) &#123;</div><div class="line">        case 3: point(this, this._x1, this._y1); // proceed</div><div class="line">        case 2: this._context.lineTo(this._x1, this._y1); break;</div><div class="line">      &#125;</div><div class="line">      if (this._line || (this._line !== 0 &amp;&amp; this._point === 1)) this._context.closePath();</div><div class="line">      this._line = 1 - this._line;</div><div class="line">    &#125;,</div><div class="line">    //首先移动至起点即第一个点，记录下第一个点和第二个点坐标，连接当前点(第一个点)和((5 * x0 + x1) / 6, (5 * y0 + y1) / 6)，并绘制改点到((x0 + 4 * x1 + x) / 6, (y0 + 4 * y1 + y) / 6)点的三次贝塞尔曲线</div><div class="line">    point: function(x, y) &#123;</div><div class="line">      x = +x, y = +y;</div><div class="line">      switch (this._point) &#123;</div><div class="line">        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;</div><div class="line">        case 1: this._point = 2; break;</div><div class="line">        case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed</div><div class="line">        default: point(this, x, y); break;</div><div class="line">      &#125;</div><div class="line">      this._x0 = this._x1, this._x1 = x;</div><div class="line">      this._y0 = this._y1, this._y1 = y;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// d3.curveBasis</div><div class="line">function basis(context) &#123;</div><div class="line">    return new Basis(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-curveBasisClosed"><a href="#d3-curveBasisClosed" class="headerlink" title="d3.curveBasisClosed"></a>d3.curveBasisClosed</h3><p>通过特定控制点的贝塞尔曲线连接离散的点，并形成一个闭合图形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">function BasisClosed(context) &#123;</div><div class="line">    this._context = context;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BasisClosed.prototype = &#123;</div><div class="line">    areaStart: noop,</div><div class="line">    areaEnd: noop,</div><div class="line">    //(x1, y1)和(x2, y2)用于记录第一个和第二个点的坐标</div><div class="line">    lineStart: function() &#123;</div><div class="line">      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =</div><div class="line">      this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;</div><div class="line">      this._point = 0;</div><div class="line">    &#125;,</div><div class="line">    lineEnd: function() &#123;</div><div class="line">      switch (this._point) &#123;</div><div class="line">        //如果只有一个点，则移动到第一个点即该点处并关闭图形</div><div class="line">        case 1: &#123;</div><div class="line">          this._context.moveTo(this._x2, this._y2);</div><div class="line">          this._context.closePath();</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">        //如果有两个点，则按如下方式处理</div><div class="line">        case 2: &#123;</div><div class="line">          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);</div><div class="line">          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);</div><div class="line">          this._context.closePath();</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">        //从最后一个点向前绘制，x2,x3,x4分别记录的是前三个点坐标</div><div class="line">        case 3: &#123;</div><div class="line">          this.point(this._x2, this._y2);</div><div class="line">          this.point(this._x3, this._y3);</div><div class="line">          this.point(this._x4, this._y4);</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    point: function(x, y) &#123;</div><div class="line">      x = +x, y = +y;</div><div class="line">      switch (this._point) &#123;</div><div class="line">        //记录最初的三个点的坐标</div><div class="line">        case 0: this._point = 1; this._x2 = x, this._y2 = y; break;</div><div class="line">        case 1: this._point = 2; this._x3 = x, this._y3 = y; break;</div><div class="line">        //到最后会绘制一个闭合图形，与初始点连接</div><div class="line">        case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;</div><div class="line">        default: point(this, x, y); break;</div><div class="line">      &#125;</div><div class="line">      this._x0 = this._x1, this._x1 = x;</div><div class="line">      this._y0 = this._y1, this._y1 = y;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">//d3.curveBasisClosed</div><div class="line">function basisClosed(context) &#123;</div><div class="line">    return new BasisClosed(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-curveBasisOpen"><a href="#d3-curveBasisOpen" class="headerlink" title="d3.curveBasisOpen"></a>d3.curveBasisOpen</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">function BasisOpen(context) &#123;</div><div class="line">    this._context = context;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BasisOpen.prototype = &#123;</div><div class="line">    areaStart: function() &#123;</div><div class="line">      this._line = 0;</div><div class="line">    &#125;,</div><div class="line">    areaEnd: function() &#123;</div><div class="line">      this._line = NaN;</div><div class="line">    &#125;,</div><div class="line">    lineStart: function() &#123;</div><div class="line">      this._x0 = this._x1 =</div><div class="line">      this._y0 = this._y1 = NaN;</div><div class="line">      this._point = 0;</div><div class="line">    &#125;,</div><div class="line">    lineEnd: function() &#123;</div><div class="line">      if (this._line || (this._line !== 0 &amp;&amp; this._point === 3)) this._context.closePath();</div><div class="line">      this._line = 1 - this._line;</div><div class="line">    &#125;,</div><div class="line">    //记录第一个和第二个点的坐标，从第三个点处开始操作，移动至((x0 + 4 * x1 + x) / 6, (y0 + y1 * 4 + y) / 6) 点处</div><div class="line">    point: function(x, y) &#123;</div><div class="line">      x = +x, y = +y;</div><div class="line">      switch (this._point) &#123;</div><div class="line">        case 0: this._point = 1; break;</div><div class="line">        case 1: this._point = 2; break;</div><div class="line">        case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;</div><div class="line">        case 3: this._point = 4; // proceed</div><div class="line">        default: point(this, x, y); break;</div><div class="line">      &#125;</div><div class="line">      this._x0 = this._x1, this._x1 = x;</div><div class="line">      this._y0 = this._y1, this._y1 = y;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//d3.curveBasisOpen</div><div class="line">function basisOpen(context) &#123;</div><div class="line">    return new BasisOpen(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="d3-curveBundle"><a href="#d3-curveBundle" class="headerlink" title="d3.curveBundle"></a>d3.curveBundle</h3><p>根据制定的控制点连接离散的点，用于分层级的关系图中，与<code>d3.line</code>一起使用，而不能与<code>d3.area</code>使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">Bundle.prototype = &#123;</div><div class="line">    lineStart: function() &#123;</div><div class="line">      this._x = [];</div><div class="line">      this._y = [];</div><div class="line">      this._basis.lineStart();</div><div class="line">    &#125;,</div><div class="line">    //结束时开始处理数据并绘制图形</div><div class="line">    lineEnd: function() &#123;</div><div class="line">      var x = this._x,</div><div class="line">          y = this._y,</div><div class="line">          j = x.length - 1;</div><div class="line"></div><div class="line">      if (j &gt; 0) &#123;</div><div class="line">        var x0 = x[0],</div><div class="line">            y0 = y[0],</div><div class="line">            //计算起始点到结束点之间x和y的差值</div><div class="line">            dx = x[j] - x0,</div><div class="line">            dy = y[j] - y0,</div><div class="line">            i = -1,</div><div class="line">            t;</div><div class="line"></div><div class="line">        while (++i &lt;= j) &#123;</div><div class="line">          t = i / j;</div><div class="line">          //根据比例确定绘制点的位置，绘制范围在(x0, y0)和(x[j], y[j])之间</div><div class="line">          //当x接近0时，结果近似为一条从起始点到结束点的直线；当x接近1时，结果接近d3.curveBasis</div><div class="line">          this._basis.point(</div><div class="line">            this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),</div><div class="line">            this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)</div><div class="line">          );</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      this._x = this._y = null;</div><div class="line">      this._basis.lineEnd();</div><div class="line">    &#125;,</div><div class="line">    //该方法不会绘制图形，只是将数据存入数组在结束绘制时开始处理数据</div><div class="line">    point: function(x, y) &#123;</div><div class="line">      this._x.push(+x);</div><div class="line">      this._y.push(+y);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  //d3.curveBundle</div><div class="line">  var bundle = (function custom(beta) &#123;</div><div class="line"></div><div class="line">    function bundle(context) &#123;</div><div class="line">      return beta === 1 ? new Basis(context) : new Bundle(context, beta);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bundle.beta = function(beta) &#123;</div><div class="line">      return custom(+beta);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return bundle;</div><div class="line">&#125;)(0.85);</div></pre></td></tr></table></figure></p>
<h2 id="Custom-Curves"><a href="#Custom-Curves" class="headerlink" title="Custom Curves"></a>Custom Curves</h2><p>自定义curve函数，需要自定义几个指定的方法。</p>
<ul>
<li>curve.areaStart()<br>  表示一个新的区域的开始，每个区域包含两条线段，topline是数据的顺序绘制，baseline则反向绘制。</li>
<li>curve.areaEnd()<br>  表示当前区域的结束。</li>
<li>curve.lineStart()<br>  表示一条新的线段的开始，接下来会绘制多个点。</li>
<li>curve.lineEnd()<br>  表示当前线段的结束。</li>
<li>curve.point(x, y)<br>  在当前线段上根据给定的(x, y)坐标绘制一个新的点。</li>
</ul>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//d3.symbol，默认绘制面积为64的圆形</div><div class="line">function symbol() &#123;</div><div class="line">    var type = constant$1(circle),</div><div class="line">        size = constant$1(64),</div><div class="line">        context = null;</div><div class="line"></div><div class="line">    function symbol() &#123;</div><div class="line">      var buffer;</div><div class="line">      if (!context) context = buffer = path();</div><div class="line">      type.apply(this, arguments).draw(context, +size.apply(this, arguments));</div><div class="line">      if (buffer) return context = null, buffer + &quot;&quot; || null;</div><div class="line">    &#125;</div><div class="line">    //设置图形类型</div><div class="line">    symbol.type = function(_) &#123;</div><div class="line">      return arguments.length ? (type = typeof _ === &quot;function&quot; ? _ : constant$1(_), symbol) : type;</div><div class="line">    &#125;;</div><div class="line">    //设置图形的面积</div><div class="line">    symbol.size = function(_) &#123;</div><div class="line">      return arguments.length ? (size = typeof _ === &quot;function&quot; ? _ : constant$1(+_), symbol) : size;</div><div class="line">    &#125;;</div><div class="line">    //设置绘制上下文</div><div class="line">    symbol.context = function(_) &#123;</div><div class="line">      return arguments.length ? (context = _ == null ? null : _, symbol) : context;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return symbol;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以内置的<code>circle</code>类型为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var circle = &#123;</div><div class="line">    //size是该圆形的面积</div><div class="line">    draw: function(context, size) &#123;</div><div class="line">      var r = Math.sqrt(size / pi$2);</div><div class="line">      context.moveTo(r, 0);</div><div class="line">      context.arc(0, 0, r, 0, tau$2);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>若自定义type，则应该实现<code>draw</code>方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[d3.js源码分析——Path]]></title>
      <url>http://arlendp.me/web/js/d3js-source-code-path/</url>
      <content type="html"><![CDATA[<p>d3的path部分是对原生绘制方法的一种封装形式。由于d3.js内部是以svg作为默认的绘图方式，因此内部的计算方式都是将数据转换成svg中<code>path</code>元素的<code>d</code>属性值。通过统一的接口让其和canvas绘图的api保持一致。<br><a id="more"></a></p>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>d3的path部分是为了模拟<code>canvas</code>的绘图方式，但是采用的是svg来作图。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line">//path构造函数</div><div class="line">function Path() &#123;</div><div class="line">    this._x0 = this._y0 = // 当前路径的起点</div><div class="line">    this._x1 = this._y1 = null; // 当前路径的终点</div><div class="line">    this._ = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">function path() &#123;</div><div class="line">    return new Path;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Path.prototype = path.prototype = &#123;</div><div class="line">    constructor: Path,</div><div class="line">    //移动至指定位置</div><div class="line">    moveTo: function(x, y) &#123;</div><div class="line">      this._.push(&quot;M&quot;, this._x0 = this._x1 = +x, &quot;,&quot;, this._y0 = this._y1 = +y);</div><div class="line">    &#125;,</div><div class="line">    //关闭路径</div><div class="line">    closePath: function() &#123;</div><div class="line">      if (this._x1 !== null) &#123;</div><div class="line">        this._x1 = this._x0, this._y1 = this._y0;</div><div class="line">        this._.push(&quot;Z&quot;);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    //绘制直线</div><div class="line">    lineTo: function(x, y) &#123;</div><div class="line">      this._.push(&quot;L&quot;, this._x1 = +x, &quot;,&quot;, this._y1 = +y);</div><div class="line">    &#125;,</div><div class="line">    //绘制二次贝塞尔曲线</div><div class="line">    quadraticCurveTo: function(x1, y1, x, y) &#123;</div><div class="line">      // Q x1 x2（控制点）, x y（终点）</div><div class="line">      this._.push(&quot;Q&quot;, +x1, &quot;,&quot;, +y1, &quot;,&quot;, this._x1 = +x, &quot;,&quot;, this._y1 = +y);</div><div class="line">    &#125;,</div><div class="line">    //绘制三次贝塞尔曲线</div><div class="line">    bezierCurveTo: function(x1, y1, x2, y2, x, y) &#123;</div><div class="line">      this._.push(&quot;C&quot;, +x1, &quot;,&quot;, +y1, &quot;,&quot;, +x2, &quot;,&quot;, +y2, &quot;,&quot;, this._x1 = +x, &quot;,&quot;, this._y1 = +y);</div><div class="line">    &#125;,</div><div class="line">    arcTo: function(x1, y1, x2, y2, r) &#123;</div><div class="line">      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;</div><div class="line">      var x0 = this._x1,</div><div class="line">          y0 = this._y1,</div><div class="line">          x21 = x2 - x1,</div><div class="line">          y21 = y2 - y1,</div><div class="line">          x01 = x0 - x1,</div><div class="line">          y01 = y0 - y1,</div><div class="line">          l01_2 = x01 * x01 + y01 * y01;</div><div class="line"></div><div class="line">      // Is the radius negative? Error.</div><div class="line">      if (r &lt; 0) throw new Error(&quot;negative radius: &quot; + r);</div><div class="line"></div><div class="line">      // Is this path empty? Move to (x1,y1).</div><div class="line">      if (this._x1 === null) &#123;</div><div class="line">        this._.push(</div><div class="line">          &quot;M&quot;, this._x1 = x1, &quot;,&quot;, this._y1 = y1</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.</div><div class="line">      else if (!(l01_2 &gt; epsilon));</div><div class="line"></div><div class="line">      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?</div><div class="line">      // Equivalently, is (x1,y1) coincident with (x2,y2)?</div><div class="line">      // Or, is the radius zero? Line to (x1,y1).</div><div class="line">      else if (!(Math.abs(y01 * x21 - y21 * x01) &gt; epsilon) || !r) &#123;</div><div class="line">        this._.push(</div><div class="line">          &quot;L&quot;, this._x1 = x1, &quot;,&quot;, this._y1 = y1</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // Otherwise, draw an arc!</div><div class="line">      else &#123;</div><div class="line">        var x20 = x2 - x0,</div><div class="line">            y20 = y2 - y0,</div><div class="line">            l21_2 = x21 * x21 + y21 * y21,</div><div class="line">            l20_2 = x20 * x20 + y20 * y20,</div><div class="line">            l21 = Math.sqrt(l21_2),</div><div class="line">            l01 = Math.sqrt(l01_2),</div><div class="line">            l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),</div><div class="line">            t01 = l / l01,</div><div class="line">            t21 = l / l21;</div><div class="line"></div><div class="line">        // If the start tangent is not coincident with (x0,y0), line to.</div><div class="line">        if (Math.abs(t01 - 1) &gt; epsilon) &#123;</div><div class="line">          this._.push(</div><div class="line">            &quot;L&quot;, x1 + t01 * x01, &quot;,&quot;, y1 + t01 * y01</div><div class="line">          );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        this._.push(</div><div class="line">          &quot;A&quot;, r, &quot;,&quot;, r, &quot;,0,0,&quot;, +(y01 * x20 &gt; x01 * y20), &quot;,&quot;, this._x1 = x1 + t21 * x21, &quot;,&quot;, this._y1 = y1 + t21 * y21</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    //(x, y)为参照点坐标，a0和a1分别为起点弧度和终点弧度</div><div class="line">    arc: function(x, y, r, a0, a1, ccw) &#123;</div><div class="line">      x = +x, y = +y, r = +r;</div><div class="line">      var dx = r * Math.cos(a0),</div><div class="line">          dy = r * Math.sin(a0),</div><div class="line">          //起点(x0, y0)坐标</div><div class="line">          x0 = x + dx,</div><div class="line">          y0 = y + dy,</div><div class="line">          //clockwise，顺时针</div><div class="line">          cw = 1 ^ ccw,</div><div class="line">          da = ccw ? a0 - a1 : a1 - a0;</div><div class="line"></div><div class="line">      if (r &lt; 0) throw new Error(&quot;negative radius: &quot; + r);</div><div class="line"></div><div class="line">      // 如果path为空，则move到(x0, y0)</div><div class="line">      if (this._x1 === null) &#123;</div><div class="line">        this._.push(</div><div class="line">          &quot;M&quot;, x0, &quot;,&quot;, y0</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // (x0, y0)与之前位置不一致，用直线连接到(x0, y0)</div><div class="line">      else if (Math.abs(this._x1 - x0) &gt; epsilon || Math.abs(this._y1 - y0) &gt; epsilon) &#123;</div><div class="line">        this._.push(</div><div class="line">          &quot;L&quot;, x0, &quot;,&quot;, y0</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (!r) return;</div><div class="line"></div><div class="line">      // 如果是一个圆，直接画两个圆弧实现这个圆形</div><div class="line">      // A rx（x轴半径） ry（y轴半径） x-axis-rotation（x轴逆时针旋转角度） large-arc-flag（0表示小角度弧即小于180°，1表示大角度弧） sweep-flag（0表示从起点到终点逆时针画弧，1表示顺时针） x（弧线终点x轴） y（弧线终点y轴）</div><div class="line">      if (da &gt; tauEpsilon) &#123;</div><div class="line">        this._.push(</div><div class="line">          &quot;A&quot;, r, &quot;,&quot;, r, &quot;,0,1,&quot;, cw, &quot;,&quot;, x - dx, &quot;,&quot;, y - dy,</div><div class="line">          &quot;A&quot;, r, &quot;,&quot;, r, &quot;,0,1,&quot;, cw, &quot;,&quot;, this._x1 = x0, &quot;,&quot;, this._y1 = y0</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 以r为半径，从当前点向endAngle位置画弧线</div><div class="line">      else &#123;</div><div class="line">        if (da &lt; 0) da = da % tau$1 + tau$1;</div><div class="line">        this._.push(</div><div class="line">          &quot;A&quot;, r, &quot;,&quot;, r, &quot;,0,&quot;, +(da &gt;= pi$1), &quot;,&quot;, cw, &quot;,&quot;, this._x1 = x + r * Math.cos(a1), &quot;,&quot;, this._y1 = y + r * Math.sin(a1)</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    rect: function(x, y, w, h) &#123;</div><div class="line">      this._.push(&quot;M&quot;, this._x0 = this._x1 = +x, &quot;,&quot;, this._y0 = this._y1 = +y, &quot;h&quot;, +w, &quot;v&quot;, +h, &quot;h&quot;, -w, &quot;Z&quot;);</div><div class="line">    &#125;,</div><div class="line">    // 将整个数组转化成一个字符串</div><div class="line">    toString: function() &#123;</div><div class="line">      return this._.join(&quot;&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[d3.js源码分析——Chord]]></title>
      <url>http://arlendp.me/web/js/d3js-source-code-chord/</url>
      <content type="html"><![CDATA[<p>d3的chord部分用于将关系或网络流绘制成一种圆形布局。<br><a id="more"></a></p>
<p><img src="https://raw.githubusercontent.com/d3/d3-chord/master/img/chord.png" alt="chord图"></p>
<p>这部分内容分为两个方面，一方面是构造一个弦布局，另一方面是构造一个产生带状图形的生成器。</p>
<h2 id="chord"><a href="#chord" class="headerlink" title="chord"></a>chord</h2><p>chord的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">function chord() &#123;</div><div class="line">    var padAngle = 0,</div><div class="line">        sortGroups = null,</div><div class="line">        sortSubgroups = null,</div><div class="line">        sortChords = null;</div><div class="line"></div><div class="line">    function chord(matrix) &#123;</div><div class="line">      var n = matrix.length,</div><div class="line">          //matrix中每组数的总和</div><div class="line">          groupSums = [],</div><div class="line">          groupIndex = range(n),</div><div class="line">          subgroupIndex = [],</div><div class="line">          chords = [],</div><div class="line">          groups = chords.groups = new Array(n),</div><div class="line">          subgroups = new Array(n * n),</div><div class="line">          k,</div><div class="line">          x,</div><div class="line">          x0,</div><div class="line">          dx,</div><div class="line">          i,</div><div class="line">          j;</div><div class="line"></div><div class="line">      // 计算每组数的和以及所有数值的总和</div><div class="line">      k = 0, i = -1; while (++i &lt; n) &#123;</div><div class="line">        x = 0, j = -1; while (++j &lt; n) &#123;</div><div class="line">          x += matrix[i][j];</div><div class="line">        &#125;</div><div class="line">        groupSums.push(x);</div><div class="line">        subgroupIndex.push(range(n));</div><div class="line">        k += x;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // sortGroups函数根据每组数据和的大小对groupIndex进行排序</div><div class="line">      if (sortGroups) groupIndex.sort(function(a, b) &#123;</div><div class="line">        return sortGroups(groupSums[a], groupSums[b]);</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      // sortSubgroups函数根据每个数据大小在该组内进行索引的排序</div><div class="line">      if (sortSubgroups) subgroupIndex.forEach(function(d, i) &#123;</div><div class="line">        d.sort(function(a, b) &#123;</div><div class="line">          return sortSubgroups(matrix[i][a], matrix[i][b]);</div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      // 计算除去padAngle之后的单位弧度（每单位数值对应的弧度）</div><div class="line">      k = max$1(0, tau$3 - padAngle * n) / k;</div><div class="line">      dx = k ? padAngle : tau$3 / n;</div><div class="line"></div><div class="line">      // 计算每个数据对应的startAngle和endAngle</div><div class="line">      x = 0, i = -1; while (++i &lt; n) &#123;</div><div class="line">        x0 = x, j = -1; while (++j &lt; n) &#123;</div><div class="line">          var di = groupIndex[i],</div><div class="line">              dj = subgroupIndex[di][j],</div><div class="line">              v = matrix[di][dj],</div><div class="line">              // startAngle</div><div class="line">              a0 = x,</div><div class="line">              // 计算endAngle</div><div class="line">              a1 = x += v * k;</div><div class="line">          //记录matrix中每个数据在弦图中的信息</div><div class="line">          subgroups[dj * n + di] = &#123;</div><div class="line">            index: di,</div><div class="line">            subindex: dj,</div><div class="line">            startAngle: a0,</div><div class="line">            endAngle: a1,</div><div class="line">            value: v</div><div class="line">          &#125;;</div><div class="line">        &#125;</div><div class="line">        //记录matrix中每组数据在弦图中的信息</div><div class="line">        groups[di] = &#123;</div><div class="line">          index: di,</div><div class="line">          startAngle: x0,</div><div class="line">          endAngle: x,</div><div class="line">          value: groupSums[di]</div><div class="line">        &#125;;</div><div class="line">        //考虑弦图中每组之间的间距</div><div class="line">        x += dx;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 产生source和target</div><div class="line">      i = -1; while (++i &lt; n) &#123;</div><div class="line">        j = i - 1; while (++j &lt; n) &#123;</div><div class="line">          var source = subgroups[j * n + i],</div><div class="line">              target = subgroups[i * n + j];</div><div class="line">          if (source.value || target.value) &#123;</div><div class="line">            //将value大的设置为source，小的设置为target</div><div class="line">            chords.push(source.value &lt; target.value</div><div class="line">                ? &#123;source: target, target: source&#125;</div><div class="line">                : &#123;source: source, target: target&#125;);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return sortChords ? chords.sort(sortChords) : chords;</div><div class="line">    &#125;</div><div class="line">    // 设置相邻组之间的间距，以弧度形式表示</div><div class="line">    chord.padAngle = function(_) &#123;</div><div class="line">      return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;</div><div class="line">    &#125;;</div><div class="line">    // 对groupIndex进行排序</div><div class="line">    chord.sortGroups = function(_) &#123;</div><div class="line">      return arguments.length ? (sortGroups = _, chord) : sortGroups;</div><div class="line">    &#125;;</div><div class="line">    // 对subgroupIndex进行排序</div><div class="line">    chord.sortSubgroups = function(_) &#123;</div><div class="line">      return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;</div><div class="line">    &#125;;</div><div class="line">    //对chords数组进行排序，影响的是chord的层叠顺序，两根弦重叠，重叠部分后面的会覆盖掉前面的</div><div class="line">    chord.sortChords = function(_) &#123;</div><div class="line">      return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords &amp;&amp; sortChords._;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return chord;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>chord函数最终会得到一个包含多组<code>source</code>和<code>target</code>对象的数组以及<code>groups</code>数组，通过将该结果传递给<code>d3.arc</code>来绘制弦图外层的圆弧，而其内部的带状图则通过<code>d3.ribbon</code>来实现。</p>
<h2 id="ribbon"><a href="#ribbon" class="headerlink" title="ribbon"></a>ribbon</h2><p>用于绘制弦图中间部分表示各块之间联系的带状区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">  function ribbon() &#123;</div><div class="line">    var source = defaultSource,</div><div class="line">        target = defaultTarget,</div><div class="line">        radius = defaultRadius$1,</div><div class="line">        startAngle = defaultStartAngle,</div><div class="line">        endAngle = defaultEndAngle,</div><div class="line">        context = null;</div><div class="line"></div><div class="line">    function ribbon() &#123;</div><div class="line">      var buffer,</div><div class="line">          argv = slice$5.call(arguments),</div><div class="line">          //source对象</div><div class="line">          s = source.apply(this, argv),</div><div class="line">          //target对象</div><div class="line">          t = target.apply(this, argv),</div><div class="line">          //带状图形中弧线的半径</div><div class="line">          sr = +radius.apply(this, (argv[0] = s, argv)),</div><div class="line"></div><div class="line">          sa0 = startAngle.apply(this, argv) - halfPi$2,</div><div class="line">          sa1 = endAngle.apply(this, argv) - halfPi$2,</div><div class="line">          sx0 = sr * cos(sa0),</div><div class="line">          sy0 = sr * sin(sa0),</div><div class="line">          tr = +radius.apply(this, (argv[0] = t, argv)),</div><div class="line">          ta0 = startAngle.apply(this, argv) - halfPi$2,</div><div class="line">          ta1 = endAngle.apply(this, argv) - halfPi$2;</div><div class="line">      //构造path对象，用于存储路径</div><div class="line">      if (!context) context = buffer = path();</div><div class="line">      //移动到startAngle对应的起始点</div><div class="line">      context.moveTo(sx0, sy0);</div><div class="line">      //向endAngle位置画弧线</div><div class="line">      context.arc(0, 0, sr, sa0, sa1);</div><div class="line">      //判断source和target是否是同个位置</div><div class="line">      if (sa0 !== ta0 || sa1 !== ta1) &#123; // TODO sr !== tr?</div><div class="line">        // 从source的endAngle位置绘制贝塞尔曲线至target的startAngle处</div><div class="line">        context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));</div><div class="line">        //target的startAngle绘制圆弧至endAngle位置</div><div class="line">        context.arc(0, 0, tr, ta0, ta1);</div><div class="line">      &#125;</div><div class="line">      //以(0, 0)为控制点绘制贝塞尔曲线至startAngle位置</div><div class="line">      context.quadraticCurveTo(0, 0, sx0, sy0);</div><div class="line">      context.closePath();</div><div class="line"></div><div class="line">      if (buffer) return context = null, buffer + &quot;&quot; || null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ribbon.radius = function(_) &#123;</div><div class="line">      return arguments.length ? (radius = typeof _ === &quot;function&quot; ? _ : constant$11(+_), ribbon) : radius;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    ribbon.startAngle = function(_) &#123;</div><div class="line">      return arguments.length ? (startAngle = typeof _ === &quot;function&quot; ? _ : constant$11(+_), ribbon) : startAngle;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    ribbon.endAngle = function(_) &#123;</div><div class="line">      return arguments.length ? (endAngle = typeof _ === &quot;function&quot; ? _ : constant$11(+_), ribbon) : endAngle;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    ribbon.source = function(_) &#123;</div><div class="line">      return arguments.length ? (source = _, ribbon) : source;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    ribbon.target = function(_) &#123;</div><div class="line">      return arguments.length ? (target = _, ribbon) : target;</div><div class="line">    &#125;;</div><div class="line">    //设置当前路径上下文</div><div class="line">    ribbon.context = function(_) &#123;</div><div class="line">      return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return ribbon;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[d3.js源码分析——Selections]]></title>
      <url>http://arlendp.me/web/js/d3-source-code-selections/</url>
      <content type="html"><![CDATA[<p>在web开发中我们会花大量的时间用于dom的操作上，一般情况下我们会选择第三方库如jQuery来替代原生的方法，因为原生的方法在操作上会使代码大量重复冗余而不易操作。d3同样提供了一套自己的方法来很方便的对dom进行操作，像修改样式、注册时间等等都可以通过它来完成。<br><a id="more"></a></p>
<p>d3的selection主要用于直接对DOM进行操作，如设置属性、修改样式等等，同时它可以和data join（数据连接）这一强大的功能结合起来对元素和元素上绑定的数据进行操作。<br>selection中的方法计算后返回当前selection，这样可以进行方法的链式调用。由于通过这种方式调用方法会使得每行的代码很长，因此按照约定：若该方法返回的是<strong>当前的selection</strong>，则使用<strong>四个空格</strong>进行缩进；若方法返回的是<strong>新的selection</strong>，则使用<strong>两个空格</strong>进行缩进。</p>
<h2 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a>选择元素</h2><p>元素的选择通过两种方法<code>select</code>和<code>selectAll</code>来实现，前者只返回第一个匹配的元素，而后者返回所有匹配元素。<br>由于之后所有的操作都是在selection上进行，而该对象则是通过Selection构造函数得到的，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Selection(groups, parents) &#123;</div><div class="line">    this._groups = groups;</div><div class="line">    this._parents = parents;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，selection对象包含两个基本属性<code>_groups</code>和<code>_parents</code>，前者用于存储结点组，而后者则存储结点的父节点信息。</p>
<h3 id="selection-select-selector"><a href="#selection-select-selector" class="headerlink" title="selection.select(selector)"></a>selection.select(selector)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var p = d3.selectAll(&apos;div&apos;)</div><div class="line">          .select(&apos;p&apos;);</div></pre></td></tr></table></figure>
<p>该方法对selection中的每个元素进行查找，选择其中第一个匹配selector的子元素，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * Selection的select方法</div><div class="line"> * 通过select方法选择时，若不存在元素，则会在数组中将该位置留出（赋值为null）用于之后插入时使用。</div><div class="line"> */</div><div class="line"></div><div class="line">function selection_select(select) &#123;</div><div class="line">    if (typeof select !== &quot;function&quot;) select = selector(select);</div><div class="line">    //当select是函数时，直接调用该函数，并依次对该函数传入data信息、当前的索引和当前的结点group，同时将函数的this设置为当前dom对象</div><div class="line">    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j &lt; m; ++j) &#123;</div><div class="line">        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i &lt; n; ++i) &#123;</div><div class="line">            if ((node = group[i]) &amp;&amp; (subnode = select.call(node, node.__data__, i, group))) &#123;</div><div class="line">          //当node中有data信息时，node的子元素也添加该data信息</div><div class="line">            if (&quot;__data__&quot; in node) subnode.__data__ = node.__data__;</div><div class="line">                subgroup[i] = subnode;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //将父级的_parents属性作为子元素的_parents属性</div><div class="line">    return new Selection(subgroups, this._parents);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若selector为选择器字符串时，则会先调用selector方法将其转化为函数，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function selector(selector) &#123;</div><div class="line">    return selector == null ? none$2 : function() &#123;</div><div class="line">        //只返回第一个选中元素</div><div class="line">        return this.querySelector(selector);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，其内部调用的是js的原生方法<code>querySelector</code>。<br>上述代码对select参数进行处理后，使得其转化为函数，在后来的循环中调用时，通过<code>select.call</code>进行调用，传入的参数依次为<strong>结点的<strong>data</strong>属性值，结点在该结点组中的索引，该结点组</strong>。<br>有以下几点值得注意：</p>
<ul>
<li>若结点中包含<code>__data__</code>属性则会对匹配的子元素也设置该属性。</li>
<li>通过select方法得到的新的selection的<code>_parents</code>值并不会改变。</li>
</ul>
<h3 id="selection-selectAll-selector"><a href="#selection-selectAll-selector" class="headerlink" title="selection.selectAll(selector)"></a>selection.selectAll(selector)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var p = d3.selectAll(&apos;div&apos;)</div><div class="line">          .selectAll(&apos;p&apos;);</div></pre></td></tr></table></figure>
<p>该方法对selection中的每个元素进行查找，选择其中匹配selector的子元素，返回的selection中的元素根据其父结点进行对应的分组，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 对selection进行selectAll计算会改变selection结构，parents也会改变</div><div class="line"> */</div><div class="line">function selection_selectAll(select) &#123;</div><div class="line">    if (typeof select !== &quot;function&quot;) select = selectorAll(select);</div><div class="line">    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j &lt; m; ++j) &#123;</div><div class="line">        for (var group = groups[j], n = group.length, node, i = 0; i &lt; n; ++i) &#123;</div><div class="line">            if (node = group[i]) &#123;</div><div class="line">                subgroups.push(select.call(node, node.__data__, i, group));</div><div class="line">                parents.push(node);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return new Selection(subgroups, parents);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码可以看出，对node调用select方法后，查找到的结果存入subgroups中，同时将node作为父结点存入parents数组中，使得结点与父结点一一对应，最终返回新的selection。</p>
<h3 id="selection-filter-filter"><a href="#selection-filter-filter" class="headerlink" title="selection.filter(filter)"></a>selection.filter(filter)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var red = d3.selectAll(&apos;p&apos;)</div><div class="line">            .filter(&apos;.red&apos;)</div></pre></td></tr></table></figure>
<p>将使得filter为true的元素构造成新的selection并返回，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//filter方法对当前selection进行过滤，保留满足条件的元素</div><div class="line">function selection_filter(match) &#123;</div><div class="line">    if (typeof match !== &quot;function&quot;) match = matcher$1(match);</div><div class="line">    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j &lt; m; ++j) &#123;</div><div class="line">            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i &lt; n; ++i) &#123;</div><div class="line">                if ((node = group[i]) &amp;&amp; match.call(node, node.__data__, i, group)) &#123;</div><div class="line">                subgroup.push(node);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return new Selection(subgroups, this._parents);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若<code>match</code>不为函数，则通过<code>matcher$1</code>函数对其进行处理，其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var matcher = function(selector) &#123;</div><div class="line">    return function() &#123;</div><div class="line">        //Element.matches(s)，如果元素能通过s选择器选择到则返回true；否则返回false</div><div class="line">        return this.matches(selector);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可看出<code>matcher</code>函数内部是调用原生的<code>Element.matches</code>方法实现。</p>
<h3 id="selection-merge-other-selection"><a href="#selection-merge-other-selection" class="headerlink" title="selection.merge(other_selection)"></a>selection.merge(other_selection)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var circle = svg.selectAll(&quot;circle&quot;).data(data) // UPDATE</div><div class="line">    .style(&quot;fill&quot;, &quot;blue&quot;);</div><div class="line"></div><div class="line">circle.exit().remove(); // EXIT</div><div class="line"></div><div class="line">circle.enter().append(&quot;circle&quot;) // ENTER</div><div class="line">    .style(&quot;fill&quot;, &quot;green&quot;)</div><div class="line">  .merge(circle) // ENTER + UPDATE</div><div class="line">    .style(&quot;stroke&quot;, &quot;black&quot;);</div></pre></td></tr></table></figure>
<p>该方法将两个selection进行合并成一个新的selection并返回，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function selection_merge(selection) &#123;</div><div class="line">    //新的selection的_.groups长度和groups0相同，合并时只在m范围内计算</div><div class="line">    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j &lt; m; ++j) &#123;</div><div class="line">        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i &lt; n; ++i) &#123;</div><div class="line">            //groups0数组大小不变，只有在group0[i]不存在，group1[i]存在时才选择group1[i]</div><div class="line">            if (node = group0[i] || group1[i]) &#123;</div><div class="line">                merge[i] = node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 若m1 &lt; m0，则将groups0剩余的复制过来</div><div class="line">    for (; j &lt; m0; ++j) &#123;</div><div class="line">      merges[j] = groups0[j];</div><div class="line">    &#125;</div><div class="line">    return new Selection(merges, this._parents);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法实际上相当于对this selection中的空元素进行填充。</p>
<h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><p>在选择元素之后可以使用selection的方法来修改元素，如样式、属性等。</p>
<h3 id="selection-attr-name-value"><a href="#selection-attr-name-value" class="headerlink" title="selection.attr(name[, value])"></a>selection.attr(name[, value])</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var p = d3.selectAll(&apos;p&apos;)</div><div class="line">            .attr(&apos;class&apos;, &apos;red&apos;);</div></pre></td></tr></table></figure>
<p>对selection中的元素以指定的name和value设置属性，并返回当前selection，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function selection_attr(name, value) &#123;</div><div class="line">    var fullname = namespace(name);</div><div class="line"></div><div class="line">    if (arguments.length &lt; 2) &#123;</div><div class="line">        //得到selection中第一个存在的元素</div><div class="line">        var node = this.node();</div><div class="line">        return fullname.local</div><div class="line">            ? node.getAttributeNS(fullname.space, fullname.local)</div><div class="line">            : node.getAttribute(fullname);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return this.each((value == null</div><div class="line">        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === &quot;function&quot;</div><div class="line">        ? (fullname.local ? attrFunctionNS : attrFunction)</div><div class="line">        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若只有name参数时，则返回第一个存在的元素的name属性值，调用的是原生的<code>Element.getAttribute</code>方法。<br>当有两个参数时，调用<code>selection.each</code>方法对selection中的每个元素进行操作，其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function selection_each(callback) &#123;</div><div class="line">    for (var groups = this._groups, j = 0, m = groups.length; j &lt; m; ++j) &#123;</div><div class="line">        for (var group = groups[j], i = 0, n = group.length, node; i &lt; n; ++i) &#123;</div><div class="line">            if (node = group[i]) callback.call(node, node.__data__, i, group);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若value值为函数，则将name和value传入attrFunction函数中进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function attrFunction(name, value) &#123;</div><div class="line">    return function() &#123;</div><div class="line">        var v = value.apply(this, arguments);</div><div class="line">        if (v == null) this.removeAttribute(name);</div><div class="line">        else this.setAttribute(name, v);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>selection.each</code>方法中，将参数传入value函数中，根据value返回结果选择设置和删除属性操作。</p>
<h3 id="selection-classed-names-value"><a href="#selection-classed-names-value" class="headerlink" title="selection.classed(names[, value])"></a>selection.classed(names[, value])</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var p = d3.selectAll(&apos;p&apos;)</div><div class="line">            .classed(&apos;red warn&apos;, true);</div></pre></td></tr></table></figure>
<p>对selection中的元素设置类名，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 当value为真值时，在所有元素类名中添加name；否则删除name</div><div class="line">function selection_classed(name, value) &#123;</div><div class="line">    var names = classArray(name + &quot;&quot;);</div><div class="line">    // 当只有name参数时，判断该selection对象的_groups里第一个存在的结点是否包含所有的name的类名，如果是则返回true；否则，返回false</div><div class="line">    if (arguments.length &lt; 2) &#123;</div><div class="line">        var list = classList(this.node()), i = -1, n = names.length;</div><div class="line">        while (++i &lt; n) if (!list.contains(names[i])) return false;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return this.each((typeof value === &quot;function&quot;</div><div class="line">        ? classedFunction : value</div><div class="line">        ? classedTrue</div><div class="line">        : classedFalse)(names, value));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中<code>classArray</code>方法是将类名字符串拆分成数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 将类名拆分成数组，如&apos;button button-warn&apos; =&gt; [&apos;button&apos;, &apos;button-warn&apos;]</div><div class="line">function classArray(string) &#123;</div><div class="line">    return string.trim().split(/^|\s+/);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="selection-style-name-value-priority"><a href="#selection-style-name-value-priority" class="headerlink" title="selection.style(name[, value[, priority]])"></a>selection.style(name[, value[, priority]])</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var p = d3.selectAll(&apos;p&apos;)</div><div class="line">            .style(&apos;color&apos;, &apos;red&apos;);</div></pre></td></tr></table></figure>
<p>该方法对selection中的元素设置样式，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 设置selection的样式，注意样式的单位问题</div><div class="line">function selection_style(name, value, priority) &#123;</div><div class="line">    var node;</div><div class="line">    return arguments.length &gt; 1</div><div class="line">        ? this.each((value == null</div><div class="line">              ? styleRemove : typeof value === &quot;function&quot;</div><div class="line">              ? styleFunction</div><div class="line">              : styleConstant)(name, value, priority == null ? &quot;&quot; : priority))</div><div class="line">        : window(node = this.node())</div><div class="line">            .getComputedStyle(node, null)</div><div class="line">            .getPropertyValue(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上述代码可以看出，获取样式是通过<code>window.getComputedStyle(element).getPropertyValue(name)</code>来得到（该方法得到的值是只读的），而删除样式则是通过<code>element.style.removeProperty(name)</code>来实现，设置属性通过<code>element.style.setProperty(name, value)</code>来实现。</p>
<h3 id="selection-property-name-value"><a href="#selection-property-name-value" class="headerlink" title="selection.property(name[, value])"></a>selection.property(name[, value])</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var checkbox = d3.selectAll(&apos;input[type=checkbox]&apos;)</div><div class="line">                    .property(&apos;checked&apos;, &apos;checked&apos;);</div></pre></td></tr></table></figure>
<p>该方法设置一些特殊的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function selection_property(name, value) &#123;</div><div class="line">    return arguments.length &gt; 1</div><div class="line">        ? this.each((value == null</div><div class="line">            ? propertyRemove : typeof value === &quot;function&quot;</div><div class="line">            ? propertyFunction</div><div class="line">            : propertyConstant)(name, value))</div><div class="line">        : this.node()[name];</div><div class="line">&#125;</div><div class="line"></div><div class="line">function propertyRemove(name) &#123;</div><div class="line">    return function() &#123;</div><div class="line">      delete this[name];</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">function propertyConstant(name, value) &#123;</div><div class="line">    return function() &#123;</div><div class="line">      this[name] = value;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function propertyFunction(name, value) &#123;</div><div class="line">    return function() &#123;</div><div class="line">      var v = value.apply(this, arguments);</div><div class="line">      if (v == null) delete this[name];</div><div class="line">      else this[name] = v;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内部通过直接修改元素的属性来实现。</p>
<h3 id="selection-text-value"><a href="#selection-text-value" class="headerlink" title="selection.text([value])"></a>selection.text([value])</h3><p>该方法对selection中的所有元素设置文本内容，同时会替换掉元素中的子元素，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function textRemove() &#123;</div><div class="line">    this.textContent = &quot;&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function textConstant(value) &#123;</div><div class="line">    return function() &#123;</div><div class="line">      this.textContent = value;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function textFunction(value) &#123;</div><div class="line">    return function() &#123;</div><div class="line">      var v = value.apply(this, arguments);</div><div class="line">      this.textContent = v == null ? &quot;&quot; : v;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">// 设置元素的textContent属性，该属性返回的是元素内的纯文本内容，不包含结点标签（但包含标签内的文本）</div><div class="line">function selection_text(value) &#123;</div><div class="line">    return arguments.length</div><div class="line">        ? this.each(value == null</div><div class="line">            ? textRemove : (typeof value === &quot;function&quot;</div><div class="line">            ? textFunction</div><div class="line">            : textConstant)(value))</div><div class="line">        : this.node().textContent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码是通过<code>element.textContent</code>方法来获取和修改文本内容。</p>
<h3 id="selection-html-value"><a href="#selection-html-value" class="headerlink" title="selection.html([value])"></a>selection.html([value])</h3><p>对selection中的所有元素设置innerHTML。方法同上述<code>selection.text</code>类似，只是通过<code>element.innerHTML</code>来修改元素内的所有内容。</p>
<h3 id="selection-append-type"><a href="#selection-append-type" class="headerlink" title="selection.append(type)"></a>selection.append(type)</h3><p>对selection中的元素添加新的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * selection的append方法</div><div class="line"> * 该方法返回新的Selection对象，</div><div class="line"> */</div><div class="line">function selection_append(name) &#123;</div><div class="line">    var create = typeof name === &quot;function&quot; ? name : creator(name);</div><div class="line">    return this.select(function() &#123;</div><div class="line">        //arguments是传入当前匿名函数的参数</div><div class="line">        return this.appendChild(create.apply(this, arguments));</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function creatorInherit(name) &#123;</div><div class="line">    return function() &#123;</div><div class="line">        //ownerDocument返回当前document对象</div><div class="line">        var document = this.ownerDocument,</div><div class="line">            uri = this.namespaceURI;</div><div class="line">        return uri === xhtml &amp;&amp; document.documentElement.namespaceURI === xhtml</div><div class="line">            ? document.createElement(name)//创建dom对象</div><div class="line">            : document.createElementNS(uri, name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法中调用到了<code>selection.select</code>方法，由于<code>element.appendChild</code>方法返回的是该子结点，因此返回的新的selection包含的是所有添加的子结点。</p>
<h3 id="selection-insert-type-before"><a href="#selection-insert-type-before" class="headerlink" title="selection.insert(type, before)"></a>selection.insert(type, before)</h3><p>对selection中的元素插入新的元素，同上述<code>selection.append</code>方法类似，只是内部使用<code>element.insertBefore</code>方法实现。</p>
<h3 id="selection-sort-compare"><a href="#selection-sort-compare" class="headerlink" title="selection.sort(compare)"></a>selection.sort(compare)</h3><p>根据<code>compare</code>函数对selection中的元素进行排序，排好序后按照排序结果对dom进行排序，返回排序后新创建的selection对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function selection_sort(compare) &#123;</div><div class="line">    if (!compare) compare = ascending$2;</div><div class="line"></div><div class="line">    function compareNode(a, b) &#123;</div><div class="line">      // 比较结点的data大小</div><div class="line">      return a &amp;&amp; b ? compare(a.__data__, b.__data__) : !a - !b;</div><div class="line">    &#125;</div><div class="line">    // copy一份selection中的_groups包含的结点</div><div class="line">    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j &lt; m; ++j) &#123;</div><div class="line">        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i &lt; n; ++i) &#123;</div><div class="line">            if (node = group[i]) &#123;</div><div class="line">                sortgroup[i] = node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 调用array的sort方法</div><div class="line">        sortgroup.sort(compareNode);</div><div class="line">    &#125;</div><div class="line">    return new Selection(sortgroups, this._parents).order();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 递增</div><div class="line">function ascending$2(a, b) &#123;</div><div class="line">    return a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若没有compare参数，则默认以递增的方式排序。同时排序是首先比较元素中的<code>__data__</code>属性值的大小，对selection排好序后调用order方法。</p>
<h3 id="selection-sort-compare-1"><a href="#selection-sort-compare-1" class="headerlink" title="selection.sort(compare)"></a>selection.sort(compare)</h3><p>按照selection中每组内元素的顺序对dom进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 对dom结点进行排序</div><div class="line">function selection_order() &#123;</div><div class="line">    for (var groups = this._groups, j = -1, m = groups.length; ++j &lt; m;) &#123;</div><div class="line">        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i &gt;= 0;) &#123;</div><div class="line">            if (node = group[i]) &#123;</div><div class="line">                // 将node移至next的前面，并将node赋值给next</div><div class="line">                if (next &amp;&amp; next !== node.nextSibling) next.parentNode.insertBefore(node, next);</div><div class="line">                next = node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="连接数据"><a href="#连接数据" class="headerlink" title="连接数据"></a>连接数据</h2><p>连接数据是将数据绑定到selection对象上，实际上是将数据存储到<code>__data__</code>属性中，这样之后对selection的操作过程中便可以直接使用绑定好的数据。主要要理解<code>update</code>、<code>enter</code>和<code>exit</code>，可参考文章<a href="https://bost.ocks.org/mike/join/" target="_blank" rel="external">Thinking With Joins</a>。</p>
<h3 id="selection-data-data-key"><a href="#selection-data-data-key" class="headerlink" title="selection.data([data[, key]])"></a>selection.data([data[, key]])</h3><p>该方法将指定的data数组绑定到选中的元素上，返回的selection包含成功绑定数据的元素，也叫做<code>updata selection</code>，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">function selection_data(value, key) &#123;</div><div class="line">    //当value为假值时，将selection所有元素的__data__属性以数组形式返回</div><div class="line">    if (!value) &#123;</div><div class="line">      data = new Array(this.size()), j = -1;</div><div class="line">      this.each(function(d) &#123; data[++j] = d; &#125;);</div><div class="line">      return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var bind = key ? bindKey : bindIndex,</div><div class="line">        parents = this._parents,</div><div class="line">        groups = this._groups;</div><div class="line"></div><div class="line">    if (typeof value !== &quot;function&quot;) value = constant$4(value);</div><div class="line"></div><div class="line">    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j &lt; m; ++j) &#123;</div><div class="line">      var parent = parents[j],</div><div class="line">          group = groups[j],</div><div class="line">          groupLength = group.length,</div><div class="line">          data = value.call(parent, parent &amp;&amp; parent.__data__, j, parents),</div><div class="line">          dataLength = data.length,</div><div class="line">          enterGroup = enter[j] = new Array(dataLength),</div><div class="line">          updateGroup = update[j] = new Array(dataLength),</div><div class="line">          exitGroup = exit[j] = new Array(groupLength);</div><div class="line"></div><div class="line">      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);</div><div class="line"></div><div class="line">      // 对enter结点设置_next属性，存储其索引之后的第一个update结点</div><div class="line">      for (var i0 = 0, i1 = 0, previous, next; i0 &lt; dataLength; ++i0) &#123;</div><div class="line">        if (previous = enterGroup[i0]) &#123;</div><div class="line">          if (i0 &gt;= i1) i1 = i0 + 1;</div><div class="line">          while (!(next = updateGroup[i1]) &amp;&amp; ++i1 &lt; dataLength);</div><div class="line">          previous._next = next || null;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    // 将enter和exit存入update selection的属性中</div><div class="line">    update = new Selection(update, parents);</div><div class="line">    update._enter = enter;</div><div class="line">    update._exit = exit;</div><div class="line">    return update;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上述代码可以看到，对每组group绑定的是相同的data数据。<br>当没有key参数时，绑定数据使用的是<code>bindIndex</code>方法，按照索引一次绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function bindIndex(parent, group, enter, update, exit, data) &#123;</div><div class="line">    var i = 0,</div><div class="line">        node,</div><div class="line">        groupLength = group.length,</div><div class="line">        dataLength = data.length;</div><div class="line"></div><div class="line">    /*</div><div class="line">     * 将data数据绑定到node，并将该node存入update数组中</div><div class="line">     * 将剩余的data数据存入enter数组中</div><div class="line">     */</div><div class="line">    for (; i &lt; dataLength; ++i) &#123;</div><div class="line">      if (node = group[i]) &#123;</div><div class="line">        node.__data__ = data[i];</div><div class="line">        update[i] = node;</div><div class="line">      &#125; else &#123;</div><div class="line">        enter[i] = new EnterNode(parent, data[i]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将剩余的node存入exit数组中</div><div class="line">    for (; i &lt; groupLength; ++i) &#123;</div><div class="line">      if (node = group[i]) &#123;</div><div class="line">        exit[i] = node;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>若含有key参数，则调用<code>bindKey</code>方法来绑定数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">function bindKey(parent, group, enter, update, exit, data, key) &#123;</div><div class="line">    var i,</div><div class="line">        node,</div><div class="line">        nodeByKeyValue = &#123;&#125;,</div><div class="line">        groupLength = group.length,</div><div class="line">        dataLength = data.length,</div><div class="line">        keyValues = new Array(groupLength),</div><div class="line">        keyValue;</div><div class="line"></div><div class="line">    // 对group中每个结点计算keyValue，如果之后的结点含有与前面结点相同的keyValue则将该结点存入exit数组中</div><div class="line">    for (i = 0; i &lt; groupLength; ++i) &#123;</div><div class="line">      if (node = group[i]) &#123;</div><div class="line">        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);</div><div class="line">        if (keyValue in nodeByKeyValue) &#123;</div><div class="line">          exit[i] = node;</div><div class="line">        &#125; else &#123;</div><div class="line">          nodeByKeyValue[keyValue] = node;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对每一个data计算keyValue，如果该keyValue已存在nodeByKeyValue数组中，则将其对应的node存入update数组且绑定data数据；否则将data存入enter中</div><div class="line">    for (i = 0; i &lt; dataLength; ++i) &#123;</div><div class="line">      keyValue = keyPrefix + key.call(parent, data[i], i, data);</div><div class="line">      if (node = nodeByKeyValue[keyValue]) &#123;</div><div class="line">        update[i] = node;</div><div class="line">        node.__data__ = data[i];</div><div class="line">        nodeByKeyValue[keyValue] = null;</div><div class="line">      &#125; else &#123;</div><div class="line">        enter[i] = new EnterNode(parent, data[i]);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将剩余的没有绑定数据的结点存入exit数组</div><div class="line">    for (i = 0; i &lt; groupLength; ++i) &#123;</div><div class="line">      if ((node = group[i]) &amp;&amp; (nodeByKeyValue[keyValues[i]] === node)) &#123;</div><div class="line">        exit[i] = node;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="selection-enter"><a href="#selection-enter" class="headerlink" title="selection.enter()"></a>selection.enter()</h3><p>返回selections中的enter selection，即<code>selection._enter</code>的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function sparse(update) &#123;</div><div class="line">    return new Array(update.length);</div><div class="line">  &#125;</div><div class="line">// selection的enter方法</div><div class="line">function selection_enter() &#123;</div><div class="line">    return new Selection(this._enter || this._groups.map(sparse), this._parents);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若selection没有<code>_enter</code>属性，即没有进行过<code>data</code>操作，则创建空的数组。</p>
<h3 id="selection-exit"><a href="#selection-exit" class="headerlink" title="selection.exit()"></a>selection.exit()</h3><p>返回selection中的exit selection，即<code>selection._exit</code>的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function selection_exit() &#123;</div><div class="line">    return new Selection(this._exit || this._groups.map(sparse), this._parents);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="selection-datum-value"><a href="#selection-datum-value" class="headerlink" title="selection.datum([value])"></a>selection.datum([value])</h3><p>对selection中的每个元素设置绑定数据，该方法并不会影响到<code>enter</code>和<code>exit</code>的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function selection_datum(value) &#123;</div><div class="line">    return arguments.length</div><div class="line">        ? this.property(&quot;__data__&quot;, value)</div><div class="line">        : this.node().__data__;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见其调用<code>selection.property</code>方法来设置<code>__data__</code>属性。<br>经常会使用该方法来进行HTML5 data属性的访问，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">selection.datum(function() &#123;return this.dataset&#125;);</div></pre></td></tr></table></figure></p>
<p><code>element.dataset</code>是原生方法，返回的是元素绑定的所有data属性。</p>
<h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><h3 id="selection-on-typenames-listener-capture"><a href="#selection-on-typenames-listener-capture" class="headerlink" title="selection.on(typenames[, listener[, capture]])"></a>selection.on(typenames[, listener[, capture]])</h3><p>该方法用于对selection中的元素添加或者移除事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function selection_on(typename, value, capture) &#123;</div><div class="line">    var typenames = parseTypenames$1(typename + &quot;&quot;), i, n = typenames.length, t;</div><div class="line">    // 如果只有typename参数，根据type和name值来找到selection中第一个存在的元素的__on属性中对应的value值。</div><div class="line">    if (arguments.length &lt; 2) &#123;</div><div class="line">      var on = this.node().__on;</div><div class="line">      if (on) for (var j = 0, m = on.length, o; j &lt; m; ++j) &#123;</div><div class="line">        for (i = 0, o = on[j]; i &lt; n; ++i) &#123;</div><div class="line">          if ((t = typenames[i]).type === o.type &amp;&amp; t.name === o.name) &#123;</div><div class="line">            return o.value;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    // 如果value为真值，则添加事件；否则移除事件。</div><div class="line">    on = value ? onAdd : onRemove;</div><div class="line">    if (capture == null) capture = false;</div><div class="line">    for (i = 0; i &lt; n; ++i) this.each(on(typenames[i], value, capture));</div><div class="line">    return this;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>首先是对typename参数进行处理，使用的是<code>parseTypenames</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 对typenames根据空格来划分成数组，并根据分离后的字符串中的&apos;.&apos;来将该字符串分割为type和name部分，如：&apos;click.foo click.bar&apos; =&gt; [&#123;type: &apos;click&apos;, name: &apos;foo&apos;&#125;, &#123;type: &apos;click&apos;, name: &apos;bar&apos;&#125;]</div><div class="line">function parseTypenames$1(typenames) &#123;</div><div class="line">    return typenames.trim().split(/^|\s+/).map(function(t) &#123;</div><div class="line">      var name = &quot;&quot;, i = t.indexOf(&quot;.&quot;);</div><div class="line">      if (i &gt;= 0) name = t.slice(i + 1), t = t.slice(0, i);</div><div class="line">      return &#123;type: t, name: name&#125;;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据value是否为真值来选择添加或者移除事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 添加事件函数</div><div class="line">function onAdd(typename, value, capture) &#123;</div><div class="line">    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;</div><div class="line">    return function(d, i, group) &#123;</div><div class="line">        var on = this.__on, o, listener = wrap(value, i, group);</div><div class="line">        if (on) for (var j = 0, m = on.length; j &lt; m; ++j) &#123;</div><div class="line">            // 如果新事件的type和name和之前已绑定的事件相同，则移除之前的事件并绑定新的事件</div><div class="line">            if ((o = on[j]).type === typename.type &amp;&amp; o.name === typename.name) &#123;</div><div class="line">                this.removeEventListener(o.type, o.listener, o.capture);</div><div class="line">                this.addEventListener(o.type, o.listener = listener, o.capture = capture);</div><div class="line">                o.value = value;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 添加事件，并将事件信息存入selection.__on属性中</div><div class="line">        this.addEventListener(typename.type, listener, capture);</div><div class="line">        o = &#123;type: typename.type, name: typename.name, value: value, listener: listener, capture: capture&#125;;</div><div class="line">        if (!on) this.__on = [o];</div><div class="line">        else on.push(o);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 移除事件函数</div><div class="line">function onRemove(typename) &#123;</div><div class="line">    return function() &#123;</div><div class="line">        var on = this.__on;</div><div class="line">        if (!on) return;</div><div class="line">        for (var j = 0, i = -1, m = on.length, o; j &lt; m; ++j) &#123;</div><div class="line">            if (o = on[j], (!typename.type || o.type === typename.type) &amp;&amp; o.name === typename.name) &#123;</div><div class="line">            //对结点移除事件</div><div class="line">            this.removeEventListener(o.type, o.listener, o.capture);</div><div class="line">            &#125; else &#123;</div><div class="line">                //修改结点的__on属性值</div><div class="line">                on[++i] = o;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (++i) on.length = i;</div><div class="line">        //on为空则删除__on属性</div><div class="line">        else delete this.__on;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="selection-dispatch-type-parameters"><a href="#selection-dispatch-type-parameters" class="headerlink" title="selection.dispatch(type[, parameters])"></a>selection.dispatch(type[, parameters])</h3><p>对selection中的元素分派指定类型的自定义事件，其中parameters可能包含以下内容：</p>
<ul>
<li>bubbles：设置为true表示事件可以冒泡</li>
<li>cancelable：设置为true表示事件可以被取消</li>
<li>detail：绑定到事件上的自定义数据<br>源码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//分派事件</div><div class="line">function selection_dispatch(type, params) &#123;</div><div class="line">    return this.each((typeof params === &quot;function&quot;</div><div class="line">        ? dispatchFunction</div><div class="line">        : dispatchConstant)(type, params));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function dispatchConstant(type, params) &#123;</div><div class="line">    return function() &#123;</div><div class="line">      return dispatchEvent(this, type, params);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function dispatchFunction(type, params) &#123;</div><div class="line">    return function() &#123;</div><div class="line">      return dispatchEvent(this, type, params.apply(this, arguments));</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>dispatchEvent</code>函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//创建自定义事件并分派给指定元素</div><div class="line">function dispatchEvent(node, type, params) &#123;</div><div class="line">    var window$$ = window(node),</div><div class="line">        event = window$$.CustomEvent;</div><div class="line"></div><div class="line">    if (event) &#123;</div><div class="line">      event = new event(type, params);</div><div class="line">    &#125; else &#123;</div><div class="line">        //该方法已被废弃</div><div class="line">        event = window$$.document.createEvent(&quot;Event&quot;);</div><div class="line">        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;</div><div class="line">        else event.initEvent(type, false, false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    node.dispatchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-event"><a href="#d3-event" class="headerlink" title="d3.event"></a>d3.event</h3><p>存储当前事件，在调用事件监听器的时候设置，处理函数执行完毕后重置，可以获取其中包含的事件信息如：<code>event.pageX</code>。</p>
<h3 id="d3-customEvent-event-listener-that-arguments"><a href="#d3-customEvent-event-listener-that-arguments" class="headerlink" title="d3.customEvent(event, listener[, that[, arguments]])"></a>d3.customEvent(event, listener[, that[, arguments]])</h3><p>该方法调用指定的监听器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//调用指定的监听器</div><div class="line">function customEvent(event1, listener, that, args) &#123;</div><div class="line">    //记录当前事件</div><div class="line">    var event0 = exports.event;</div><div class="line">    event1.sourceEvent = exports.event;</div><div class="line">    exports.event = event1;</div><div class="line">    try &#123;</div><div class="line">        return listener.apply(that, args);</div><div class="line">    &#125; finally &#123;</div><div class="line">        //监听器执行完后恢复事件</div><div class="line">        exports.event = event0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="d3-mouse-container"><a href="#d3-mouse-container" class="headerlink" title="d3.mouse(container)"></a>d3.mouse(container)</h3><p>返回当前当前事件相对于指定容器的x和y坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function mouse(node) &#123;</div><div class="line">    var event = sourceEvent();</div><div class="line">    //如果是触摸事件，返回Touch对象</div><div class="line">    if (event.changedTouches) event = event.changedTouches[0];</div><div class="line">    return point$5(node, event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>point$5</code>方法用于计算坐标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function point$5(node, event) &#123;</div><div class="line">    //若node是svg元素，则获取svg容器</div><div class="line">    var svg = node.ownerSVGElement || node;</div><div class="line"></div><div class="line">    if (svg.createSVGPoint) &#123;</div><div class="line">      //创建SVGPoint对象</div><div class="line">      var point = svg.createSVGPoint();</div><div class="line">      //将事件相对客户端的x和y坐标赋值给point对象</div><div class="line">      point.x = event.clientX, point.y = event.clientY;</div><div class="line">      //进行坐标转换</div><div class="line">      point = point.matrixTransform(node.getScreenCTM().inverse());</div><div class="line">      return [point.x, point.y];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var rect = node.getBoundingClientRect();</div><div class="line">    //返回event事件相对于容器的坐标</div><div class="line">    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>用于selection的一些高级操作。</p>
<h3 id="selection-each-function"><a href="#selection-each-function" class="headerlink" title="selection.each(function)"></a>selection.each(function)</h3><p>为每一个选中的元素调用指定的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//selection的each方法</div><div class="line">function selection_each(callback) &#123;</div><div class="line"></div><div class="line">    for (var groups = this._groups, j = 0, m = groups.length; j &lt; m; ++j) &#123;</div><div class="line">      for (var group = groups[j], i = 0, n = group.length, node; i &lt; n; ++i) &#123;</div><div class="line">        //通过call方式调用回调函数</div><div class="line">        if (node = group[i]) callback.call(node, node.__data__, i, group);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="selection-call-function-arguments…"><a href="#selection-call-function-arguments…" class="headerlink" title="selection.call(function[, arguments…])"></a>selection.call(function[, arguments…])</h3><p>将selection和其他参数传入指定函数中执行，并返回当前selection，这和直接链式调用<code>function(selection)</code>相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function selection_call() &#123;</div><div class="line">    var callback = arguments[0];</div><div class="line">    arguments[0] = this;</div><div class="line">    callback.apply(null, arguments);</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>d3的局部变量可以定义与data独立开来的局部状态，它的作用域是dom元素。<br>其构造函数和原型方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Local() &#123;</div><div class="line">    this._ = &quot;@&quot; + (++nextId).toString(36);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Local.prototype = local.prototype = &#123;</div><div class="line">    constructor: Local,</div><div class="line">    get: function(node) &#123;</div><div class="line">      var id = this._;</div><div class="line">      while (!(id in node)) if (!(node = node.parentNode)) return;</div><div class="line">      return node[id];</div><div class="line">    &#125;,</div><div class="line">    set: function(node, value) &#123;</div><div class="line">      return node[this._] = value;</div><div class="line">    &#125;,</div><div class="line">    remove: function(node) &#123;</div><div class="line">      return this._ in node &amp;&amp; delete node[this._];</div><div class="line">    &#125;,</div><div class="line">    toString: function() &#123;</div><div class="line">      return this._;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[javascript正则表达式]]></title>
      <url>http://arlendp.me/web/js/javascript-regex/</url>
      <content type="html"><![CDATA[<p>正则表达式常用作检索、匹配或者替换文本，它是一种文本模式匹配的方法，在我们对复杂文本进行操作时，使用正则表达式会极大的简化我们的操作。本文将介绍正则表达式对象和匹配规则。<br><a id="more"></a></p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>正则表达式是一种表示文本模式的方法，常用于匹配文本，例如email地址的验证等等，js中的正则表达式是Perl 5的子集。</p>
<p>正则表达式有两种写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/abc/</span>;</div><div class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>);</div></pre></td></tr></table></figure>
<p>上述两种写法的主要区别在于新建正则表达式的时间，前者是在编译时完成，后者则是在运行时完成。</p>
<h2 id="2-正则表达式对象"><a href="#2-正则表达式对象" class="headerlink" title="2. 正则表达式对象"></a>2. 正则表达式对象</h2><h3 id="2-1-属性"><a href="#2-1-属性" class="headerlink" title="2.1 属性"></a>2.1 属性</h3><p>正则表达式对象的属性主要有5个：</p>
<ul>
<li>与修饰符相关，都返回布尔值并且都是只读属性：<ul>
<li>ignoreCase：表示是否设置了i修饰符</li>
<li>global：表示是否设置了g修饰符</li>
<li>multiline：表示是否设置m修饰符</li>
</ul>
</li>
<li>与修饰符无关：<ul>
<li>lastIndex：返回下一次开始搜索的位置，<strong>且只在设置了g修饰符时才有意义</strong>。</li>
<li>source：返回正则表达式相应的字符串形式。</li>
</ul>
</li>
</ul>
<h3 id="2-2-方法（正则表达式）"><a href="#2-2-方法（正则表达式）" class="headerlink" title="2.2 方法（正则表达式）"></a>2.2 方法（正则表达式）</h3><ul>
<li><p><code>test()</code></p>
<ul>
<li>test接收一个字符串用于验证该字符串能否被匹配，结果返回布尔值。</li>
<li>若正则表达式字符串为空，则能匹配所有字符串。</li>
</ul>
</li>
<li><p><code>exec()</code></p>
<ul>
<li>exec接收一个字符串并且以数组的形式返回匹配结果，含有每一个匹配成功的子字符串，若匹配失败则返回null。</li>
<li>返回的数组含有两个属性：<ul>
<li><code>input</code>：表示原字符串</li>
<li><code>index</code>：表示模式匹配成功的开始位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-方法（字符串）"><a href="#2-3-方法（字符串）" class="headerlink" title="2.3 方法（字符串）"></a>2.3 方法（字符串）</h3><ul>
<li>match()：返回一个数组，成员是所有匹配的子字符串。<ul>
<li>该方法与正则表达式的<code>exec</code>方法类似</li>
<li>如果正则表达式带有<code>g</code>修饰符，该方法会返回所有匹配的结果，而<code>exec</code>则不会。</li>
<li>设置<code>lastIndex</code>属性对其无效。</li>
</ul>
</li>
<li>search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。若不匹配则返回-1.（<strong>忽略g修饰符和lastIndex属性</strong>）。</li>
<li>replace()：按照给定的正则表达式进行替换，返回替换后的字符串。<ul>
<li>有两个参数，第一个是搜索的模式，第二个是替换的内容。</li>
<li>搜索模式如果不加g修饰符，则替换第一个匹配的结果，否则替换所有的匹配结果。</li>
<li>该方法的第二个参数可以使用<code>$</code>来指代所替换的内容。<ul>
<li><code>$&amp;</code> 指代匹配的子字符串。</li>
<li><code>$\</code> 指代匹配结果前面的文本。</li>
<li><code>$&#39;</code> 指代匹配结果后面的文本。</li>
<li><code>$n</code> 指代匹配成功的第n组内容，n是从1开始的自然数。</li>
<li><code>$$</code> 指代美元符号$。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
<h3 id="2-4-匹配规则"><a href="#2-4-匹配规则" class="headerlink" title="2.4 匹配规则"></a>2.4 匹配规则</h3><ul>
<li>字面量字符：字符直接表示其字面的含义，如/a/、/word/。</li>
<li>元字符：表示特殊含义<ul>
<li><code>.</code>字符<ul>
<li>能匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</li>
<li>但是只能匹配一个字符。</li>
</ul>
</li>
<li>位置字符<ul>
<li><code>^</code>字符：表示字符串的开始位置</li>
<li><code>$</code>字符：表示字符串的结束位置</li>
</ul>
</li>
<li>选择符<ul>
<li><code>|</code>字符：表示关系”或“。<strong>会包括前后的多个字符</strong><ul>
<li>重复类：用于精确设置匹配次数，使用<code>{}</code>表示。<code>{n}</code>表示重复n次，<code>{n,}</code>表示不少于n次，<code>{m,n}</code>表示重复m~n次。<strong>只匹配前一个字符</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>量词符：用于设置模式匹配的次数，同样只匹配前一个字符：<ul>
<li><code>?</code>等同于<code>{0,1}</code></li>
<li><code>*</code>等同于<code>{0,}</code></li>
<li><code>+</code>等同于<code>{1,}</code></li>
</ul>
</li>
<li>贪婪模式：匹配到下一个字符不满足匹配规则为止。<ul>
<li>所有的量词符后面加上<code>?</code>即可变为非贪婪模式。</li>
</ul>
</li>
<li>字符类：表示一系列字符中只要匹配一个就可以，所有可供选择的字符都放在方括号中。如<code>[abc]</code>：表示匹配a、b、c三个字母中的任意一个。<ul>
<li>脱字符（^）<ul>
<li><code>[^abc]</code>：表示除了abc外所有字符都可以匹配。</li>
<li><code>[^]</code>可以匹配所有字符，比<code>.</code>匹配更强。</li>
<li><code>^</code>字符只有在字符类的第一个位置才有意义，否则直接就是字面含义。</li>
</ul>
</li>
<li>连字符（-）<ul>
<li>对于连续序列的字符可用（-）来简写。</li>
<li><code>[a-z]</code>表示所有的小写字母。</li>
<li><code>-</code>字符若不在方括号之中则代表字面含义。</li>
<li>并且连字符必须在头尾两个字符之间才有特殊含义，否则只是字面含义。</li>
</ul>
</li>
</ul>
</li>
<li>转义符<ul>
<li>在正则表达式中有些特殊含义的字符，如果要匹配它们本身则需要在前面加上反斜杠。</li>
<li>正则表达式中需要斜杠转义的一共有以下12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\\</code>。</li>
<li>注意若是通过RegExp构造函数生成正则对象，转义时需要使用双斜杠<code>\\</code>，因为字符串内部会先转义一次。</li>
</ul>
</li>
<li>修饰符<ul>
<li><code>g</code>修饰符<ul>
<li>默认情况下，第一次匹配成功之后正则表达式就停止匹配，若有g修饰符则会匹配所有符合条件的结果，主要用于搜索和替换。</li>
</ul>
</li>
<li><code>i</code>修饰符<ul>
<li>表示忽略大小写。</li>
</ul>
</li>
<li><code>m</code>修饰符<ul>
<li>表示多行模式，会修改<code>^</code>、<code>$</code>的行为，这两个字符默认情况下是作为位置字符来匹配字符串的开始和结束位置。当加上m修饰符时会匹配行首和行尾，即会识别换行符（\n）。</li>
<li><code>/^bc/m.test(&quot;a\nbc&quot;)</code>返回true。</li>
</ul>
</li>
</ul>
</li>
<li>预定义模式：指常见模式的一些简写方式<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括制表符、空格符、断行符等），相等于<code>[\t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^\t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界，即该词单独存在。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
</li>
<li><p>特殊字符：正则表达式中表示一些不能打印的字符。</p>
<blockquote>
<p>\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。<br>  [\b] 匹配退格键(U+0008)，不要与\b混淆。<br>  \n 匹配换行键。<br>  \r 匹配回车键。<br>  \t 匹配制表符tab（U+0009）。<br>  \v 匹配垂直制表符（U+000B）。<br>  \f 匹配换页符（U+000C）。<br>  \0 匹配null字符（U+0000）。<br>  \xhh 匹配一个以两位十六进制数表示的字符。<br>  \uhhhh 匹配一个以四位十六进制数表示的unicode字符。</p>
</blockquote>
</li>
<li><p>组匹配</p>
<ul>
<li>正则表达式中通过括号表示分组匹配。</li>
<li>使用组匹配时不宜同时使用g修饰符，否则match方法不会捕获分组内容。如：<code>&quot;abcabc&quot;.match(/(.)b(.)/);//返回[&#39;abc&#39;, &#39;a&#39;, &#39;c&#39;]</code>而<code>&quot;abcabc&quot;.march(/(.)b(.)/g)返回[&#39;abc&#39;, &#39;abc&#39;]</code>。</li>
<li>组匹配中通过<code>\数字</code>可以引用括号匹配的内容。如：<code>/(.)b(.)\1\2/.test(&#39;abcabc&#39;) // \1表示第一个括号匹配结果即a， \2表示第二个括号匹配结果即c</code>。</li>
</ul>
</li>
<li>非捕获组<ul>
<li><code>(?:x)</code>表示不返回该组匹配的内容，为了不占用组匹配。</li>
<li>如：<code>&quot;abc&quot;.match(/(?:.)b(.)/)</code>返回[“abc”, “c”]。</li>
</ul>
</li>
<li>先行断言<ul>
<li><code>x(?=y)</code>表示x只有在y的前面才匹配，并且匹配结果中不会将y计入。</li>
<li>如：<code>&quot;abc&quot;.match(/b(?=c)/);</code>返回[“b”]。</li>
</ul>
</li>
<li>先行否定断言<ul>
<li>x只有不在y前面才会匹配。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[javascript学习笔记]]></title>
      <url>http://arlendp.me/web/js/js-study-notes/</url>
      <content type="html"><![CDATA[<p>本文是对《javascript权威指南》这本书中的知识点的总结。<br><a id="more"></a></p>
<h2 id="1-词法结构"><a href="#1-词法结构" class="headerlink" title="1. 词法结构"></a>1. 词法结构</h2><ul>
<li>js标识符必须以字母、下划线（<code>_</code>）或美元符（<code>$</code>）开始，后续字符可以是字母、数字、下划线或美元符。</li>
<li>当缺少分号时，js并不是在所有换行处填补分号，而是在缺少分号就无法正确解析代码的时候才会填补分号。但有两个例外：<ul>
<li>当<code>return</code>、<code>break</code>和<code>continue</code>语句后面紧接着换行时，js会在换行处添加分号。</li>
<li>当涉及到<code>++</code>和<code>--</code>符号时，若运算符作为后缀使用，应和表达式在同一行，若此时换行，js会在行尾填补分号，运算符会作为下一行代码的前缀运算符。</li>
</ul>
</li>
</ul>
<h2 id="2-类型、值和变量"><a href="#2-类型、值和变量" class="headerlink" title="2. 类型、值和变量"></a>2. 类型、值和变量</h2><ul>
<li>对象、数组属于可变类型，数字、字符串、布尔值、<code>null</code>和<code>undefined</code>属于不可变类型。</li>
<li>任意js的值都可以转换为布尔值。<code>undefined</code>、<code>null</code>、<code>0</code>、<code>-0</code>、<code>NaN</code>、<code>&quot;&quot;</code>会转化成<code>false</code>，其他值都会转换成<code>true</code>。</li>
<li><code>null</code>是一种特殊的对象。<code>undefined</code>属于<code>undefined</code>类型，变量没有初始化，当查询的对象或数组的属性或元素不存在，如果函数没有返回任何值，引用没有提供实参的函数形参的值都会返回<code>undefined</code>。<code>undefined</code>是预定义的全局变量，不是关键字。<code>==</code>会认为两者相等，<code>.</code>和<code>[]</code>对两者进行操作时都会产生类型错误。若想将他们赋值给变量、属性或作为参数传入函数建议使用<code>null</code>。</li>
<li>不在任何函数内的js代码可以使用关键字<code>this</code>来引用全局对象。</li>
<li>在读取字符串、数字和布尔值的属性值时，表现的像对象一样。但如果你给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未被保留下来。</li>
<li>对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，他们也是不相等的。</li>
<li><code>x + &quot;&quot;</code>等价于<code>String(x)</code>，<code>+x</code>等价于<code>Number(x)</code>，<code>!!x</code>等价于<code>Boolean(x)</code>。</li>
<li><code>+</code>、<code>==</code>、<code>!=</code>和关系运算符是唯一执行特殊字符串到原始值的转换方式的运算符。</li>
<li>使用<code>var</code>语句重复声明变量是合法无害的。若给未声明的变量赋值，js会给全局对象创建一个同名属性。</li>
<li>函数体内，局部变量的优先级高于同名的全局变量。</li>
<li>js使用了函数作用域，即在函数内声明的所有变量在函数体内始终是可见的。声明提前：js函数内声明的所有变量都（不包含赋值）被提前至函数体的顶部。</li>
<li>词法作用域：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。</li>
</ul>
<h2 id="3-表达式和运算符"><a href="#3-表达式和运算符" class="headerlink" title="3. 表达式和运算符"></a>3. 表达式和运算符</h2><ul>
<li>如果表达式后跟一对方括号，则会计算方括号内的表达式的值并将它转换为字符串。只有当属性名称是合法的标识符并且需要知道要访问的属性名时，才能使用<code>.</code>来访问属性。</li>
<li>如果函数使用<code>return</code>给出一个返回值时，这个返回值就是该表达式的值，否则表达式的值就是<code>undefined</code>。</li>
<li>如果对象创建表达式不需要传入任何参数给构造函数的话，那么空圆括号是可以省略的。</li>
<li>构造函数一般不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果该构造函数返回了一个对象值（只能是对象），那么该对象则作为整个表达式的值，而构造函数中新创建的对象就废弃了。</li>
<li><p>js中子表达式的计算过程中的运算顺序不同于运算符的优先级和结合性规定的运算顺序。js总是严格按照从左至右的顺序来计算表达式的。如计算式</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">var b = (a++) + a;</div></pre></td></tr></table></figure>
<ol>
<li>计算b</li>
<li>计算a++（结果记为c），之后a的值增1</li>
<li>计算a</li>
<li>计算c+a（此时a为2）</li>
<li>将结果赋值给b</li>
</ol>
</li>
<li><p>所有无法转换为数字的操作数都转化为<code>NaN</code>，若有操作数为<code>NaN</code>，此时计算结果也为<code>NaN</code>。</p>
</li>
<li>求余运算中余数的符号和被除数的符号保持一致。</li>
<li><p>当<code>+</code>与字符串和数字一起使用时，应考虑加法的结合性对运算的影响。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = 1 + 2 + &quot;hello&quot;;//&quot;3hello&quot;</div><div class="line">var b = 1 + (2 + &quot;hello&quot;);//&quot;12hello&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>位运算符的操作数为整数，且为32位整型，若不是则会强制转换。</p>
<ul>
<li>左移（&lt;&lt;）新的一位会用0来补充</li>
<li>右移（&gt;&gt;）新的一位由操作数的符号决定，正数补0，负数补1。</li>
<li>无符号右移（&gt;&gt;&gt;）新的一位总是补0.</li>
</ul>
</li>
<li>只有数字和字符串才能真正执行比较操作，除此之外的都将进行类型转换。如果一个操作数是（或转换之后是）<code>NaN</code>，则比较结果总为<code>false</code>。字符串比较中大写字母总是小于小写字母。</li>
<li>in运算符：如果右侧的对象有一个名为左侧操作数的属性名，那么表达式返回<code>true</code>。</li>
<li>instanceof运算符：左操作数是对象，右操作数是对象的类。若左操作数不是对象，则返回<code>false</code>，若右操作数不是函数，则抛出类型错误异常。</li>
<li><p><code>&amp;&amp;</code> 和 <code>||</code>的“短路”性质，可用于简写代码：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (a == b) &#123;</div><div class="line">    stop();</div><div class="line">&#125;</div><div class="line"></div><div class="line">(a == b) &amp;&amp; stop();</div></pre></td></tr></table></figure>
</li>
<li><p>带操作符的赋值运算中需要注意：表达式<code>a op= b</code>和<code>a = a op b</code>的不同点，当a中含有具有副作用的表达式时，两者是不同的。如：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"><span class="comment">//data[i++] *= 2;</span></div><div class="line"><span class="comment">//data[i++] = data[i++] * 2;</span></div><div class="line">两者计算结果不同，第一个data = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]，第二个data = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
</li>
<li><p><code>typeof</code>运算符返回表示操作数类型的字符串，可将数组和对象与函数区分开。</p>
</li>
<li><code>delete</code>运算符用来删除对象属性或数组元素，删除属性时该属性在对象中不再存在，删除数组元素时，其对应值变为<code>undefined</code>。但通过<code>var</code>声明的变量和定义的函数都不能被删除。</li>
<li><code>void</code>运算符：操作数会照常计算但是忽略计算结果并返回<code>undefined</code>。常用于url中。</li>
</ul>
<h2 id="4-语句"><a href="#4-语句" class="headerlink" title="4. 语句"></a>4. 语句</h2><ul>
<li>全局变量是全局对象的属性，然而和其他全局变量的属性不同的是，var声明的变量是无法通过delete删除的。</li>
<li>函数声明语句和函数定义表达式的不同点：<ul>
<li>函数定义语句中的函数名称和函数体均被显式的提前到脚本或函数的顶部，因此他们在整个脚本和函数内都是可见的。</li>
<li>使用var声明的函数表达式中只有变量声明被提前了，变量的初始化代码仍在原来的位置。</li>
</ul>
</li>
<li><code>default</code>标签可以放在<code>switch</code>语句的任何位置，并不会影响结果。</li>
<li><code>while(true)</code>和<code>for(;;)</code>都表示死循环。</li>
</ul>
<h2 id="5-对象"><a href="#5-对象" class="headerlink" title="5. 对象"></a>5. 对象</h2><ul>
<li>如果变量x是指向一个对象的引用，那么执行代码`var y = x;变量y也是指向同一个对象的引用，而非这个对象的副本。通过变量y修改这个对象同样会对变量x的值造成影响。</li>
<li>对象的属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。同时属性名也可以是标识符，但若属性名含有非法字符或是关键字则需要带上引号。</li>
<li>用<code>.</code>操作对象时，右侧必须是一个以属性名命名的标识符。用<code>[]</code>操作对象时，方括号内的表达式必须返回一个字符串或者可以转换为字符串的值。</li>
<li>若要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x，如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者找到一个原型是null的对象为止。</li>
<li>若给对象o的属性x赋值，如果o中已经有了属性x，那么这个赋值操作只改变这个已有属性x的值；如果o中不存在属性x，那么赋值操作给o添加了新属性x；如果之前o继承了属性x，那么这个继承的属性就被新创建的同名属性覆盖了。</li>
<li><code>delete</code>只是断开属性和宿主对象的联系，只能删除自有属性而不能删除继承属性，若一定要删除则只能从定义这个属性的原型对象上删除。（但这会影响到所有继承自这个原型的对象）</li>
<li><code>in</code>运算符可检测是否含有自有属性和继承属性，<code>hasOwnProperty</code>只能检测是否含有自由属性。</li>
<li>可通过<code>o.x !== undefined</code>判断是否含有某种属性，效果等同于in运算符。（但此种方法不能区分存在但值为undefined的属性）</li>
<li>for/in循环可以遍历对象中所有可枚举的自有属性和继承属性，但不能枚举继承的内置方法。</li>
<li><code>Object.keys()</code>返回可枚举的自有属性，<code>Object.getOwnPropertyNames()</code>返回所有自有属性。</li>
<li>存取器属性<code>getter</code>和<code>setter</code>。</li>
<li><code>Object.getOwnPropertyDescriptor(Object, attributeName)</code>获得某个对象特定自有属性的属性描述符。</li>
<li><code>Object.defineProperty(Object, attributeName, descriptorObject)</code>可以设置属性的特性。</li>
<li>通过对象直接量创建的对象使用<code>Object.prototype</code>作为它的原型，通过new创建的对象使用构造函数的prototype属性作为它的原型，通过<code>Object.create()</code>创建的对象使用第一个参数作为它的原型。</li>
<li><code>Object.getPrototypeOf()</code>可以查询对象的原型。</li>
<li><code>ObjectA.isPrototypeOf(ObjectB)</code>检测对象A是否是对象B的原型。</li>
<li>对象的可扩展性表示是否可以给对象添加新属性。<code>Object.isExtensible()</code>判断对象是否可扩展；<code>ObjectPreventExtensions()</code>将对象转换为不可扩展的，此时再无法将对象转换回可扩展的了，同时这样做只能影响到对象本身的可扩展性，若给一个不可扩展的对象的原型添加属性，则该对象同样会继承这个新属性。</li>
</ul>
<h2 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h2><ul>
<li>js数组可以是稀疏的，数组元素的索引不一定要连续，他们之间可以有空缺，对于每一个数组都有<code>length</code>属性，针对非稀疏数组，该属性就是数组元素的个数，而对于稀疏数组，该属性值比所有元素的索引都要大。</li>
<li>数组直接量的语法允许有可选的结尾的逗号，因此<code>var a = [, ,]</code>含有两个<code>undefined</code>值而非三个。</li>
<li>数组的索引是<strong>0~2^32-2</strong>之间的整数。</li>
<li>因为数组是对象，因此可以为其创建任意名字的属性，但是如果属性名是数组的索引，数组就会更新它的length属性值。</li>
<li>可以使用负数或者非整数作为数组的索引，此时数值将转换为字符串来作为属性名使用，此时只能作为属性名而非数组索引。同样，如果使用了非负整数的字符串作为数组索引，它就会直接作为数组索引而非对象的属性值。当使用浮点数作为索引时，若浮点数与一个整数相等则同样方式处理。</li>
<li>关于<code>length</code>属性：<ul>
<li>如果为一个数组元素赋值，它的索引 <strong>i</strong> 大于或等于现有数组的长度时，length的属性值将设置为 <strong>i+1</strong></li>
<li>若设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除。</li>
</ul>
</li>
</ul>
<h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h2><ul>
<li>函数的定义可以通过函数声明或者函数定义表达式。通过函数声明的方法定义的函数，其名称是必需的部分，函数声明实际上声明了一个变量并把一个函数赋值给它。通过函数定义表达式的方式定义的函数，其名称是可选的，如果它包含名称，函数的局部作用域将会包含一个绑定到该函数对象的名称，函数的名称将成为函数内部的一个局部变量，在比如函数需要递归的情况下是很有用的。</li>
<li>函数声明语句被提前到外部脚本或外部函数作用域的顶部，所以这种方式声明的函数可以被在它定义之前出现的代码所调用。要调用以表达式定义的函数则需要将函数赋值给一个变量，变量的声明会提前但是变量的赋值是不会提前的。</li>
<li>函数声明语句不能出现在循环、条件判断、或者try/catch/finally以及with语句中。函数定义表达式则不受限制。</li>
<li>普通的函数调用中（无论该函数声明是在脚本中还是函数内）的上下文<code>this</code>指的是全局对象（严格模式中是undefined），而方法调用中则指的是调用该方法的对象。</li>
<li>构造函数调用创建一个新的空对象，这个对象继承自构造函数的prototype属性，构造函数会试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数中的this指的是这个新创建的对象。</li>
<li>构造函数通常不使用<code>return</code>返回值，因为构造函数会显式返回初始化的新对象，如果使用了return返回一个对象，则调用构造函数返回的就是这个对象，若return返回的是其他值则会忽略该返回值。</li>
<li>在函数体内标识符<code>arguments</code>是指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标来访问传入函数的实参值。</li>
<li><code>arguments</code>和形参指的是同一个值，修改任意一个值都会影响到另一个。</li>
<li>函数不仅是一种语法也是值。</li>
<li>闭包的实现和理解，词法作用域。</li>
<li><p><code>call()</code>方法和<code>apply()</code>方法可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。对于call函数来说，第一个调用上下文参数之后的所有参数都是要传入的待调用函数的实参；而apply方法则将实参都放入一个数组当中。两种方法的第一个参数都是一个要调用该函数的对象，该函数中的<code>this</code>则指向这个对象。如：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = &#123;x: <span class="number">1</span>&#125;;</div><div class="line">add.call(a, <span class="number">2</span>)<span class="comment">//返回3</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>bind()</code>方法将函数绑定至某个对象，并返回一个新的函数。如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function f(y) &#123;</div><div class="line">    return this.x + y;</div><div class="line">&#125;</div><div class="line">var a = &#123;x: 1&#125;;</div><div class="line">var g = f.bind(a);</div><div class="line">g(2)//返回3</div><div class="line">上述过程相当于</div><div class="line">a = &#123;x: 1, f: function(y) &#123;return this.x + y&#125;&#125;;</div><div class="line">g = a.f;</div></pre></td></tr></table></figure>
</li>
<li><p>通过<code>Function()</code>构造的函数不使用词法作用域，它的作用域是全局作用域。</p>
</li>
<li>js在函数式编程中的使用。</li>
</ul>
<h2 id="8-类和模块"><a href="#8-类和模块" class="headerlink" title="8. 类和模块"></a>8. 类和模块</h2><ul>
<li>定义构造函数即是定义类，因此构造函数名的首字母要大写，而普通的函数和方法名首字母都是小写。</li>
<li>构造函数不必用<code>return</code>返回值，当通过<code>new</code>关键字来创建新对象时会自动返回该对象。其原型对象的名字为<code>ClassName.prototype</code>，这是一个强制命名，通过该构造函数创建的新对象会自动使用该原型对象作为新创建的对象的原型。</li>
<li><strong>原型对象是类的唯一标识</strong>，当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例，而初始化该对象的构造函数则不能作为类的标识，两个构造函数的prototype可能指向同一个原型对象，那么这两个构造函数创建的实例是属于同一个类的。</li>
<li><code>a instanceof A</code>并不会检查a是否是由A()构造函数初始化而来，而是检查a是否继承自A.prototype。</li>
<li>在希望用到字符串的地方用到对象的话，js会自动调用<code>toString</code>方法，如果没有实现这个方法，类会默认从<code>Object.prototype</code>中继承这个方法。</li>
<li>代码的模块化很重要，模块是一个独立的js文件，模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码。</li>
<li>所有模块都尽量定义不超过一个全局变量。</li>
<li>创建模块的过程中，避免污染全局变量的一种方法是使用一个对象作为命名空间。</li>
</ul>
<h2 id="9-正则表达式的模式匹配"><a href="#9-正则表达式的模式匹配" class="headerlink" title="9. 正则表达式的模式匹配"></a>9. 正则表达式的模式匹配</h2><p>正则表达式部分在我的另一篇博客中有介绍到：<a href="">javascri正则表达式</a></p>
<h2 id="10-web浏览器中的javascript"><a href="#10-web浏览器中的javascript" class="headerlink" title="10. web浏览器中的javascript"></a>10. web浏览器中的javascript</h2><ul>
<li><p>在html文档里嵌入客户端javascript代码有四种方法：</p>
<ul>
<li>内联方式，放置在<code>&lt;script&gt;&lt;/script&gt;</code>标签对之间。</li>
<li>放置在<code>&lt;script&gt;</code>标签的src属性指定的外部文件中。</li>
<li>放置在html事件处理程序中，如放入onclick的属性值中。</li>
<li>放在url中，该url使用特殊的”javascript:”协议。</li>
</ul>
</li>
<li><p>当使用<code>src</code>属性时，<code>&lt;script&gt;&lt;/script&gt;</code>之间的任何内容都会忽略。</p>
</li>
<li><code>script</code>标记中type属性默认值为”text/javascript”，如果没有指定，则使用默认值。若指定的类型是一个不可执行的类型，则不会从该url中下载任何东西。</li>
<li>可以通过<code>&lt;a href=&quot;javascript: void doSomethingHere;&quot;&gt;</code>来执行某些操作并且不会修改当前页面文档。</li>
<li>脚本和事件处理程序在同一时间只能执行一个，没有并发性。</li>
<li>javascript的时间线。</li>
</ul>
<h2 id="11-Window对象"><a href="#11-Window对象" class="headerlink" title="11. Window对象"></a>11. Window对象</h2><ul>
<li>它是客户端js的全局对象。</li>
<li><code>Location</code>对象的<code>assign()</code>和<code>replace()</code>方法都可以使窗口载入一个指定的url中的文档，后者在载入新文档之前会将当前文档从浏览历史中删除，此时后退操作无效。</li>
<li><code>Location</code>对象的<code>reload()</code>方法可以让浏览器重新载入当前文档。</li>
<li>直接将url赋值给<code>location</code>属性。</li>
<li>片段标识符不会使浏览器载入新的文档，它只会使它滚动到文档中的某个位置。<code>#id</code>会使浏览器跳到元素id对应的位置。<code>#top</code>如果没有元素id为top的话，则浏览器会跳到文档的开始处。</li>
<li><code>history</code>属性包含浏览器的浏览历史信息。</li>
<li><code>navigator</code>属性包含浏览器厂商和版本信息。</li>
<li><code>screen</code>属性包含窗口大小和可用颜色信息。</li>
<li>浏览器会为了防止广告的弹出而禁用<code>window.open()</code>方法，只有当用户手动点击按钮或者链接的时候才会调用。</li>
<li>如果正在事件处理程序中调用<code>close()</code>方法，则应指明是Window对象还是Document对象的close方法。</li>
<li>即使一个窗口已经关闭，但是代表它的Window对象仍然存在，它的document会使null，它的方法也不会工作。</li>
<li>Window对象的open()方法会返回新创建的窗口的Window对象，而该对象的opener属性则指向打开该窗口的原始窗口的Window对象。</li>
<li>窗体是用<code>&lt;iframe&gt;</code>元素创建的，窗体或窗口之间可以互相嵌套，可通过<code>parent</code>引用父窗口或窗体的window对象，<code>top</code>则可直接引用顶级窗口对象。若获取了iframe元素，可通过<code>contentWindow</code>属性获取该窗体的window对象，相反可通过window对象的<code>frameElement</code>得到对应的元素。另外，Window对象中还有frames属性可以得到自身包含的子窗口或窗体的引用，frames属性引用的是类数组对象，数组中的元素是Window对象而不是iframe元素，当访问子窗体时也可通过iframe元素的name或id属性来访问。</li>
</ul>
<h2 id="12-脚本化文档"><a href="#12-脚本化文档" class="headerlink" title="12. 脚本化文档"></a>12. 脚本化文档</h2><ul>
<li><code>Document</code>对象表示窗口的内容。</li>
<li>在html的树形结构中，树形的根部是<code>Document</code>节点，代表整个文档，代表html元素的是<code>Element</code>节点，代表文本的是<code>Text</code>节点。这三种节点都是Node的子类。</li>
<li>html的<code>name</code>属性最初是为了表单元素分配名字，在表单数据提交到服务器时使用该属性的值。name属性的值在html文档中不必唯一，并且该属性仅在表单、表单元素、iframe和img这些元素中有效。（<strong>对于IE浏览器，通过<code>getElementById()</code>和<code>getElementsByName()</code>均会返回包含对应id和name的元素，因此不应将同样的字符串用作id和name的值</strong>）</li>
<li><code>document.documentElement</code>指代文档的根元素，<code>document.head</code>和<code>document.body</code>分别指代head和body元素。</li>
<li><code>NodeList</code>和<code>HTMLCollection</code>都是类数组对象，因此不能直接使用Array的方法，但可以通过call和apply来间接调用。</li>
<li><code>querySelectorAll()</code>方法是通过css选择器的方式来匹配元素，但是其返回值并不是实时的，不会随着文档的变化而更新。<code>querySelector()</code>则是返回匹配的第一个元素。</li>
<li>html中的属性名不区分大小写，但是js中的属性名则大小写敏感。因此html中的属性名在js中全部转换为小写，如果属性名包含不只一个单词，则除第一个单词外其余单词的首字母均大写。另外，有些html属性名在js中是保留字，对于这些属性一般是在属性名前加<strong>html</strong>前缀，例如，<code>for</code>转换为<code>htmlFor</code>，但对于<code>class</code>属性则例外，它转换为<code>className</code>。</li>
<li>表示html属性的值通常是字符串，但当html属性为布尔值或数字时，js中的属性也是布尔值或者数字。</li>
<li>HTML5提供任意以<code>data-</code>为前缀的小写的属性名而在元素上绑定一些额外的信息。同时定义了Element对象的dataset属性，该对象的属性对应于上述含前缀的属性。</li>
<li><code>createElement()</code>和<code>createTextNode()</code>分别用于创建Element节点和Text节点。</li>
<li>如果通过<code>appendChild()</code>和<code>insertBefore()</code>方法将文档中已经存在的节点插入到文档中，那个节点将会从它当前的位置删除并在新的位置重新插入。</li>
<li><code>window.pageXOffset</code>、<code>window.pageYOffset</code>、<code>document.documentElement.scrollTop</code>、<code>document.documentElement.scrollLeft</code>都可以得到滚动条的位置信息。</li>
<li><code>window.innerWidth</code>、<code>window.innerHeight</code>、<code>document.documentElement.clientWidth</code>、<code>document.documentElement.clientHeight</code>都可以得到视口的尺寸信息。</li>
<li><code>getBoundingClientRect()</code>、<code>getClientRects()</code>可以得到一个元素的尺寸和位置。</li>
</ul>
<h2 id="13-脚本化css"><a href="#13-脚本化css" class="headerlink" title="13. 脚本化css"></a>13. 脚本化css</h2><ul>
<li>style属性中的样式覆盖了样式表中的样式，而且文档的样式表中的样式覆盖了浏览器的默认样式。</li>
<li>对于<code>absolute</code>和<code>fixed</code>定位，可以通过left和right或top和bottom来设置长和宽，若通过含有width或height，则相应的right和bottom将失效。</li>
<li><code>z-index</code>属性只对兄弟元素应用堆叠效果。</li>
<li><code>z-index</code>属性不适用于非定位元素，但对于非定位元素，它的值为0。</li>
<li>对于定位元素，left和top属性指定了从容器边框内侧到定位元素边框外侧的距离。</li>
<li>如果css属性名包含多个连字符，在js中应将连字符移除并将每个连字符后紧接着的字母大写。如果css属性名在js中属于保留字，则应在该属性名前加上”css”前缀，如”cssFloat”。</li>
<li>通过js操作元素的style属性时，所有的值都是字符串，并且对于定位属性，其单位也要写上。</li>
</ul>
<h2 id="14-事件处理"><a href="#14-事件处理" class="headerlink" title="14. 事件处理"></a>14. 事件处理</h2><ul>
<li><code>event</code>对象被当作参数传给事件处理函数，该对象的<code>type</code>属性确定了事件的类型，<code>target</code>属性确定了触发事件的对象。</li>
<li>当按下键盘按键重复产生字符时，在<code>keyup</code>事件之前会产生多个<code>keypress</code>事件，该事件对象指定的是产生的字符，而不是按键。</li>
<li><code>addEventListener()</code>能为同一个对象注册同一事件类型的多个处理程序函数，当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。</li>
<li>使用相同的参数在同一对象上多次调用<code>addEventListener()</code>是没用的，处理程序仍然只注册一次，同时重复调用也不会改变调用处理程序的顺序。</li>
<li>对于IE9之前不支持<code>addEventListener()</code>、<code>removeEventListener()</code>但支持类似的方法，<code>attachEvent()</code>和<code>detachEvent()</code>。两种方法类似但是存在以下几点不同：<ul>
<li>只有两个参数</li>
<li>第一个参数使用了带”on”前缀的事件处理程序名字字符串。</li>
<li>当给同一对象注册多个同一事件处理程序，事件发生时，会多次触发事件处理程序。</li>
<li>通过这种方式注册的事件处理程序中的this指的是全局对象，而其他方式指的是目标对象。</li>
</ul>
</li>
<li>事件的调用顺序：<ul>
<li>通过设置对象属性或html属性注册的处理程序优先调用。</li>
<li>通过<code>addEventListener()</code>注册的处理程序按照它们的注册顺序调用。</li>
<li>使用<code>attachEvent()</code>注册的处理程序可能按照任何顺序调用，代码不应依赖于调用顺序。</li>
</ul>
</li>
</ul>
<h2 id="15-脚本化http"><a href="#15-脚本化http" class="headerlink" title="15. 脚本化http"></a>15. 脚本化http</h2><ul>
<li>http请求的顺序是：先是请求方法和url，然后是请求头，最后是请求主体。</li>
</ul>
<h2 id="16-jquery类库"><a href="#16-jquery类库" class="headerlink" title="16. jquery类库"></a>16. jquery类库</h2><ul>
<li>this指的是原生文档参数，而不是jquery对象，若想使用jquery方法，则应该写成<code>$(this)</code>。</li>
<li>jquery中使用同一个方法既当setter又当getter使用，用作setter时，这些方法会给jquery对象中的每一个元素设置值，当作为getter使用时，这些方法只会查询jquery对象中的第一个元素并给它设置值。</li>
<li><code>css()</code>方法返回的是当前样式，即计算样式，该返回值既可能来自style属性也可能来自样式表。</li>
<li><code>css()</code>方法不能获取复合样式，但是可以设置复合样式的值，其中的样式名既可以用连字符也可以用驼峰格式。</li>
<li><code>css()</code>方法在获取样式值时，会把数值转换成带有单位后缀的字符串返回，在设置样式值时，则会将数值转换成字符串并在必要时添加”px”后缀。</li>
<li><code>offset()</code>方法返回元素的绝对位置，用相对于文档的坐标来表示。<code>position()</code>方法返回相对于元素的<code>offsetParent()</code>的偏移量。</li>
<li>获取元素的尺寸可以使用以下几种方法:<ul>
<li><code>width()</code>、<code>height()</code>返回内容的宽度和高度。</li>
<li><code>innerWidth()</code>、<code>innerHeight()</code>返回包含内边距的宽度和高度。</li>
<li><code>outerWidth()</code>、<code>outerHeight()</code>返回包含边框的宽度和高度</li>
<li>若对第三种方法传入参数<code>true</code>则返回的是包含元素外边距的宽度和高度。</li>
</ul>
</li>
<li>如果插入的元素已经是文档的一部分，这些元素只会简单的移动而不是复制到新位置。</li>
<li>jquery动画只支持数值属性。</li>
</ul>
<h2 id="17-客户端存储"><a href="#17-客户端存储" class="headerlink" title="17. 客户端存储"></a>17. 客户端存储</h2><ul>
<li>浏览器目前只支持存储字符串类型数据，若要存取其他类型的数据，需要手动进行编码和解码。</li>
</ul>
<h2 id="18-多媒体和图形编程"><a href="#18-多媒体和图形编程" class="headerlink" title="18. 多媒体和图形编程"></a>18. 多媒体和图形编程</h2><ul>
<li>通过<code>Image()</code>构造函数来创建一个图片对象，并将其<code>src</code>属性设置为相应的图片的url，这样由于图片元素并没有被添加到文档中，因此它是不可见的，但是浏览器会加载图片并将其缓存起来。当其他部分需要使用到该图片时便可直接从浏览器缓存中获取。</li>
<li>对于音频元素，可通过<code>new Audio(&quot;url&quot;)</code>来构造一个对象，但视频元素没有类似的构造函数。</li>
<li>在用<code>canvas</code>绘制图形时，当完成一条路径要绘制另一条路径前应使用<code>beginPath()</code>方法，如果没有使用该方法，那么添加的所有子路径都是处于当前路径上，使用<code>stroke()</code>和<code>fill()</code>方法时会作用在当前路径上的所有子路径。可能会导致重复绘制。</li>
<li>非零绕数原则：判断一个点是否在路径的内部。</li>
<li>每个<code>canvas</code>元素只有一个上下文对象，就算多次调用<code>getContext()</code>方法也会返回相同的上下文对象。</li>
<li>线段宽度是由<code>lineWidth</code>属性和当前坐标系变换决定的，与其他创建路径的方法无关。</li>
<li>文本对齐<code>textAlign</code>属性中，属性值<code>start</code>和<code>end</code>跟文本的方向有关，若文本是从左到右的则<code>start</code>和<code>left</code>是相同的，否则则相反。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git知识总结]]></title>
      <url>http://arlendp.me/git/git-knowledge/</url>
      <content type="html"><![CDATA[<p>git是平常软件开发中经常使用的版本控制系统，本文对git的原理、基础和配置方式进行了介绍，同时总结了平时使用过程中常见的git操作。<br><a id="more"></a></p>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><ol>
<li>集中式版本控制系统：有一个单一的集中管理的服务器，开发人员都可以连接到这台服务器，进行协同工作。</li>
</ol>
<ul>
<li>优点是系统容易管理和维护</li>
<li>缺点是如果中央服务器出现故障，工作将不能进行</li>
</ul>
<ol>
<li>分布式版本控制系统：不是只提取最新版本的文件快照，而是将整个代码仓库拷贝到本地，即使服务器故障也能通过本地仓库进行完整的恢复。</li>
</ol>
<h2 id="2-基础"><a href="#2-基础" class="headerlink" title="2. 基础"></a>2. 基础</h2><ul>
<li><p>git保存数据是保存整个文件系统的一个快照<img src="https://git-scm.com/book/en/v2/book/01-introduction/images/snapshots.png" alt="git-snapshot"></p>
</li>
<li><p>其他大部分系统保存的是文件的变更信息<img src="https://git-scm.com/book/en/v2/book/01-introduction/images/deltas.png" alt="delta"></p>
</li>
<li><p>git大部分操作都是在本地完成的，因此速度很快。即使没有网络，也可以提交文件，之后再上传</p>
</li>
<li><p>git通过SHA-1（哈希）计算校验和，由40个十六进制数组成的字符串。git数据库中保存的信息都是通过文件内容的hash值进行索引的而不是文件名。</p>
</li>
<li><p>git的三个工作区域</p>
<ul>
<li>git仓库：用来保存项目的数据以及数据库，当从其他地方clone项目时，拷贝的就是这里面的数据。</li>
<li>工作目录：存放的是项目某个版本的内容，存放于磁盘可供修改等操作，来源于git仓库中的压缩数据库。</li>
<li>暂存区域： 是一个文件，保存了将提交的文件信息。</li>
</ul>
</li>
<li><p>git工作流程</p>
<ul>
<li>在工作目录中修改文件(modified)</li>
<li>将修改的文件暂存在暂存区域(staged)</li>
<li>提交更新，将暂存区的文件存储到git仓库中(commited)</li>
</ul>
</li>
</ul>
<h2 id="3-git配置"><a href="#3-git配置" class="headerlink" title="3. git配置"></a>3. git配置</h2><p>git config</p>
<ul>
<li>–system：系统上所有用户及仓库的通用配置</li>
<li>–global：针对当前用户的配置</li>
<li>–config：针对当前仓库的配置</li>
</ul>
<p>上述配置具有优先级，由上往下递增，高优先级的覆盖低优先级的配置。</p>
<p>第一次使用时会配置个人信息<br><code>$ git config --global user.name yourname</code><br><code>$ git config --global user.email your@email.com</code><br>这些信息会写入每一次提交中，该配置只需配置一次。若想对某个项目使用特定的用户信息，通过git config来配置。<br>可通过git config –list查看所有配置信息，也可通过如git config user.name来查看用户名</p>
<h2 id="4-git基础操作"><a href="#4-git基础操作" class="headerlink" title="4. git基础操作"></a>4. git基础操作</h2><h3 id="4-1-创建git仓库"><a href="#4-1-创建git仓库" class="headerlink" title="4.1 创建git仓库"></a>4.1 创建git仓库</h3><ul>
<li>在已有项目中创建git仓库：通过<code>$ git init</code>命令创建一个.git子目录，里面存储了git仓库初始化时的必须文件，但不包括项目文件。</li>
<li>克隆仓库：通过<code>$ git clone theUrlYouWantToClone</code>，会克隆该仓库的所有版本的文件而不是最新版本的文件。执行该操作后会在当前目录下创建一个与该仓库同名的目录，并在该目录下初始化一个<code>.git</code>文件夹，将远程仓库中的数据拉取到该文件夹，并从中读取最新版本的项目文件，拷贝至其同级目录。<ul>
<li>可通过<code>$ git clone theUrlYouWantToClone myProjectName</code>修改仓库名称</li>
</ul>
</li>
</ul>
<p><strong><code>theUrlYouWantToClone</code></strong>可支持多种协议，git中常用到的是https、git和SSH协议。</p>
<h3 id="4-2-文件状态"><a href="#4-2-文件状态" class="headerlink" title="4.2 文件状态"></a>4.2 文件状态</h3><p>文件具有两种状态<strong>已跟踪</strong>和<strong>未跟踪</strong>。</p>
<ul>
<li>已跟踪的文件指的是已被纳入版本控制的文件，它们可能处于<em>未修改</em>、<em>已修改</em>、<em>已暂存</em>等状态。</li>
<li>将文件从git中移除、新建立一个文件等操作产生的文件都会处于未跟踪状态。<br>git版本控制下文件的生命周期<br><img src="https://git-scm.com/book/en/v2/book/02-git-basics/images/lifecycle.png" alt="life-cycle"></li>
</ul>
<h3 id="4-3-git-add命令"><a href="#4-3-git-add命令" class="headerlink" title="4.3 git add命令"></a>4.3 git add命令</h3><h4 id="4-3-1-跟踪新文件"><a href="#4-3-1-跟踪新文件" class="headerlink" title="4.3.1 跟踪新文件"></a>4.3.1 跟踪新文件</h4><p>通过<code>$ git add filename</code>、<code>$ git add pathname</code>可分别跟踪某个文件和某个路径下的所有文件，或者通过<code>$ git add .</code>来跟踪所有文件。</p>
<h4 id="4-3-2-暂存已修改文件"><a href="#4-3-2-暂存已修改文件" class="headerlink" title="4.3.2 暂存已修改文件"></a>4.3.2 暂存已修改文件</h4><p>与上述方法相同</p>
<p>因此，<code>git add</code>具有多种功能，可理解为<strong>向下次提交中添加内容</strong></p>
<h3 id="4-4-git-status命令"><a href="#4-4-git-status命令" class="headerlink" title="4.4 git status命令"></a>4.4 git status命令</h3><p>该命令用于查看文件状态<br>也可通过<code>$ git status -s</code>或者<code>$ git status --short</code>查看简写的文件状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git status -s</div><div class="line">M README</div><div class="line">MM Rakefile</div><div class="line">A  lib/git.rb</div><div class="line">M  lib/simplegit.rb</div><div class="line">?? LICENSE.txt</div></pre></td></tr></table></figure>
<p>各种记号的解释如下：</p>
<ul>
<li>??：未跟踪文件</li>
<li>A：新添加到暂存区的文件</li>
<li>_M：文件被修改但未添加到暂存区</li>
<li>M_：文件被修改且已添加到暂存区</li>
<li>MM：文件被修改且已添加到暂存区后又被修改</li>
</ul>
<h3 id="4-5-gitignore文件"><a href="#4-5-gitignore文件" class="headerlink" title="4.5 .gitignore文件"></a>4.5 .gitignore文件</h3><p>忽略文件的具体格式可见<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#忽略文件" target="_blank" rel="external">忽略文件</a></p>
<h3 id="4-6-git-diff命令"><a href="#4-6-git-diff命令" class="headerlink" title="4.6 git diff命令"></a>4.6 git diff命令</h3><p>git diff命令用于查看文件的修改，与git status相比可以具体显示修改的内容。</p>
<ul>
<li><code>$ git diff</code>显示的是已修改但未暂存的文件内容</li>
<li><code>$ git diff --cached</code>或<code>$ git diff --staged</code>查看已暂存但未提交的内容</li>
</ul>
<h3 id="4-7-git-commit命令"><a href="#4-7-git-commit命令" class="headerlink" title="4.7 git commit命令"></a>4.7 git commit命令</h3><p>通过git commit命令可将暂存区内的文件进行提交，而未暂存的文件则不会被提交。<br>可用<code>$ git commit</code>命令按提示完成提交或直接通过<code>$ git commit -m &quot;yourComments&quot;</code>进行提交说明并提交。<br>若想对所有已暂存和未暂存的文件进行提交可使用<code>$ git commit -a -m &quot;yourComments&quot;</code>进行提交，这样可简化操作步骤。</p>
<h3 id="4-8-移除文件"><a href="#4-8-移除文件" class="headerlink" title="4.8 移除文件"></a>4.8 移除文件</h3><p>移除文件需要git remove操作。</p>
<ul>
<li>通过<code>$ git rm fileName</code>即可将文件移出git版本控制并同时删除工作区中的文件，之后执行commit操作提交即可。</li>
<li>若是直接手动将文件删除，此时文件将会处于未暂存状态，通过git add或git rm操作便可进入已暂存状态，之后执行commit操作即可。</li>
<li>若文件进过修改并送入暂存区，需要用<code>$ git rm -f fileName</code>才能强制删除或通过上述第一种方式删除。</li>
<li>若是要将文件从git版本控制中删除但又不想从工作区中删除，则可通过<code>$ git rm --cached fileName</code>命令来实现。</li>
</ul>
<h3 id="4-9-移动文件"><a href="#4-9-移动文件" class="headerlink" title="4.9 移动文件"></a>4.9 移动文件</h3><p>移动文件操作通过<code>$ git mv fileFrom fileTo</code>来实现，该操作执行过程实际上是执行了删除fileFrom文件之后添加fileTo文件。</p>
<h3 id="4-10-撤销操作"><a href="#4-10-撤销操作" class="headerlink" title="4.10 撤销操作"></a>4.10 撤销操作</h3><ol>
<li><p>修改提交文件</p>
<ul>
<li>若提交后发现漏掉其他文件，可通过<code>$ git commit --amend</code>操作将当前暂存区的文件加入上次提交中，相当于只存在一次提交。</li>
<li>若是想修改提交文件的提交信息，可通过<code>$ git commit --amend -m &quot;newComments&quot;</code></li>
</ul>
</li>
<li><p>取消暂存文件</p>
<ul>
<li>通过<code>$ git reset HEAD fileName</code>可将文件从暂存区中移除，进入未暂存状态。</li>
</ul>
</li>
<li><p>取消已修改文件</p>
<ul>
<li>通过<code>$ git checkout -- fileName</code>将已修改的文件还原至上一次未修改时的状态。</li>
</ul>
</li>
</ol>
<h3 id="4-11-远程仓库"><a href="#4-11-远程仓库" class="headerlink" title="4.11 远程仓库"></a>4.11 远程仓库</h3><p>git项目的协作时会用到远程仓库，当克隆一个项目时，会有一个默认的名为<strong>origin</strong>的远程仓库。</p>
<ul>
<li>可通过<code>$ git remote</code>查看所有远程仓库或<code>$ git remote -v</code>查看所有远程仓库的具体信息。通过<code>$ git remote show remoteName</code>查看指定远程仓库的详细信息。</li>
<li>通过<code>$ git remote add shortNameForTheRemoteRepository RepositoryUrl</code></li>
<li>通过<code>$ git fetch shortName</code>可获取该远程仓库中的所有信息，但不会合并或修改当前工作区的文件</li>
<li>通过<code>$ git pull</code>命令获取远程仓库的数据并合并到当前分支，默认情况下，本地的master分支会跟踪远程仓库的master分支。</li>
<li>通过<code>$ git push remoteName branchName</code>将当前分支推送到指定远程仓库的指定分支上。</li>
<li>重命名远程仓库可使用<code>$ git remote rename originalName currentName</code></li>
<li>删除远程仓库可使用<code>$ git remote rm repositoryName</code></li>
</ul>
<h2 id="5-git分支"><a href="#5-git分支" class="headerlink" title="5. git分支"></a>5. git分支</h2><p>使用分支可以将开发工作从主线上进行分离，git的默认分支是<strong>master</strong>分支。git使用<strong>HEAD</strong>指针指向当前分支，可看做当前分支的一个别名。</p>
<h3 id="5-1-创建分支"><a href="#5-1-创建分支" class="headerlink" title="5.1 创建分支"></a>5.1 创建分支</h3><p>创建分支实际上就是创建了一个指向当前项目的指针，通过<code>$ git branch</code>命令可以查看当前分支，<code>$ git branch branchName</code>用于创建分支。</p>
<h3 id="5-2-切换分支"><a href="#5-2-切换分支" class="headerlink" title="5.2 切换分支"></a>5.2 切换分支</h3><p>命令<code>$ git checkout branchName</code>用于切换分支，切换分支后当前的工作区的文件也会随之改变。<br><strong>git分支是以提交的文件为基础的，一般情况下在修改文件后只有当提交了文件才能切换到另一个分支，但也有特殊情况，以branch1和branch2两个分支为例，若在branch1中添加了新文件，此时切换到branch2分支可以看到该文件，若此时提交则该文件属于branch2分支，再次切回branch1中不会保留该文件</strong></p>
<h3 id="5-3-删除分支"><a href="#5-3-删除分支" class="headerlink" title="5.3 删除分支"></a>5.3 删除分支</h3><p>通过<code>$ git branch -d branchName</code>可以删除该分支</p>
<h3 id="5-4-分支合并"><a href="#5-4-分支合并" class="headerlink" title="5.4 分支合并"></a>5.4 分支合并</h3><p>首先通过<code>$ git checkout branchName</code>切换到某一分支，如master分支，接下来执行<code>$ git merge branchName</code>将对应分支合并到master中。<br><strong>合并过程中如果两个分支对同一个文件进行了操作，则会产生冲突，需要手动解决，产生冲突的内容会在工作区中的相应文件中被标记出来，需要自己去判断保留哪一份修改，之后执行提交即可。</strong></p>
<h3 id="5-5-跟踪远程分支"><a href="#5-5-跟踪远程分支" class="headerlink" title="5.5 跟踪远程分支"></a>5.5 跟踪远程分支</h3><p>若想跟踪远程分支可以通过<code>$ git checkout --track remoteRepository/remoteBranch</code>，也可通过<code>$ git checkout -b branchName remoteRepository/remoteBranch</code>新建分支并跟踪远程分支，两者的不同点只是新建分支的名字不同。<br>若本地已有分支，则可通过<code>$ git branch -u remoteRepository/remoteBranch</code>添加或修改跟踪。<br>通过<code>$ git branch -vv</code>命令可以查看远程分支的跟踪信息。</p>
<h3 id="5-6-删除远程分支"><a href="#5-6-删除远程分支" class="headerlink" title="5.6 删除远程分支"></a>5.6 删除远程分支</h3><p>命令<code>$ git push remoteRepository --delete remoteBranch</code>可用于删除远程分支。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS实现元素的垂直居中]]></title>
      <url>http://arlendp.me/web/css/element-vertical-centering-by-css/</url>
      <content type="html"><![CDATA[<p>垂直居中指的是将元素在垂直方向上相对于父级元素达到一种居中的效果，在我们平时的布局中也会经常碰到垂直居中，在这里总结了下通过css实现垂直居中的各种常见方法，在使用各种方法时也要考虑到使用的场景。<br><a id="more"></a></p>
<p>以下css样式所应用到的html代码均如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;content&quot;&gt;</div><div class="line">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>要达到的效果是box相对于content实现垂直居中。</p>
<p>以下是各种实现方法总结：</p>
<h2 id="1-元素高度已知"><a href="#1-元素高度已知" class="headerlink" title="1. 元素高度已知"></a>1. 元素高度已知</h2><ol>
<li><p>已知尺寸的块可以通过绝对定位和margin进行垂直居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.content &#123;</div><div class="line">    display: relative;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">.content .box &#123;</div><div class="line">    display: absolute;</div><div class="line">    height: 100px;</div><div class="line">    top: 50%;</div><div class="line">    margin-top: -50px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 注意：通过这种方式元素被设置成了绝对定位，脱离了文档流，会对后面的元素位置产生影响。</p>
</li>
<li><p>通过在box前设置一个浮动的空块来实现垂直居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.floater &#123;</div><div class="line">    float: left;</div><div class="line">    height: 50%;</div><div class="line">    margin-bottom: -100px;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">.content .box &#123;</div><div class="line">    clear: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 注意：通过这种方式多用了一个空元素，同时因为使用了浮动元素所以应记得清除。</p>
</li>
</ol>
<h2 id="2-元素高度未知"><a href="#2-元素高度未知" class="headerlink" title="2. 元素高度未知"></a>2. 元素高度未知</h2><ol>
<li><p>通过table-cell元素的垂直居中属性实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.content &#123;</div><div class="line">     display: table;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> .content .box &#123;</div><div class="line">    display: table-cell;</div><div class="line">    vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 或直接通过table布局，table-cell的vertical-align:middle默认属性，但两者具有区别。</p>
</li>
<li><p>通过after或before伪类和vertical-align实现垂直居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.content .box &#123;</div><div class="line">    width: auto;</div><div class="line">    height: auto;</div><div class="line">    display: inline-block;</div><div class="line">    vertical-align: middle;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.content:after &#123;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    height: 100%;</div><div class="line">    width: 0;</div><div class="line">    display: inline-block;</div><div class="line">    vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 注意：定位元素需要设置为inline-block，同时都需要设置vertical-align:center属性。</p>
</li>
<li><p>通过margin:auto自动填充外边距实现垂直居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.content &#123;</div><div class="line">    position:relative;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">.content .box &#123;</div><div class="line">    position: absolute;</div><div class="line">    height: 200px;</div><div class="line">    top: 0;</div><div class="line">    bottom: 0;</div><div class="line">    margin-top: auto;</div><div class="line">    margin-bottom: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 注意：因为使用了绝对定位脱离了文档流，要考虑到对父元素和兄弟元素位置的影响。</p>
</li>
<li><p>通过transform属性的translateY()实现垂直居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.content &#123;</div><div class="line">    position: relative;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> .content .box &#123;</div><div class="line">    position: absolute;</div><div class="line">    top: 50%;</div><div class="line">    transform: translateY(-50%);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> 注意：使用了绝对定位，元素脱离文档流。同时使用时注意兼容性，不支持IE9以下的浏览器，对于部分版本浏览器需加上-ms-、-webkit-等前缀。</p>
</li>
<li><p>通过flexbox实现垂直居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.content &#123;</div><div class="line">    display: flex;</div><div class="line">    flex-direction: column;</div><div class="line">    justify-content: center;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> 注意：弹性盒改变了块模型，它可以自动调整子元素使得定位子元素更加容易。它有自己的一些属性，使用了另一种不同的布局逻辑，会使部分元素属性失效，如float和vertical-align。</p>
</li>
</ol>
<p><strong>小结：对于元素的垂直居中的情况判断一般是以该元素的高度是否已知，对于高度已知的情况，上述通过绝对定位和margin—top或通过增加一个浮动的空块均可解决，对于高度未知的情况，通过table布局、vartical-align属性、弹性盒、绝对定位与margin:auto的配合使用或是transfer属性都可实现垂直居中的布局。</strong></p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>http://arlendp.me/about/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[读书]]></title>
      <url>http://arlendp.me/reading/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
