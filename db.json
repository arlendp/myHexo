{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-raytaylorism/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/weixin_favicon.png","path":"weixin_favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/js/prettify.js","path":"js/prettify.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/images/side-user-cover.jpg","path":"css/images/side-user-cover.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/lib/font-awesome.min.css","path":"css/lib/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/lib/prettify-tomorrow-night-eighties.css","path":"css/lib/prettify-tomorrow-night-eighties.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/js/materialize.min.js","path":"js/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/lib/materialize.min.css","path":"css/lib/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Bold.eot","path":"css/font/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Bold.woff","path":"css/font/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Bold.woff2","path":"css/font/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Light.eot","path":"css/font/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Light.woff","path":"css/font/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Light.woff2","path":"css/font/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Medium.eot","path":"css/font/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Medium.woff","path":"css/font/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Medium.woff2","path":"css/font/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Regular.eot","path":"css/font/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Regular.woff","path":"css/font/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Regular.woff2","path":"css/font/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/FontAwesome.otf","path":"css/font/font-awesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.eot","path":"css/font/font-awesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.woff","path":"css/font/font-awesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.woff2","path":"css/font/font-awesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Bold.ttf","path":"css/font/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Light.ttf","path":"css/font/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Medium.ttf","path":"css/font/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Regular.ttf","path":"css/font/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.ttf","path":"css/font/font-awesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.svg","path":"css/font/font-awesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-raytaylorism/Gruntfile.js","hash":"f69b2e716f955c9d5a23ca1b75394098c1494858","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/.gitignore","hash":"cda50c55bb8864e0d96101140b62f880f690da5e","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/LICENSE","hash":"115cd028ae511ac9e3d30eb4933da38136a68513","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/README.md","hash":"a4b01ca87702c619b283994f4c8f0dfae65f199f","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/_config.yml","hash":"b10aa3e3aa6381cee2603fdd6d3f4421d14f4561","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/log.md","hash":"99d57a50f8f328d1a313b47bb636d0dc5656d813","modified":1471601595453},{"_id":"source/_data/about.json","hash":"d66a9dc9e7cfcb7ccca350657d21257a5b18f896","modified":1471601595406},{"_id":"source/_data/hint.json","hash":"bbcd2e75b304937160b40ad6cfe615911b711f39","modified":1471601595406},{"_id":"source/_data/link.json","hash":"34957efaf79d6dfc3a46236c21a0ae9c19d473a9","modified":1471601595406},{"_id":"source/_data/reading.json","hash":"35f5d500a44aef0da388fc587f81388625e76720","modified":1471601595406},{"_id":"source/_posts/element-vertical-centering-by-css.md","hash":"363740f8837782c0b0dd31e8619e8834784685ec","modified":1471601595406},{"_id":"source/_posts/git-knowledge.md","hash":"0be64399678bf112c9bc0d652c40b554915c24ad","modified":1471601595406},{"_id":"source/_posts/javascript-regex.md","hash":"06706e716bb90cde7f9d74fb631e816db65d0ff4","modified":1471601595406},{"_id":"source/_posts/js-study-notes.md","hash":"0fafa91194dbd89306d419678511d2bd9a272239","modified":1471601595422},{"_id":"source/about/index.md","hash":"48201ee80bf02b7442424cd853f6dc357d711a0b","modified":1471601595422},{"_id":"source/reading/index.md","hash":"ab4ae4fad36f371f60b49973797a115423a784d4","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/_data/about.json","hash":"ad37c7a373e24ba9fb26630b0e761cabb3431b90","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/_data/hint.json","hash":"178fe345ea95511364ed70da86186cb834947993","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/_data/link.json","hash":"b865125d0440e6717ee3d88d1b518a4ebdb32d61","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/_data/reading.json","hash":"e8045e22b2d499a5d813320a8c2b1bccdbedd46d","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/_data/slider.json","hash":"361373b57cfb5371027af42000bbaec4e03333a3","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/languages/default.yml","hash":"db4cca3224d973512449940f9b146be510cf299b","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/languages/zh-CN.yml","hash":"fb211a860b62cbe2c8eabffade72e56386666ef3","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/languages/zh-TW.yml","hash":"b3c05b36011e938204b89e48864b5c4e656816bc","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/layout/about.ejs","hash":"599b3bb334b3f88b918e67f7a709287b8effee6d","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/archive.ejs","hash":"0a21af8903e95c6d8bb7554b089ac219e8708ad7","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/index.ejs","hash":"50c1e7dab5a065fd10dd3a28fdffa5e3d342de82","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/layout.ejs","hash":"43beb54ac81519cf5e88a3a1494649beeb856066","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/page.ejs","hash":"90441f114859ce63ef7c7d93d668dbe5939995c2","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/post.ejs","hash":"8e550fd95ef761909294ed3a4aa428ff0509fbf0","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/reading.ejs","hash":"8fa965aa0f11f356c9f5344770cc9fc615577a74","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/tag.ejs","hash":"42ecab14917abd40c0a38e6ab629f089352a24b1","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/favicon.png","hash":"87b66add31d41a3267fd945bc9c2491d983ce529","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/weixin_favicon.png","hash":"4a8466bd7d8cf4753cab8fb68647b40b91a246ad","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/_md/about/index.md","hash":"cf37b9536668e276655568ad5b3ef20f78c1ad8f","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/_md/reading/index.md","hash":"ab4ae4fad36f371f60b49973797a115423a784d4","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/layout/_widget/blogroll.ejs","hash":"1a6808fa62906e7fb1fac3e16208fa6b1fc8d0ea","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_widget/category.ejs","hash":"95292eb643be63d98f08e28f759c9b01bbfcb9b8","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/_widget/tag.ejs","hash":"62c1e0e98229628e5338297d0157f770023e5135","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/_widget/recent_posts.ejs","hash":"935bfacce10a726eed6cd82fe39d2c6f9cce9e2a","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/_widget/tagcloud.ejs","hash":"f256f028c247bdcb7927351df89f2284c64b7b6c","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/after_footer.ejs","hash":"2b4ccf0350ccb9d10b88f275f9565968565f434d","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/archive.ejs","hash":"92b96a90ca81bb8ac57323cbf3847790abd1bdab","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/archive_title.ejs","hash":"a03a0aa0b8398f458f770202e353fbd61bd68311","modified":1471601595422},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/article.ejs","hash":"c0636d79e09a29ff871a8a9d80bd890eff376878","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/construction.ejs","hash":"21190b5a0d567ed4ea5d5289459690b72c1452f0","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/feature_guide.ejs","hash":"7aefb6bdc65d1e6113cb83190fcd2f29af2c9125","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/float.ejs","hash":"bba2781f42cd8ea0895749377e6f2cce69cadb6a","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/footer.ejs","hash":"c43c2c453bdd678f410d0de944c3415e3f60de37","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/head.ejs","hash":"7ceea72401426588cd7778f92585ab9487b463da","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/header.ejs","hash":"0616dd744262dd4cc98cd1cabe959643c845141f","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/menu_drawer.ejs","hash":"028ecbf59089cc4d1907a2d91d8da937f92d321c","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/pagenav.ejs","hash":"e7ada8faaee878ea4dde267d1b420bb45421670d","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/pagination.ejs","hash":"00de7746cf4ef8c4b67a72e825e5ff236f9d5814","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/search.ejs","hash":"0eca40de0d39c1ae52040fcb8c9d7f79afce35dc","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/side_nav.ejs","hash":"c69c45de069c348bf3906f1bd941920887a85c98","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/simple_article.ejs","hash":"a203ba5e571a5b8e70036cba184aca8b926f0456","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/slider.ejs","hash":"bb7b53f6ca9c852808d955fb074f88112e51ea59","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/source/css/style.styl","hash":"a05bcd2543b7bdcd3f725db6d053cd76ccf154be","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/js/prettify.js","hash":"d592e6f771c2955cea3764d819221b91bc343961","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/js/jquery.min.js","hash":"f694238d616f579a0690001f37984af430c19963","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/plugin/comment.ejs","hash":"ccb4bc1f63911a8884657de8a3fcbb537331fed8","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/plugin/analytics.ejs","hash":"b7dbd8342866929e683e9b013caa7324547ff704","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/plugin/google_code_prettify.ejs","hash":"336f01048440f0c9f7b75f24aafcc3a1ffefd9a0","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/plugin/main_javascript.ejs","hash":"645ad97a2380d5ff9ad4ce54cabe058fed344602","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/plugin/mathjax.ejs","hash":"6f6b85a5876ae150d3e5f08e384aff68652c0335","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/plugin/noscript.ejs","hash":"182650c8be93b093997ac4d5fe14af2f835b98d9","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/plugin/reward.ejs","hash":"284ab1d5cb4f43eb23b6d7a8aba2477b34abdc00","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/post/category.ejs","hash":"e17f452079201bd2a5a37bc76b51b132afd04faa","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/post/gallery.ejs","hash":"bd2285802766572736663e61852eb49f6acc744f","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/post/tablecontents.ejs","hash":"585ea42410648f193184931864a64b41635af956","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/post/tag.ejs","hash":"0f84c1aded9ba1887566d34e7f0d696c015295f0","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/post/time.ejs","hash":"79093d98f97aff91529364682ab5882ae0d40f6b","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/layout/_partial/post/title.ejs","hash":"cfaf9195506cc4b526c72b16e1484f85721ebc2d","modified":1471601595437},{"_id":"themes/hexo-theme-raytaylorism/source/css/_base/layout.styl","hash":"b2f718418de61946504a3f8bf28b75be165913a7","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_base/icons.css","hash":"ab167f1694ffe10c3c51d18a633efd41be121555","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_base/lib_customize.styl","hash":"2e9f3c668f79b0dd11b3babf828d376c6c91e0b2","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_base/variable.styl","hash":"ce4e056d1bbfb80734d98a6898950e7c0136edf4","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/about.styl","hash":"def183d6908ebcbd59341b09e9f7e06dc277b9ca","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/archive.styl","hash":"4d48566e9f72b8eac8875b6985885418f56fbafa","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/article.styl","hash":"293e38a8ab9aee346cc8e52421f1519c5a46a667","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/comment.styl","hash":"590f1386581181ab588be06e4189861f5a209467","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/footer.styl","hash":"345e2147c1cec1bf24ab7338a8c929d6716fd730","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/header.styl","hash":"ebfd0155cda8a0876c36595708f02c294a7c82a0","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/index.styl","hash":"ac83523dd14a1fc1fe55f98c84ed84cb03be864b","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/link_context.styl","hash":"5b23db4dee53cbbe9eef257f4a542823100fde72","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/other.styl","hash":"283d627c29a192d28f6f99b8b34e593855f98b93","modified":1471601595453},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/reading.styl","hash":"f81929fa12212465b02456d0bb3b8263355e3281","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/search.styl","hash":"f9ca6f5626c795ae73ff7412ff58207b62fd64ac","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/slider.styl","hash":"ad757e74b3500aa774636ebbe5bdcee7e52e5ad7","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/side_nav.styl","hash":"b239b6b55e87e86d038d6aa821beeb66a9cbaf39","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/syntax.styl","hash":"ed23b6d70c1af3c3a7192f344fddd09984198cb4","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/_partial/tablecontents.styl","hash":"7bbd7f34aae24b6af38fdd79ea3c85546d12eca4","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/images/side-user-cover.jpg","hash":"d8d73a64d6d5af83a27e6af1d4fedef808955ba0","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/css/lib/font-awesome.min.css","hash":"14be7d7ae1894d2cc7c1a8e847df4db42a310b2f","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/css/lib/prettify-tomorrow-night-eighties.css","hash":"e320b2be926124d30998af0e149b7f06303b8f8b","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/js/materialize.min.js","hash":"04fe8bbc9a3165eb7bfb13b7166306ed671268d8","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/css/lib/materialize.min.css","hash":"4d82b2b04b9c0ac07f1502667d40f38aee90c296","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1471601595486},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1471601595484},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1471601595489},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1471601595490},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1471601595506},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1471601595469},{"_id":"themes/hexo-theme-raytaylorism/source/css/font/font-awesome/fontawesome-webfont.svg","hash":"550ef5c1253c8376f2ead32b654eb58d3c106ca3","modified":1471601595469},{"_id":"public/about/index.html","hash":"57bc1722431aee7e6d136315cc1f83ffd8ba9027","modified":1471602934144},{"_id":"public/reading/index.html","hash":"99802becb7217a2f5864e57834af31b65d4fd6b5","modified":1471602934144},{"_id":"public/web/js/javascript-regex/index.html","hash":"7d23156017747457bccf89ab0ca0e2c9779ead11","modified":1471602934144},{"_id":"public/web/js/js-study-notes/index.html","hash":"3d7bb84d668c2448334873756be2660bae47ce38","modified":1471602934144},{"_id":"public/git/git-knowledge/index.html","hash":"94d5b4abf395ce45569862122f44347519d7b855","modified":1471602934144},{"_id":"public/web/css/element-vertical-centering-by-css/index.html","hash":"92be09a311936084c500203c606eb1d4e3173e59","modified":1471602934144},{"_id":"public/archives/index.html","hash":"ada1dbae421a077a80d99bc073c0b8711d49c95c","modified":1471602934144},{"_id":"public/archives/2015/index.html","hash":"6b2ba326c00243a090a67ed6bd466b4aad01bdca","modified":1471602934144},{"_id":"public/archives/2015/11/index.html","hash":"da102ad2186aef9fe1f7aa4d0b35912935a77551","modified":1471602934144},{"_id":"public/archives/2015/12/index.html","hash":"b01713e99b77cb3bbf49759059932a135f7385c2","modified":1471602934144},{"_id":"public/archives/2016/index.html","hash":"0eacf0141887bd59b10cc551fa6885ee107b48f1","modified":1471602934144},{"_id":"public/archives/2016/03/index.html","hash":"37d02490e96b55b630cd19e2f3691ab457bbfa36","modified":1471602934144},{"_id":"public/archives/2016/04/index.html","hash":"8885aafe28e38bdc5778255f40c68c2af6dd5ff1","modified":1471602934144},{"_id":"public/categories/Web开发/index.html","hash":"3db24d06ae9fb18393e078a3e0b3c582d5598557","modified":1471602934144},{"_id":"public/categories/Git/index.html","hash":"c5ea578054406a982294efbff0202b8784ce1da4","modified":1471602934144},{"_id":"public/categories/Web开发/JS/index.html","hash":"7a4157b6dd04a694d16bc69e20cf421262cb715d","modified":1471602934144},{"_id":"public/categories/Web开发/CSS/index.html","hash":"04da5ba4afb9302a79d18084291619babb33af9c","modified":1471602934144},{"_id":"public/index.html","hash":"7f547183de156ebfb3c167623b2e5e31cccc819c","modified":1471602934144},{"_id":"public/tags/Web开发/index.html","hash":"b9ecacf492f8ef25ed28807b7354e16530bb1258","modified":1471602934144},{"_id":"public/tags/CSS/index.html","hash":"b48c52547215ff85594fe478b0d7f8a2f7df89aa","modified":1471602934144},{"_id":"public/tags/Git/index.html","hash":"4dc1daee9949501af6be6d0e887fe9f4c1133431","modified":1471602934144},{"_id":"public/tags/JS/index.html","hash":"c8cb58dfc16c600afe3e3fc0ea46f4d35b08cef2","modified":1471602934144},{"_id":"public/favicon.png","hash":"87b66add31d41a3267fd945bc9c2491d983ce529","modified":1471602934160},{"_id":"public/weixin_favicon.png","hash":"4a8466bd7d8cf4753cab8fb68647b40b91a246ad","modified":1471602934160},{"_id":"public/css/images/side-user-cover.jpg","hash":"d8d73a64d6d5af83a27e6af1d4fedef808955ba0","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1471602934160},{"_id":"public/css/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1471602934160},{"_id":"public/css/font/font-awesome/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1471602935315},{"_id":"public/css/font/font-awesome/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1471602935315},{"_id":"public/css/font/font-awesome/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1471602935315},{"_id":"public/css/font/font-awesome/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1471602935315},{"_id":"public/css/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1471602935331},{"_id":"public/css/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1471602935331},{"_id":"public/css/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1471602935331},{"_id":"public/css/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1471602935331},{"_id":"public/js/prettify.js","hash":"d24b1da342b5c2d0582f0922118aaf0b2a6840d5","modified":1471602935331},{"_id":"public/css/lib/prettify-tomorrow-night-eighties.css","hash":"35e07bd7a4585363060edd558a0e9939e7e68323","modified":1471602935331},{"_id":"public/css/style.css","hash":"ce961052e19f54d5cc77995eb865870ddb3ef5c5","modified":1471602935331},{"_id":"public/js/jquery.min.js","hash":"69bb69e25ca7d5ef0935317584e6153f3fd9a88c","modified":1471602935331},{"_id":"public/css/lib/font-awesome.min.css","hash":"683d12731b7429d32ec7de00a6706602e403013f","modified":1471602935331},{"_id":"public/js/materialize.min.js","hash":"c9308fbe808a149aa11061af40a4be5f391cccee","modified":1471602935331},{"_id":"public/css/lib/materialize.min.css","hash":"41d1676b73eec020eaeb9b507dcbcd30069ae8cb","modified":1471602935331},{"_id":"public/css/font/font-awesome/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1471602935331},{"_id":"public/css/font/font-awesome/fontawesome-webfont.svg","hash":"550ef5c1253c8376f2ead32b654eb58d3c106ca3","modified":1471602935362}],"Category":[{"name":"Web开发","_id":"cis1me2dy0005no74cc86y5ar"},{"name":"Git","_id":"cis1me2ee0009no743fbnon77"},{"name":"JS","parent":"cis1me2dy0005no74cc86y5ar","_id":"cis1me2et000fno74zqa4un4e"},{"name":"CSS","parent":"cis1me2dy0005no74cc86y5ar","_id":"cis1me2et000jno742jsa10wk"}],"Data":[{"_id":"about","data":{"avatar":"http://ww2.sinaimg.cn/small/74990035jw1f1rjkd681bj20rs0rsdhg.jpg","name":"arlendp","tag":"Web前端","desc":"Web前端","skills":null,"projects":null,"reward":null}},{"_id":"hint","data":{"new":{"selector":[]}}},{"_id":"link","data":{"social":{"github":"https://github.com/arlendp","rss":"/atom.xml"},"extern":{}}},{"_id":"reading","data":{"define":{"readed":"已读","reading":"在读","wanted":"想读"},"contents":{"readed":[{"title":"JavaScript语言精粹","cover":"http://img3.douban.com/lpic/s11373174.jpg","review":"","score":"","doubanLink":"http://book.douban.com/subject/11874748/"}],"reading":[],"wanted":[]}}}],"Page":[{"title":"关于","layout":"about","_content":"\n","source":"about/index.md","raw":"title: 关于\nlayout: about\n---\n\n","date":"2016-08-19T10:13:15.422Z","updated":"2016-08-19T10:13:15.422Z","path":"about/index.html","comments":1,"_id":"cis1me2dj0001no747oahs24m","content":"","excerpt":"","more":""},{"title":"读书","layout":"reading","_content":"","source":"reading/index.md","raw":"title: 读书\nlayout: reading\n---\n","date":"2016-08-19T10:13:15.422Z","updated":"2016-08-19T10:13:15.422Z","path":"reading/index.html","comments":1,"_id":"cis1me2dj0003no742mmnmga4","content":"","excerpt":"","more":""}],"Post":[{"title":"CSS实现元素的垂直居中","date":"2015-11-21T16:00:00.000Z","folder":"web/css","en-title":"element-vertical-centering-by-css","_content":"\n垂直居中指的是将元素在垂直方向上相对于父级元素达到一种居中的效果，在我们平时的布局中也会经常碰到垂直居中，在这里总结了下通过css实现垂直居中的各种常见方法，在使用各种方法时也要考虑到使用的场景。\n<!-- more -->\n\n以下css样式所应用到的html代码均如下:\n```\n<div class=\"content\">\n    <div class=\"box\"></div>\n</div>\n```\n要达到的效果是box相对于content实现垂直居中。\n\n以下是各种实现方法总结：\n\n## 1. 元素高度已知\n\n1. 已知尺寸的块可以通过绝对定位和margin进行垂直居中\n```\n.content {\n    display: relative;\n }\n\n.content .box {\n    display: absolute;\n    height: 100px;\n    top: 50%;\n    margin-top: -50px;\n}\n```\n    注意：通过这种方式元素被设置成了绝对定位，脱离了文档流，会对后面的元素位置产生影响。\n\n2. 通过在box前设置一个浮动的空块来实现垂直居中\n```\n.floater {\n    float: left;\n    height: 50%;\n    margin-bottom: -100px;\n }\n\n.content .box {\n    clear: left;\n}\n```\n    注意：通过这种方式多用了一个空元素，同时因为使用了浮动元素所以应记得清除。\n\n## 2. 元素高度未知\n\n1. 通过table-cell元素的垂直居中属性实现\n```\n.content {\n     display: table;\n }\n\n .content .box {\n    display: table-cell;\n    vertical-align: middle;\n}\n```\n    或直接通过table布局，table-cell的vertical-align:middle默认属性，但两者具有区别。\n2. 通过after或before伪类和vertical-align实现垂直居中\n```\n.content .box {\n    width: auto;\n    height: auto;\n    display: inline-block;\n    vertical-align: middle;\n}\n\n.content:after {\n    content: \"\";\n    height: 100%;\n    width: 0;\n    display: inline-block;\n    vertical-align: middle;\n}\n```\n    注意：定位元素需要设置为inline-block，同时都需要设置vertical-align:center属性。\n3. 通过margin:auto自动填充外边距实现垂直居中\n```\n.content {\n    position:relative;\n }\n\n.content .box {\n    position: absolute;\n    height: 200px;\n    top: 0;\n    bottom: 0;\n    margin-top: auto;\n    margin-bottom: auto;\n}\n```\n    注意：因为使用了绝对定位脱离了文档流，要考虑到对父元素和兄弟元素位置的影响。\n4. 通过transform属性的translateY()实现垂直居中\n```\n.content {\n    position: relative;\n }\n\n .content .box {\n    position: absolute;\n    top: 50%;\n    transform: translateY(-50%);\n }\n```\n    注意：使用了绝对定位，元素脱离文档流。同时使用时注意兼容性，不支持IE9以下的浏览器，对于部分版本浏览器需加上-ms-、-webkit-等前缀。\n5. 通过flexbox实现垂直居中\n```\n.content {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n }\n```\n    注意：弹性盒改变了块模型，它可以自动调整子元素使得定位子元素更加容易。它有自己的一些属性，使用了另一种不同的布局逻辑，会使部分元素属性失效，如float和vertical-align。\n\n**小结：对于元素的垂直居中的情况判断一般是以该元素的高度是否已知，对于高度已知的情况，上述通过绝对定位和margin—top或通过增加一个浮动的空块均可解决，对于高度未知的情况，通过table布局、vartical-align属性、弹性盒、绝对定位与margin:auto的配合使用或是transfer属性都可实现垂直居中的布局。**\n\n","source":"_posts/element-vertical-centering-by-css.md","raw":"title: CSS实现元素的垂直居中\n\ncategories:\n- Web开发\n- CSS\ntags:\n- Web开发\n- CSS\n\ndate: 2015/11/22\nfolder: web/css\nen-title: element-vertical-centering-by-css\n---\n\n垂直居中指的是将元素在垂直方向上相对于父级元素达到一种居中的效果，在我们平时的布局中也会经常碰到垂直居中，在这里总结了下通过css实现垂直居中的各种常见方法，在使用各种方法时也要考虑到使用的场景。\n<!-- more -->\n\n以下css样式所应用到的html代码均如下:\n```\n<div class=\"content\">\n    <div class=\"box\"></div>\n</div>\n```\n要达到的效果是box相对于content实现垂直居中。\n\n以下是各种实现方法总结：\n\n## 1. 元素高度已知\n\n1. 已知尺寸的块可以通过绝对定位和margin进行垂直居中\n```\n.content {\n    display: relative;\n }\n\n.content .box {\n    display: absolute;\n    height: 100px;\n    top: 50%;\n    margin-top: -50px;\n}\n```\n    注意：通过这种方式元素被设置成了绝对定位，脱离了文档流，会对后面的元素位置产生影响。\n\n2. 通过在box前设置一个浮动的空块来实现垂直居中\n```\n.floater {\n    float: left;\n    height: 50%;\n    margin-bottom: -100px;\n }\n\n.content .box {\n    clear: left;\n}\n```\n    注意：通过这种方式多用了一个空元素，同时因为使用了浮动元素所以应记得清除。\n\n## 2. 元素高度未知\n\n1. 通过table-cell元素的垂直居中属性实现\n```\n.content {\n     display: table;\n }\n\n .content .box {\n    display: table-cell;\n    vertical-align: middle;\n}\n```\n    或直接通过table布局，table-cell的vertical-align:middle默认属性，但两者具有区别。\n2. 通过after或before伪类和vertical-align实现垂直居中\n```\n.content .box {\n    width: auto;\n    height: auto;\n    display: inline-block;\n    vertical-align: middle;\n}\n\n.content:after {\n    content: \"\";\n    height: 100%;\n    width: 0;\n    display: inline-block;\n    vertical-align: middle;\n}\n```\n    注意：定位元素需要设置为inline-block，同时都需要设置vertical-align:center属性。\n3. 通过margin:auto自动填充外边距实现垂直居中\n```\n.content {\n    position:relative;\n }\n\n.content .box {\n    position: absolute;\n    height: 200px;\n    top: 0;\n    bottom: 0;\n    margin-top: auto;\n    margin-bottom: auto;\n}\n```\n    注意：因为使用了绝对定位脱离了文档流，要考虑到对父元素和兄弟元素位置的影响。\n4. 通过transform属性的translateY()实现垂直居中\n```\n.content {\n    position: relative;\n }\n\n .content .box {\n    position: absolute;\n    top: 50%;\n    transform: translateY(-50%);\n }\n```\n    注意：使用了绝对定位，元素脱离文档流。同时使用时注意兼容性，不支持IE9以下的浏览器，对于部分版本浏览器需加上-ms-、-webkit-等前缀。\n5. 通过flexbox实现垂直居中\n```\n.content {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n }\n```\n    注意：弹性盒改变了块模型，它可以自动调整子元素使得定位子元素更加容易。它有自己的一些属性，使用了另一种不同的布局逻辑，会使部分元素属性失效，如float和vertical-align。\n\n**小结：对于元素的垂直居中的情况判断一般是以该元素的高度是否已知，对于高度已知的情况，上述通过绝对定位和margin—top或通过增加一个浮动的空块均可解决，对于高度未知的情况，通过table布局、vartical-align属性、弹性盒、绝对定位与margin:auto的配合使用或是transfer属性都可实现垂直居中的布局。**\n\n","slug":"element-vertical-centering-by-css","published":1,"updated":"2016-08-19T10:13:15.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis1me2d30000no740lj7hkfc","content":"<p>垂直居中指的是将元素在垂直方向上相对于父级元素达到一种居中的效果，在我们平时的布局中也会经常碰到垂直居中，在这里总结了下通过css实现垂直居中的各种常见方法，在使用各种方法时也要考虑到使用的场景。<br><a id=\"more\"></a></p>\n<p>以下css样式所应用到的html代码均如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;content&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>要达到的效果是box相对于content实现垂直居中。</p>\n<p>以下是各种实现方法总结：</p>\n<h2 id=\"1-元素高度已知\"><a href=\"#1-元素高度已知\" class=\"headerlink\" title=\"1. 元素高度已知\"></a>1. 元素高度已知</h2><ol>\n<li><p>已知尺寸的块可以通过绝对定位和margin进行垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">    display: relative;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">.content .box &#123;</div><div class=\"line\">    display: absolute;</div><div class=\"line\">    height: 100px;</div><div class=\"line\">    top: 50%;</div><div class=\"line\">    margin-top: -50px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 注意：通过这种方式元素被设置成了绝对定位，脱离了文档流，会对后面的元素位置产生影响。</p>\n</li>\n<li><p>通过在box前设置一个浮动的空块来实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.floater &#123;</div><div class=\"line\">    float: left;</div><div class=\"line\">    height: 50%;</div><div class=\"line\">    margin-bottom: -100px;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">.content .box &#123;</div><div class=\"line\">    clear: left;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 注意：通过这种方式多用了一个空元素，同时因为使用了浮动元素所以应记得清除。</p>\n</li>\n</ol>\n<h2 id=\"2-元素高度未知\"><a href=\"#2-元素高度未知\" class=\"headerlink\" title=\"2. 元素高度未知\"></a>2. 元素高度未知</h2><ol>\n<li><p>通过table-cell元素的垂直居中属性实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">     display: table;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> .content .box &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 或直接通过table布局，table-cell的vertical-align:middle默认属性，但两者具有区别。</p>\n</li>\n<li><p>通过after或before伪类和vertical-align实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content .box &#123;</div><div class=\"line\">    width: auto;</div><div class=\"line\">    height: auto;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.content:after &#123;</div><div class=\"line\">    content: &quot;&quot;;</div><div class=\"line\">    height: 100%;</div><div class=\"line\">    width: 0;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 注意：定位元素需要设置为inline-block，同时都需要设置vertical-align:center属性。</p>\n</li>\n<li><p>通过margin:auto自动填充外边距实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">    position:relative;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">.content .box &#123;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">    top: 0;</div><div class=\"line\">    bottom: 0;</div><div class=\"line\">    margin-top: auto;</div><div class=\"line\">    margin-bottom: auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 注意：因为使用了绝对定位脱离了文档流，要考虑到对父元素和兄弟元素位置的影响。</p>\n</li>\n<li><p>通过transform属性的translateY()实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> .content .box &#123;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    top: 50%;</div><div class=\"line\">    transform: translateY(-50%);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p> 注意：使用了绝对定位，元素脱离文档流。同时使用时注意兼容性，不支持IE9以下的浏览器，对于部分版本浏览器需加上-ms-、-webkit-等前缀。</p>\n</li>\n<li><p>通过flexbox实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">    display: flex;</div><div class=\"line\">    flex-direction: column;</div><div class=\"line\">    justify-content: center;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p> 注意：弹性盒改变了块模型，它可以自动调整子元素使得定位子元素更加容易。它有自己的一些属性，使用了另一种不同的布局逻辑，会使部分元素属性失效，如float和vertical-align。</p>\n</li>\n</ol>\n<p><strong>小结：对于元素的垂直居中的情况判断一般是以该元素的高度是否已知，对于高度已知的情况，上述通过绝对定位和margin—top或通过增加一个浮动的空块均可解决，对于高度未知的情况，通过table布局、vartical-align属性、弹性盒、绝对定位与margin:auto的配合使用或是transfer属性都可实现垂直居中的布局。</strong></p>\n","excerpt":"<p>垂直居中指的是将元素在垂直方向上相对于父级元素达到一种居中的效果，在我们平时的布局中也会经常碰到垂直居中，在这里总结了下通过css实现垂直居中的各种常见方法，在使用各种方法时也要考虑到使用的场景。<br>","more":"</p>\n<p>以下css样式所应用到的html代码均如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;content&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>要达到的效果是box相对于content实现垂直居中。</p>\n<p>以下是各种实现方法总结：</p>\n<h2 id=\"1-元素高度已知\"><a href=\"#1-元素高度已知\" class=\"headerlink\" title=\"1. 元素高度已知\"></a>1. 元素高度已知</h2><ol>\n<li><p>已知尺寸的块可以通过绝对定位和margin进行垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">    display: relative;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">.content .box &#123;</div><div class=\"line\">    display: absolute;</div><div class=\"line\">    height: 100px;</div><div class=\"line\">    top: 50%;</div><div class=\"line\">    margin-top: -50px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 注意：通过这种方式元素被设置成了绝对定位，脱离了文档流，会对后面的元素位置产生影响。</p>\n</li>\n<li><p>通过在box前设置一个浮动的空块来实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.floater &#123;</div><div class=\"line\">    float: left;</div><div class=\"line\">    height: 50%;</div><div class=\"line\">    margin-bottom: -100px;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">.content .box &#123;</div><div class=\"line\">    clear: left;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 注意：通过这种方式多用了一个空元素，同时因为使用了浮动元素所以应记得清除。</p>\n</li>\n</ol>\n<h2 id=\"2-元素高度未知\"><a href=\"#2-元素高度未知\" class=\"headerlink\" title=\"2. 元素高度未知\"></a>2. 元素高度未知</h2><ol>\n<li><p>通过table-cell元素的垂直居中属性实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">     display: table;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> .content .box &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 或直接通过table布局，table-cell的vertical-align:middle默认属性，但两者具有区别。</p>\n</li>\n<li><p>通过after或before伪类和vertical-align实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content .box &#123;</div><div class=\"line\">    width: auto;</div><div class=\"line\">    height: auto;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.content:after &#123;</div><div class=\"line\">    content: &quot;&quot;;</div><div class=\"line\">    height: 100%;</div><div class=\"line\">    width: 0;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 注意：定位元素需要设置为inline-block，同时都需要设置vertical-align:center属性。</p>\n</li>\n<li><p>通过margin:auto自动填充外边距实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">    position:relative;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">.content .box &#123;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">    top: 0;</div><div class=\"line\">    bottom: 0;</div><div class=\"line\">    margin-top: auto;</div><div class=\"line\">    margin-bottom: auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 注意：因为使用了绝对定位脱离了文档流，要考虑到对父元素和兄弟元素位置的影响。</p>\n</li>\n<li><p>通过transform属性的translateY()实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> .content .box &#123;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    top: 50%;</div><div class=\"line\">    transform: translateY(-50%);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p> 注意：使用了绝对定位，元素脱离文档流。同时使用时注意兼容性，不支持IE9以下的浏览器，对于部分版本浏览器需加上-ms-、-webkit-等前缀。</p>\n</li>\n<li><p>通过flexbox实现垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">    display: flex;</div><div class=\"line\">    flex-direction: column;</div><div class=\"line\">    justify-content: center;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p> 注意：弹性盒改变了块模型，它可以自动调整子元素使得定位子元素更加容易。它有自己的一些属性，使用了另一种不同的布局逻辑，会使部分元素属性失效，如float和vertical-align。</p>\n</li>\n</ol>\n<p><strong>小结：对于元素的垂直居中的情况判断一般是以该元素的高度是否已知，对于高度已知的情况，上述通过绝对定位和margin—top或通过增加一个浮动的空块均可解决，对于高度未知的情况，通过table布局、vartical-align属性、弹性盒、绝对定位与margin:auto的配合使用或是transfer属性都可实现垂直居中的布局。</strong></p>"},{"title":"Git知识总结","date":"2015-12-25T16:00:00.000Z","folder":"git","en-title":"git-knowledge","_content":"git是平常软件开发中经常使用的版本控制系统，本文对git的原理、基础和配置方式进行了介绍，同时总结了平时使用过程中常见的git操作。\n<!-- more -->\n\n## 1. 概念\n1. 集中式版本控制系统：有一个单一的集中管理的服务器，开发人员都可以连接到这台服务器，进行协同工作。\n* 优点是系统容易管理和维护\n* 缺点是如果中央服务器出现故障，工作将不能进行\n2. 分布式版本控制系统：不是只提取最新版本的文件快照，而是将整个代码仓库拷贝到本地，即使服务器故障也能通过本地仓库进行完整的恢复。\n\n## 2. 基础\n* git保存数据是保存整个文件系统的一个快照![git-snapshot](https://git-scm.com/book/en/v2/book/01-introduction/images/snapshots.png)\n\n* 其他大部分系统保存的是文件的变更信息![delta](https://git-scm.com/book/en/v2/book/01-introduction/images/deltas.png)\n\n* git大部分操作都是在本地完成的，因此速度很快。即使没有网络，也可以提交文件，之后再上传\n\n* git通过SHA-1（哈希）计算校验和，由40个十六进制数组成的字符串。git数据库中保存的信息都是通过文件内容的hash值进行索引的而不是文件名。\n\n* git的三个工作区域\n * git仓库：用来保存项目的数据以及数据库，当从其他地方clone项目时，拷贝的就是这里面的数据。\n * 工作目录：存放的是项目某个版本的内容，存放于磁盘可供修改等操作，来源于git仓库中的压缩数据库。\n * 暂存区域： 是一个文件，保存了将提交的文件信息。\n\n* git工作流程\n * 在工作目录中修改文件(modified)\n * 将修改的文件暂存在暂存区域(staged)\n * 提交更新，将暂存区的文件存储到git仓库中(commited)\n\n## 3. git配置\ngit config\n\n* --system：系统上所有用户及仓库的通用配置\n* --global：针对当前用户的配置\n* --config：针对当前仓库的配置\n\n上述配置具有优先级，由上往下递增，高优先级的覆盖低优先级的配置。\n\n第一次使用时会配置个人信息\n`$ git config --global user.name yourname`\n`$ git config --global user.email your@email.com`\n这些信息会写入每一次提交中，该配置只需配置一次。若想对某个项目使用特定的用户信息，通过git config来配置。\n可通过git config --list查看所有配置信息，也可通过如git config user.name来查看用户名\n\n## 4. git基础操作\n\n### 4.1 创建git仓库\n* 在已有项目中创建git仓库：通过`$ git init`命令创建一个.git子目录，里面存储了git仓库初始化时的必须文件，但不包括项目文件。\n* 克隆仓库：通过`$ git clone theUrlYouWantToClone`，会克隆该仓库的所有版本的文件而不是最新版本的文件。执行该操作后会在当前目录下创建一个与该仓库同名的目录，并在该目录下初始化一个`.git`文件夹，将远程仓库中的数据拉取到该文件夹，并从中读取最新版本的项目文件，拷贝至其同级目录。\n * 可通过`$ git clone theUrlYouWantToClone myProjectName`修改仓库名称\n\n**`theUrlYouWantToClone`**可支持多种协议，git中常用到的是https、git和SSH协议。\n\n### 4.2 文件状态\n文件具有两种状态**已跟踪**和**未跟踪**。\n\n* 已跟踪的文件指的是已被纳入版本控制的文件，它们可能处于*未修改*、*已修改*、*已暂存*等状态。\n* 将文件从git中移除、新建立一个文件等操作产生的文件都会处于未跟踪状态。\ngit版本控制下文件的生命周期\n![life-cycle](https://git-scm.com/book/en/v2/book/02-git-basics/images/lifecycle.png)\n\n### 4.3 git add命令\n####  4.3.1 跟踪新文件\n通过`$ git add filename`、`$ git add pathname`可分别跟踪某个文件和某个路径下的所有文件，或者通过`$ git add .`来跟踪所有文件。\n#### 4.3.2 暂存已修改文件\n与上述方法相同\n\n因此，`git add`具有多种功能，可理解为**向下次提交中添加内容**\n\n### 4.4 git status命令\n该命令用于查看文件状态\n也可通过`$ git status -s`或者`$ git status --short`查看简写的文件状态。\n\n```\n$ git status -s\nM README\nMM Rakefile\nA  lib/git.rb\nM  lib/simplegit.rb\n?? LICENSE.txt\n```\n各种记号的解释如下：\n\n* ??：未跟踪文件\n* A：新添加到暂存区的文件\n* _M：文件被修改但未添加到暂存区\n* M_：文件被修改且已添加到暂存区\n* MM：文件被修改且已添加到暂存区后又被修改\n\n### 4.5 .gitignore文件\n忽略文件的具体格式可见[忽略文件](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#忽略文件)\n\n### 4.6 git diff命令\ngit diff命令用于查看文件的修改，与git status相比可以具体显示修改的内容。\n\n* `$ git diff`显示的是已修改但未暂存的文件内容\n* `$ git diff --cached`或`$ git diff --staged`查看已暂存但未提交的内容\n\n### 4.7 git commit命令\n通过git commit命令可将暂存区内的文件进行提交，而未暂存的文件则不会被提交。\n可用`$ git commit`命令按提示完成提交或直接通过`$ git commit -m \"yourComments\"`进行提交说明并提交。\n若想对所有已暂存和未暂存的文件进行提交可使用`$ git commit -a -m \"yourComments\"`进行提交，这样可简化操作步骤。\n\n### 4.8 移除文件\n移除文件需要git remove操作。\n\n* 通过`$ git rm fileName`即可将文件移出git版本控制并同时删除工作区中的文件，之后执行commit操作提交即可。\n* 若是直接手动将文件删除，此时文件将会处于未暂存状态，通过git add或git rm操作便可进入已暂存状态，之后执行commit操作即可。\n* 若文件进过修改并送入暂存区，需要用`$ git rm -f fileName`才能强制删除或通过上述第一种方式删除。\n* 若是要将文件从git版本控制中删除但又不想从工作区中删除，则可通过`$ git rm --cached fileName`命令来实现。\n\n### 4.9 移动文件\n移动文件操作通过`$ git mv fileFrom fileTo`来实现，该操作执行过程实际上是执行了删除fileFrom文件之后添加fileTo文件。\n\n### 4.10 撤销操作\n1. 修改提交文件\n * 若提交后发现漏掉其他文件，可通过`$ git commit --amend`操作将当前暂存区的文件加入上次提交中，相当于只存在一次提交。\n * 若是想修改提交文件的提交信息，可通过`$ git commit --amend -m \"newComments\"`\n\n2. 取消暂存文件\n * 通过`$ git reset HEAD fileName`可将文件从暂存区中移除，进入未暂存状态。\n\n3. 取消已修改文件\n * 通过`$ git checkout -- fileName`将已修改的文件还原至上一次未修改时的状态。\n\n### 4.11 远程仓库\ngit项目的协作时会用到远程仓库，当克隆一个项目时，会有一个默认的名为**origin**的远程仓库。\n\n* 可通过`$ git remote`查看所有远程仓库或`$ git remote -v`查看所有远程仓库的具体信息。通过`$ git remote show remoteName`查看指定远程仓库的详细信息。\n* 通过`$ git remote add shortNameForTheRemoteRepository RepositoryUrl`\n* 通过`$ git fetch shortName`可获取该远程仓库中的所有信息，但不会合并或修改当前工作区的文件\n* 通过`$ git pull`命令获取远程仓库的数据并合并到当前分支，默认情况下，本地的master分支会跟踪远程仓库的master分支。\n* 通过`$ git push remoteName branchName`将当前分支推送到指定远程仓库的指定分支上。\n* 重命名远程仓库可使用`$ git remote rename originalName currentName`\n* 删除远程仓库可使用`$ git remote rm repositoryName`\n\n## 5. git分支\n使用分支可以将开发工作从主线上进行分离，git的默认分支是**master**分支。git使用**HEAD**指针指向当前分支，可看做当前分支的一个别名。\n### 5.1 创建分支\n创建分支实际上就是创建了一个指向当前项目的指针，通过`$ git branch`命令可以查看当前分支，`$ git branch branchName`用于创建分支。\n\n### 5.2 切换分支\n命令`$ git checkout branchName`用于切换分支，切换分支后当前的工作区的文件也会随之改变。\n**git分支是以提交的文件为基础的，一般情况下在修改文件后只有当提交了文件才能切换到另一个分支，但也有特殊情况，以branch1和branch2两个分支为例，若在branch1中添加了新文件，此时切换到branch2分支可以看到该文件，若此时提交则该文件属于branch2分支，再次切回branch1中不会保留该文件**\n\n### 5.3 删除分支\n通过`$ git branch -d branchName`可以删除该分支\n\n### 5.4 分支合并\n首先通过`$ git checkout branchName`切换到某一分支，如master分支，接下来执行`$ git merge branchName`将对应分支合并到master中。\n**合并过程中如果两个分支对同一个文件进行了操作，则会产生冲突，需要手动解决，产生冲突的内容会在工作区中的相应文件中被标记出来，需要自己去判断保留哪一份修改，之后执行提交即可。**\n\n### 5.5 跟踪远程分支\n若想跟踪远程分支可以通过`$ git checkout --track remoteRepository/remoteBranch`，也可通过`$ git checkout -b branchName remoteRepository/remoteBranch`新建分支并跟踪远程分支，两者的不同点只是新建分支的名字不同。\n若本地已有分支，则可通过`$ git branch -u remoteRepository/remoteBranch`添加或修改跟踪。\n通过`$ git branch -vv`命令可以查看远程分支的跟踪信息。\n\n### 5.6 删除远程分支\n命令`$ git push remoteRepository --delete remoteBranch`可用于删除远程分支。\n\n\n\n\n\n","source":"_posts/git-knowledge.md","raw":"title: Git知识总结\n\ncategories:\n- Git\ntags:\n- Git\n\ndate: 2015/12/26\nfolder: git\nen-title: git-knowledge\n---\ngit是平常软件开发中经常使用的版本控制系统，本文对git的原理、基础和配置方式进行了介绍，同时总结了平时使用过程中常见的git操作。\n<!-- more -->\n\n## 1. 概念\n1. 集中式版本控制系统：有一个单一的集中管理的服务器，开发人员都可以连接到这台服务器，进行协同工作。\n* 优点是系统容易管理和维护\n* 缺点是如果中央服务器出现故障，工作将不能进行\n2. 分布式版本控制系统：不是只提取最新版本的文件快照，而是将整个代码仓库拷贝到本地，即使服务器故障也能通过本地仓库进行完整的恢复。\n\n## 2. 基础\n* git保存数据是保存整个文件系统的一个快照![git-snapshot](https://git-scm.com/book/en/v2/book/01-introduction/images/snapshots.png)\n\n* 其他大部分系统保存的是文件的变更信息![delta](https://git-scm.com/book/en/v2/book/01-introduction/images/deltas.png)\n\n* git大部分操作都是在本地完成的，因此速度很快。即使没有网络，也可以提交文件，之后再上传\n\n* git通过SHA-1（哈希）计算校验和，由40个十六进制数组成的字符串。git数据库中保存的信息都是通过文件内容的hash值进行索引的而不是文件名。\n\n* git的三个工作区域\n * git仓库：用来保存项目的数据以及数据库，当从其他地方clone项目时，拷贝的就是这里面的数据。\n * 工作目录：存放的是项目某个版本的内容，存放于磁盘可供修改等操作，来源于git仓库中的压缩数据库。\n * 暂存区域： 是一个文件，保存了将提交的文件信息。\n\n* git工作流程\n * 在工作目录中修改文件(modified)\n * 将修改的文件暂存在暂存区域(staged)\n * 提交更新，将暂存区的文件存储到git仓库中(commited)\n\n## 3. git配置\ngit config\n\n* --system：系统上所有用户及仓库的通用配置\n* --global：针对当前用户的配置\n* --config：针对当前仓库的配置\n\n上述配置具有优先级，由上往下递增，高优先级的覆盖低优先级的配置。\n\n第一次使用时会配置个人信息\n`$ git config --global user.name yourname`\n`$ git config --global user.email your@email.com`\n这些信息会写入每一次提交中，该配置只需配置一次。若想对某个项目使用特定的用户信息，通过git config来配置。\n可通过git config --list查看所有配置信息，也可通过如git config user.name来查看用户名\n\n## 4. git基础操作\n\n### 4.1 创建git仓库\n* 在已有项目中创建git仓库：通过`$ git init`命令创建一个.git子目录，里面存储了git仓库初始化时的必须文件，但不包括项目文件。\n* 克隆仓库：通过`$ git clone theUrlYouWantToClone`，会克隆该仓库的所有版本的文件而不是最新版本的文件。执行该操作后会在当前目录下创建一个与该仓库同名的目录，并在该目录下初始化一个`.git`文件夹，将远程仓库中的数据拉取到该文件夹，并从中读取最新版本的项目文件，拷贝至其同级目录。\n * 可通过`$ git clone theUrlYouWantToClone myProjectName`修改仓库名称\n\n**`theUrlYouWantToClone`**可支持多种协议，git中常用到的是https、git和SSH协议。\n\n### 4.2 文件状态\n文件具有两种状态**已跟踪**和**未跟踪**。\n\n* 已跟踪的文件指的是已被纳入版本控制的文件，它们可能处于*未修改*、*已修改*、*已暂存*等状态。\n* 将文件从git中移除、新建立一个文件等操作产生的文件都会处于未跟踪状态。\ngit版本控制下文件的生命周期\n![life-cycle](https://git-scm.com/book/en/v2/book/02-git-basics/images/lifecycle.png)\n\n### 4.3 git add命令\n####  4.3.1 跟踪新文件\n通过`$ git add filename`、`$ git add pathname`可分别跟踪某个文件和某个路径下的所有文件，或者通过`$ git add .`来跟踪所有文件。\n#### 4.3.2 暂存已修改文件\n与上述方法相同\n\n因此，`git add`具有多种功能，可理解为**向下次提交中添加内容**\n\n### 4.4 git status命令\n该命令用于查看文件状态\n也可通过`$ git status -s`或者`$ git status --short`查看简写的文件状态。\n\n```\n$ git status -s\nM README\nMM Rakefile\nA  lib/git.rb\nM  lib/simplegit.rb\n?? LICENSE.txt\n```\n各种记号的解释如下：\n\n* ??：未跟踪文件\n* A：新添加到暂存区的文件\n* _M：文件被修改但未添加到暂存区\n* M_：文件被修改且已添加到暂存区\n* MM：文件被修改且已添加到暂存区后又被修改\n\n### 4.5 .gitignore文件\n忽略文件的具体格式可见[忽略文件](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#忽略文件)\n\n### 4.6 git diff命令\ngit diff命令用于查看文件的修改，与git status相比可以具体显示修改的内容。\n\n* `$ git diff`显示的是已修改但未暂存的文件内容\n* `$ git diff --cached`或`$ git diff --staged`查看已暂存但未提交的内容\n\n### 4.7 git commit命令\n通过git commit命令可将暂存区内的文件进行提交，而未暂存的文件则不会被提交。\n可用`$ git commit`命令按提示完成提交或直接通过`$ git commit -m \"yourComments\"`进行提交说明并提交。\n若想对所有已暂存和未暂存的文件进行提交可使用`$ git commit -a -m \"yourComments\"`进行提交，这样可简化操作步骤。\n\n### 4.8 移除文件\n移除文件需要git remove操作。\n\n* 通过`$ git rm fileName`即可将文件移出git版本控制并同时删除工作区中的文件，之后执行commit操作提交即可。\n* 若是直接手动将文件删除，此时文件将会处于未暂存状态，通过git add或git rm操作便可进入已暂存状态，之后执行commit操作即可。\n* 若文件进过修改并送入暂存区，需要用`$ git rm -f fileName`才能强制删除或通过上述第一种方式删除。\n* 若是要将文件从git版本控制中删除但又不想从工作区中删除，则可通过`$ git rm --cached fileName`命令来实现。\n\n### 4.9 移动文件\n移动文件操作通过`$ git mv fileFrom fileTo`来实现，该操作执行过程实际上是执行了删除fileFrom文件之后添加fileTo文件。\n\n### 4.10 撤销操作\n1. 修改提交文件\n * 若提交后发现漏掉其他文件，可通过`$ git commit --amend`操作将当前暂存区的文件加入上次提交中，相当于只存在一次提交。\n * 若是想修改提交文件的提交信息，可通过`$ git commit --amend -m \"newComments\"`\n\n2. 取消暂存文件\n * 通过`$ git reset HEAD fileName`可将文件从暂存区中移除，进入未暂存状态。\n\n3. 取消已修改文件\n * 通过`$ git checkout -- fileName`将已修改的文件还原至上一次未修改时的状态。\n\n### 4.11 远程仓库\ngit项目的协作时会用到远程仓库，当克隆一个项目时，会有一个默认的名为**origin**的远程仓库。\n\n* 可通过`$ git remote`查看所有远程仓库或`$ git remote -v`查看所有远程仓库的具体信息。通过`$ git remote show remoteName`查看指定远程仓库的详细信息。\n* 通过`$ git remote add shortNameForTheRemoteRepository RepositoryUrl`\n* 通过`$ git fetch shortName`可获取该远程仓库中的所有信息，但不会合并或修改当前工作区的文件\n* 通过`$ git pull`命令获取远程仓库的数据并合并到当前分支，默认情况下，本地的master分支会跟踪远程仓库的master分支。\n* 通过`$ git push remoteName branchName`将当前分支推送到指定远程仓库的指定分支上。\n* 重命名远程仓库可使用`$ git remote rename originalName currentName`\n* 删除远程仓库可使用`$ git remote rm repositoryName`\n\n## 5. git分支\n使用分支可以将开发工作从主线上进行分离，git的默认分支是**master**分支。git使用**HEAD**指针指向当前分支，可看做当前分支的一个别名。\n### 5.1 创建分支\n创建分支实际上就是创建了一个指向当前项目的指针，通过`$ git branch`命令可以查看当前分支，`$ git branch branchName`用于创建分支。\n\n### 5.2 切换分支\n命令`$ git checkout branchName`用于切换分支，切换分支后当前的工作区的文件也会随之改变。\n**git分支是以提交的文件为基础的，一般情况下在修改文件后只有当提交了文件才能切换到另一个分支，但也有特殊情况，以branch1和branch2两个分支为例，若在branch1中添加了新文件，此时切换到branch2分支可以看到该文件，若此时提交则该文件属于branch2分支，再次切回branch1中不会保留该文件**\n\n### 5.3 删除分支\n通过`$ git branch -d branchName`可以删除该分支\n\n### 5.4 分支合并\n首先通过`$ git checkout branchName`切换到某一分支，如master分支，接下来执行`$ git merge branchName`将对应分支合并到master中。\n**合并过程中如果两个分支对同一个文件进行了操作，则会产生冲突，需要手动解决，产生冲突的内容会在工作区中的相应文件中被标记出来，需要自己去判断保留哪一份修改，之后执行提交即可。**\n\n### 5.5 跟踪远程分支\n若想跟踪远程分支可以通过`$ git checkout --track remoteRepository/remoteBranch`，也可通过`$ git checkout -b branchName remoteRepository/remoteBranch`新建分支并跟踪远程分支，两者的不同点只是新建分支的名字不同。\n若本地已有分支，则可通过`$ git branch -u remoteRepository/remoteBranch`添加或修改跟踪。\n通过`$ git branch -vv`命令可以查看远程分支的跟踪信息。\n\n### 5.6 删除远程分支\n命令`$ git push remoteRepository --delete remoteBranch`可用于删除远程分支。\n\n\n\n\n\n","slug":"git-knowledge","published":1,"updated":"2016-08-19T10:13:15.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis1me2dj0002no74zcyspcsk","content":"<p>git是平常软件开发中经常使用的版本控制系统，本文对git的原理、基础和配置方式进行了介绍，同时总结了平时使用过程中常见的git操作。<br><a id=\"more\"></a></p>\n<h2 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h2><ol>\n<li>集中式版本控制系统：有一个单一的集中管理的服务器，开发人员都可以连接到这台服务器，进行协同工作。</li>\n</ol>\n<ul>\n<li>优点是系统容易管理和维护</li>\n<li>缺点是如果中央服务器出现故障，工作将不能进行</li>\n</ul>\n<ol>\n<li>分布式版本控制系统：不是只提取最新版本的文件快照，而是将整个代码仓库拷贝到本地，即使服务器故障也能通过本地仓库进行完整的恢复。</li>\n</ol>\n<h2 id=\"2-基础\"><a href=\"#2-基础\" class=\"headerlink\" title=\"2. 基础\"></a>2. 基础</h2><ul>\n<li><p>git保存数据是保存整个文件系统的一个快照<img src=\"https://git-scm.com/book/en/v2/book/01-introduction/images/snapshots.png\" alt=\"git-snapshot\"></p>\n</li>\n<li><p>其他大部分系统保存的是文件的变更信息<img src=\"https://git-scm.com/book/en/v2/book/01-introduction/images/deltas.png\" alt=\"delta\"></p>\n</li>\n<li><p>git大部分操作都是在本地完成的，因此速度很快。即使没有网络，也可以提交文件，之后再上传</p>\n</li>\n<li><p>git通过SHA-1（哈希）计算校验和，由40个十六进制数组成的字符串。git数据库中保存的信息都是通过文件内容的hash值进行索引的而不是文件名。</p>\n</li>\n<li><p>git的三个工作区域</p>\n<ul>\n<li>git仓库：用来保存项目的数据以及数据库，当从其他地方clone项目时，拷贝的就是这里面的数据。</li>\n<li>工作目录：存放的是项目某个版本的内容，存放于磁盘可供修改等操作，来源于git仓库中的压缩数据库。</li>\n<li>暂存区域： 是一个文件，保存了将提交的文件信息。</li>\n</ul>\n</li>\n<li><p>git工作流程</p>\n<ul>\n<li>在工作目录中修改文件(modified)</li>\n<li>将修改的文件暂存在暂存区域(staged)</li>\n<li>提交更新，将暂存区的文件存储到git仓库中(commited)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-git配置\"><a href=\"#3-git配置\" class=\"headerlink\" title=\"3. git配置\"></a>3. git配置</h2><p>git config</p>\n<ul>\n<li>–system：系统上所有用户及仓库的通用配置</li>\n<li>–global：针对当前用户的配置</li>\n<li>–config：针对当前仓库的配置</li>\n</ul>\n<p>上述配置具有优先级，由上往下递增，高优先级的覆盖低优先级的配置。</p>\n<p>第一次使用时会配置个人信息<br><code>$ git config --global user.name yourname</code><br><code>$ git config --global user.email your@email.com</code><br>这些信息会写入每一次提交中，该配置只需配置一次。若想对某个项目使用特定的用户信息，通过git config来配置。<br>可通过git config –list查看所有配置信息，也可通过如git config user.name来查看用户名</p>\n<h2 id=\"4-git基础操作\"><a href=\"#4-git基础操作\" class=\"headerlink\" title=\"4. git基础操作\"></a>4. git基础操作</h2><h3 id=\"4-1-创建git仓库\"><a href=\"#4-1-创建git仓库\" class=\"headerlink\" title=\"4.1 创建git仓库\"></a>4.1 创建git仓库</h3><ul>\n<li>在已有项目中创建git仓库：通过<code>$ git init</code>命令创建一个.git子目录，里面存储了git仓库初始化时的必须文件，但不包括项目文件。</li>\n<li>克隆仓库：通过<code>$ git clone theUrlYouWantToClone</code>，会克隆该仓库的所有版本的文件而不是最新版本的文件。执行该操作后会在当前目录下创建一个与该仓库同名的目录，并在该目录下初始化一个<code>.git</code>文件夹，将远程仓库中的数据拉取到该文件夹，并从中读取最新版本的项目文件，拷贝至其同级目录。<ul>\n<li>可通过<code>$ git clone theUrlYouWantToClone myProjectName</code>修改仓库名称</li>\n</ul>\n</li>\n</ul>\n<p><strong><code>theUrlYouWantToClone</code></strong>可支持多种协议，git中常用到的是https、git和SSH协议。</p>\n<h3 id=\"4-2-文件状态\"><a href=\"#4-2-文件状态\" class=\"headerlink\" title=\"4.2 文件状态\"></a>4.2 文件状态</h3><p>文件具有两种状态<strong>已跟踪</strong>和<strong>未跟踪</strong>。</p>\n<ul>\n<li>已跟踪的文件指的是已被纳入版本控制的文件，它们可能处于<em>未修改</em>、<em>已修改</em>、<em>已暂存</em>等状态。</li>\n<li>将文件从git中移除、新建立一个文件等操作产生的文件都会处于未跟踪状态。<br>git版本控制下文件的生命周期<br><img src=\"https://git-scm.com/book/en/v2/book/02-git-basics/images/lifecycle.png\" alt=\"life-cycle\"></li>\n</ul>\n<h3 id=\"4-3-git-add命令\"><a href=\"#4-3-git-add命令\" class=\"headerlink\" title=\"4.3 git add命令\"></a>4.3 git add命令</h3><h4 id=\"4-3-1-跟踪新文件\"><a href=\"#4-3-1-跟踪新文件\" class=\"headerlink\" title=\"4.3.1 跟踪新文件\"></a>4.3.1 跟踪新文件</h4><p>通过<code>$ git add filename</code>、<code>$ git add pathname</code>可分别跟踪某个文件和某个路径下的所有文件，或者通过<code>$ git add .</code>来跟踪所有文件。</p>\n<h4 id=\"4-3-2-暂存已修改文件\"><a href=\"#4-3-2-暂存已修改文件\" class=\"headerlink\" title=\"4.3.2 暂存已修改文件\"></a>4.3.2 暂存已修改文件</h4><p>与上述方法相同</p>\n<p>因此，<code>git add</code>具有多种功能，可理解为<strong>向下次提交中添加内容</strong></p>\n<h3 id=\"4-4-git-status命令\"><a href=\"#4-4-git-status命令\" class=\"headerlink\" title=\"4.4 git status命令\"></a>4.4 git status命令</h3><p>该命令用于查看文件状态<br>也可通过<code>$ git status -s</code>或者<code>$ git status --short</code>查看简写的文件状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git status -s</div><div class=\"line\">M README</div><div class=\"line\">MM Rakefile</div><div class=\"line\">A  lib/git.rb</div><div class=\"line\">M  lib/simplegit.rb</div><div class=\"line\">?? LICENSE.txt</div></pre></td></tr></table></figure>\n<p>各种记号的解释如下：</p>\n<ul>\n<li>??：未跟踪文件</li>\n<li>A：新添加到暂存区的文件</li>\n<li>_M：文件被修改但未添加到暂存区</li>\n<li>M_：文件被修改且已添加到暂存区</li>\n<li>MM：文件被修改且已添加到暂存区后又被修改</li>\n</ul>\n<h3 id=\"4-5-gitignore文件\"><a href=\"#4-5-gitignore文件\" class=\"headerlink\" title=\"4.5 .gitignore文件\"></a>4.5 .gitignore文件</h3><p>忽略文件的具体格式可见<a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#忽略文件\" target=\"_blank\" rel=\"external\">忽略文件</a></p>\n<h3 id=\"4-6-git-diff命令\"><a href=\"#4-6-git-diff命令\" class=\"headerlink\" title=\"4.6 git diff命令\"></a>4.6 git diff命令</h3><p>git diff命令用于查看文件的修改，与git status相比可以具体显示修改的内容。</p>\n<ul>\n<li><code>$ git diff</code>显示的是已修改但未暂存的文件内容</li>\n<li><code>$ git diff --cached</code>或<code>$ git diff --staged</code>查看已暂存但未提交的内容</li>\n</ul>\n<h3 id=\"4-7-git-commit命令\"><a href=\"#4-7-git-commit命令\" class=\"headerlink\" title=\"4.7 git commit命令\"></a>4.7 git commit命令</h3><p>通过git commit命令可将暂存区内的文件进行提交，而未暂存的文件则不会被提交。<br>可用<code>$ git commit</code>命令按提示完成提交或直接通过<code>$ git commit -m &quot;yourComments&quot;</code>进行提交说明并提交。<br>若想对所有已暂存和未暂存的文件进行提交可使用<code>$ git commit -a -m &quot;yourComments&quot;</code>进行提交，这样可简化操作步骤。</p>\n<h3 id=\"4-8-移除文件\"><a href=\"#4-8-移除文件\" class=\"headerlink\" title=\"4.8 移除文件\"></a>4.8 移除文件</h3><p>移除文件需要git remove操作。</p>\n<ul>\n<li>通过<code>$ git rm fileName</code>即可将文件移出git版本控制并同时删除工作区中的文件，之后执行commit操作提交即可。</li>\n<li>若是直接手动将文件删除，此时文件将会处于未暂存状态，通过git add或git rm操作便可进入已暂存状态，之后执行commit操作即可。</li>\n<li>若文件进过修改并送入暂存区，需要用<code>$ git rm -f fileName</code>才能强制删除或通过上述第一种方式删除。</li>\n<li>若是要将文件从git版本控制中删除但又不想从工作区中删除，则可通过<code>$ git rm --cached fileName</code>命令来实现。</li>\n</ul>\n<h3 id=\"4-9-移动文件\"><a href=\"#4-9-移动文件\" class=\"headerlink\" title=\"4.9 移动文件\"></a>4.9 移动文件</h3><p>移动文件操作通过<code>$ git mv fileFrom fileTo</code>来实现，该操作执行过程实际上是执行了删除fileFrom文件之后添加fileTo文件。</p>\n<h3 id=\"4-10-撤销操作\"><a href=\"#4-10-撤销操作\" class=\"headerlink\" title=\"4.10 撤销操作\"></a>4.10 撤销操作</h3><ol>\n<li><p>修改提交文件</p>\n<ul>\n<li>若提交后发现漏掉其他文件，可通过<code>$ git commit --amend</code>操作将当前暂存区的文件加入上次提交中，相当于只存在一次提交。</li>\n<li>若是想修改提交文件的提交信息，可通过<code>$ git commit --amend -m &quot;newComments&quot;</code></li>\n</ul>\n</li>\n<li><p>取消暂存文件</p>\n<ul>\n<li>通过<code>$ git reset HEAD fileName</code>可将文件从暂存区中移除，进入未暂存状态。</li>\n</ul>\n</li>\n<li><p>取消已修改文件</p>\n<ul>\n<li>通过<code>$ git checkout -- fileName</code>将已修改的文件还原至上一次未修改时的状态。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-11-远程仓库\"><a href=\"#4-11-远程仓库\" class=\"headerlink\" title=\"4.11 远程仓库\"></a>4.11 远程仓库</h3><p>git项目的协作时会用到远程仓库，当克隆一个项目时，会有一个默认的名为<strong>origin</strong>的远程仓库。</p>\n<ul>\n<li>可通过<code>$ git remote</code>查看所有远程仓库或<code>$ git remote -v</code>查看所有远程仓库的具体信息。通过<code>$ git remote show remoteName</code>查看指定远程仓库的详细信息。</li>\n<li>通过<code>$ git remote add shortNameForTheRemoteRepository RepositoryUrl</code></li>\n<li>通过<code>$ git fetch shortName</code>可获取该远程仓库中的所有信息，但不会合并或修改当前工作区的文件</li>\n<li>通过<code>$ git pull</code>命令获取远程仓库的数据并合并到当前分支，默认情况下，本地的master分支会跟踪远程仓库的master分支。</li>\n<li>通过<code>$ git push remoteName branchName</code>将当前分支推送到指定远程仓库的指定分支上。</li>\n<li>重命名远程仓库可使用<code>$ git remote rename originalName currentName</code></li>\n<li>删除远程仓库可使用<code>$ git remote rm repositoryName</code></li>\n</ul>\n<h2 id=\"5-git分支\"><a href=\"#5-git分支\" class=\"headerlink\" title=\"5. git分支\"></a>5. git分支</h2><p>使用分支可以将开发工作从主线上进行分离，git的默认分支是<strong>master</strong>分支。git使用<strong>HEAD</strong>指针指向当前分支，可看做当前分支的一个别名。</p>\n<h3 id=\"5-1-创建分支\"><a href=\"#5-1-创建分支\" class=\"headerlink\" title=\"5.1 创建分支\"></a>5.1 创建分支</h3><p>创建分支实际上就是创建了一个指向当前项目的指针，通过<code>$ git branch</code>命令可以查看当前分支，<code>$ git branch branchName</code>用于创建分支。</p>\n<h3 id=\"5-2-切换分支\"><a href=\"#5-2-切换分支\" class=\"headerlink\" title=\"5.2 切换分支\"></a>5.2 切换分支</h3><p>命令<code>$ git checkout branchName</code>用于切换分支，切换分支后当前的工作区的文件也会随之改变。<br><strong>git分支是以提交的文件为基础的，一般情况下在修改文件后只有当提交了文件才能切换到另一个分支，但也有特殊情况，以branch1和branch2两个分支为例，若在branch1中添加了新文件，此时切换到branch2分支可以看到该文件，若此时提交则该文件属于branch2分支，再次切回branch1中不会保留该文件</strong></p>\n<h3 id=\"5-3-删除分支\"><a href=\"#5-3-删除分支\" class=\"headerlink\" title=\"5.3 删除分支\"></a>5.3 删除分支</h3><p>通过<code>$ git branch -d branchName</code>可以删除该分支</p>\n<h3 id=\"5-4-分支合并\"><a href=\"#5-4-分支合并\" class=\"headerlink\" title=\"5.4 分支合并\"></a>5.4 分支合并</h3><p>首先通过<code>$ git checkout branchName</code>切换到某一分支，如master分支，接下来执行<code>$ git merge branchName</code>将对应分支合并到master中。<br><strong>合并过程中如果两个分支对同一个文件进行了操作，则会产生冲突，需要手动解决，产生冲突的内容会在工作区中的相应文件中被标记出来，需要自己去判断保留哪一份修改，之后执行提交即可。</strong></p>\n<h3 id=\"5-5-跟踪远程分支\"><a href=\"#5-5-跟踪远程分支\" class=\"headerlink\" title=\"5.5 跟踪远程分支\"></a>5.5 跟踪远程分支</h3><p>若想跟踪远程分支可以通过<code>$ git checkout --track remoteRepository/remoteBranch</code>，也可通过<code>$ git checkout -b branchName remoteRepository/remoteBranch</code>新建分支并跟踪远程分支，两者的不同点只是新建分支的名字不同。<br>若本地已有分支，则可通过<code>$ git branch -u remoteRepository/remoteBranch</code>添加或修改跟踪。<br>通过<code>$ git branch -vv</code>命令可以查看远程分支的跟踪信息。</p>\n<h3 id=\"5-6-删除远程分支\"><a href=\"#5-6-删除远程分支\" class=\"headerlink\" title=\"5.6 删除远程分支\"></a>5.6 删除远程分支</h3><p>命令<code>$ git push remoteRepository --delete remoteBranch</code>可用于删除远程分支。</p>\n","excerpt":"<p>git是平常软件开发中经常使用的版本控制系统，本文对git的原理、基础和配置方式进行了介绍，同时总结了平时使用过程中常见的git操作。<br>","more":"</p>\n<h2 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h2><ol>\n<li>集中式版本控制系统：有一个单一的集中管理的服务器，开发人员都可以连接到这台服务器，进行协同工作。</li>\n</ol>\n<ul>\n<li>优点是系统容易管理和维护</li>\n<li>缺点是如果中央服务器出现故障，工作将不能进行</li>\n</ul>\n<ol>\n<li>分布式版本控制系统：不是只提取最新版本的文件快照，而是将整个代码仓库拷贝到本地，即使服务器故障也能通过本地仓库进行完整的恢复。</li>\n</ol>\n<h2 id=\"2-基础\"><a href=\"#2-基础\" class=\"headerlink\" title=\"2. 基础\"></a>2. 基础</h2><ul>\n<li><p>git保存数据是保存整个文件系统的一个快照<img src=\"https://git-scm.com/book/en/v2/book/01-introduction/images/snapshots.png\" alt=\"git-snapshot\"></p>\n</li>\n<li><p>其他大部分系统保存的是文件的变更信息<img src=\"https://git-scm.com/book/en/v2/book/01-introduction/images/deltas.png\" alt=\"delta\"></p>\n</li>\n<li><p>git大部分操作都是在本地完成的，因此速度很快。即使没有网络，也可以提交文件，之后再上传</p>\n</li>\n<li><p>git通过SHA-1（哈希）计算校验和，由40个十六进制数组成的字符串。git数据库中保存的信息都是通过文件内容的hash值进行索引的而不是文件名。</p>\n</li>\n<li><p>git的三个工作区域</p>\n<ul>\n<li>git仓库：用来保存项目的数据以及数据库，当从其他地方clone项目时，拷贝的就是这里面的数据。</li>\n<li>工作目录：存放的是项目某个版本的内容，存放于磁盘可供修改等操作，来源于git仓库中的压缩数据库。</li>\n<li>暂存区域： 是一个文件，保存了将提交的文件信息。</li>\n</ul>\n</li>\n<li><p>git工作流程</p>\n<ul>\n<li>在工作目录中修改文件(modified)</li>\n<li>将修改的文件暂存在暂存区域(staged)</li>\n<li>提交更新，将暂存区的文件存储到git仓库中(commited)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-git配置\"><a href=\"#3-git配置\" class=\"headerlink\" title=\"3. git配置\"></a>3. git配置</h2><p>git config</p>\n<ul>\n<li>–system：系统上所有用户及仓库的通用配置</li>\n<li>–global：针对当前用户的配置</li>\n<li>–config：针对当前仓库的配置</li>\n</ul>\n<p>上述配置具有优先级，由上往下递增，高优先级的覆盖低优先级的配置。</p>\n<p>第一次使用时会配置个人信息<br><code>$ git config --global user.name yourname</code><br><code>$ git config --global user.email your@email.com</code><br>这些信息会写入每一次提交中，该配置只需配置一次。若想对某个项目使用特定的用户信息，通过git config来配置。<br>可通过git config –list查看所有配置信息，也可通过如git config user.name来查看用户名</p>\n<h2 id=\"4-git基础操作\"><a href=\"#4-git基础操作\" class=\"headerlink\" title=\"4. git基础操作\"></a>4. git基础操作</h2><h3 id=\"4-1-创建git仓库\"><a href=\"#4-1-创建git仓库\" class=\"headerlink\" title=\"4.1 创建git仓库\"></a>4.1 创建git仓库</h3><ul>\n<li>在已有项目中创建git仓库：通过<code>$ git init</code>命令创建一个.git子目录，里面存储了git仓库初始化时的必须文件，但不包括项目文件。</li>\n<li>克隆仓库：通过<code>$ git clone theUrlYouWantToClone</code>，会克隆该仓库的所有版本的文件而不是最新版本的文件。执行该操作后会在当前目录下创建一个与该仓库同名的目录，并在该目录下初始化一个<code>.git</code>文件夹，将远程仓库中的数据拉取到该文件夹，并从中读取最新版本的项目文件，拷贝至其同级目录。<ul>\n<li>可通过<code>$ git clone theUrlYouWantToClone myProjectName</code>修改仓库名称</li>\n</ul>\n</li>\n</ul>\n<p><strong><code>theUrlYouWantToClone</code></strong>可支持多种协议，git中常用到的是https、git和SSH协议。</p>\n<h3 id=\"4-2-文件状态\"><a href=\"#4-2-文件状态\" class=\"headerlink\" title=\"4.2 文件状态\"></a>4.2 文件状态</h3><p>文件具有两种状态<strong>已跟踪</strong>和<strong>未跟踪</strong>。</p>\n<ul>\n<li>已跟踪的文件指的是已被纳入版本控制的文件，它们可能处于<em>未修改</em>、<em>已修改</em>、<em>已暂存</em>等状态。</li>\n<li>将文件从git中移除、新建立一个文件等操作产生的文件都会处于未跟踪状态。<br>git版本控制下文件的生命周期<br><img src=\"https://git-scm.com/book/en/v2/book/02-git-basics/images/lifecycle.png\" alt=\"life-cycle\"></li>\n</ul>\n<h3 id=\"4-3-git-add命令\"><a href=\"#4-3-git-add命令\" class=\"headerlink\" title=\"4.3 git add命令\"></a>4.3 git add命令</h3><h4 id=\"4-3-1-跟踪新文件\"><a href=\"#4-3-1-跟踪新文件\" class=\"headerlink\" title=\"4.3.1 跟踪新文件\"></a>4.3.1 跟踪新文件</h4><p>通过<code>$ git add filename</code>、<code>$ git add pathname</code>可分别跟踪某个文件和某个路径下的所有文件，或者通过<code>$ git add .</code>来跟踪所有文件。</p>\n<h4 id=\"4-3-2-暂存已修改文件\"><a href=\"#4-3-2-暂存已修改文件\" class=\"headerlink\" title=\"4.3.2 暂存已修改文件\"></a>4.3.2 暂存已修改文件</h4><p>与上述方法相同</p>\n<p>因此，<code>git add</code>具有多种功能，可理解为<strong>向下次提交中添加内容</strong></p>\n<h3 id=\"4-4-git-status命令\"><a href=\"#4-4-git-status命令\" class=\"headerlink\" title=\"4.4 git status命令\"></a>4.4 git status命令</h3><p>该命令用于查看文件状态<br>也可通过<code>$ git status -s</code>或者<code>$ git status --short</code>查看简写的文件状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git status -s</div><div class=\"line\">M README</div><div class=\"line\">MM Rakefile</div><div class=\"line\">A  lib/git.rb</div><div class=\"line\">M  lib/simplegit.rb</div><div class=\"line\">?? LICENSE.txt</div></pre></td></tr></table></figure>\n<p>各种记号的解释如下：</p>\n<ul>\n<li>??：未跟踪文件</li>\n<li>A：新添加到暂存区的文件</li>\n<li>_M：文件被修改但未添加到暂存区</li>\n<li>M_：文件被修改且已添加到暂存区</li>\n<li>MM：文件被修改且已添加到暂存区后又被修改</li>\n</ul>\n<h3 id=\"4-5-gitignore文件\"><a href=\"#4-5-gitignore文件\" class=\"headerlink\" title=\"4.5 .gitignore文件\"></a>4.5 .gitignore文件</h3><p>忽略文件的具体格式可见<a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#忽略文件\">忽略文件</a></p>\n<h3 id=\"4-6-git-diff命令\"><a href=\"#4-6-git-diff命令\" class=\"headerlink\" title=\"4.6 git diff命令\"></a>4.6 git diff命令</h3><p>git diff命令用于查看文件的修改，与git status相比可以具体显示修改的内容。</p>\n<ul>\n<li><code>$ git diff</code>显示的是已修改但未暂存的文件内容</li>\n<li><code>$ git diff --cached</code>或<code>$ git diff --staged</code>查看已暂存但未提交的内容</li>\n</ul>\n<h3 id=\"4-7-git-commit命令\"><a href=\"#4-7-git-commit命令\" class=\"headerlink\" title=\"4.7 git commit命令\"></a>4.7 git commit命令</h3><p>通过git commit命令可将暂存区内的文件进行提交，而未暂存的文件则不会被提交。<br>可用<code>$ git commit</code>命令按提示完成提交或直接通过<code>$ git commit -m &quot;yourComments&quot;</code>进行提交说明并提交。<br>若想对所有已暂存和未暂存的文件进行提交可使用<code>$ git commit -a -m &quot;yourComments&quot;</code>进行提交，这样可简化操作步骤。</p>\n<h3 id=\"4-8-移除文件\"><a href=\"#4-8-移除文件\" class=\"headerlink\" title=\"4.8 移除文件\"></a>4.8 移除文件</h3><p>移除文件需要git remove操作。</p>\n<ul>\n<li>通过<code>$ git rm fileName</code>即可将文件移出git版本控制并同时删除工作区中的文件，之后执行commit操作提交即可。</li>\n<li>若是直接手动将文件删除，此时文件将会处于未暂存状态，通过git add或git rm操作便可进入已暂存状态，之后执行commit操作即可。</li>\n<li>若文件进过修改并送入暂存区，需要用<code>$ git rm -f fileName</code>才能强制删除或通过上述第一种方式删除。</li>\n<li>若是要将文件从git版本控制中删除但又不想从工作区中删除，则可通过<code>$ git rm --cached fileName</code>命令来实现。</li>\n</ul>\n<h3 id=\"4-9-移动文件\"><a href=\"#4-9-移动文件\" class=\"headerlink\" title=\"4.9 移动文件\"></a>4.9 移动文件</h3><p>移动文件操作通过<code>$ git mv fileFrom fileTo</code>来实现，该操作执行过程实际上是执行了删除fileFrom文件之后添加fileTo文件。</p>\n<h3 id=\"4-10-撤销操作\"><a href=\"#4-10-撤销操作\" class=\"headerlink\" title=\"4.10 撤销操作\"></a>4.10 撤销操作</h3><ol>\n<li><p>修改提交文件</p>\n<ul>\n<li>若提交后发现漏掉其他文件，可通过<code>$ git commit --amend</code>操作将当前暂存区的文件加入上次提交中，相当于只存在一次提交。</li>\n<li>若是想修改提交文件的提交信息，可通过<code>$ git commit --amend -m &quot;newComments&quot;</code></li>\n</ul>\n</li>\n<li><p>取消暂存文件</p>\n<ul>\n<li>通过<code>$ git reset HEAD fileName</code>可将文件从暂存区中移除，进入未暂存状态。</li>\n</ul>\n</li>\n<li><p>取消已修改文件</p>\n<ul>\n<li>通过<code>$ git checkout -- fileName</code>将已修改的文件还原至上一次未修改时的状态。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-11-远程仓库\"><a href=\"#4-11-远程仓库\" class=\"headerlink\" title=\"4.11 远程仓库\"></a>4.11 远程仓库</h3><p>git项目的协作时会用到远程仓库，当克隆一个项目时，会有一个默认的名为<strong>origin</strong>的远程仓库。</p>\n<ul>\n<li>可通过<code>$ git remote</code>查看所有远程仓库或<code>$ git remote -v</code>查看所有远程仓库的具体信息。通过<code>$ git remote show remoteName</code>查看指定远程仓库的详细信息。</li>\n<li>通过<code>$ git remote add shortNameForTheRemoteRepository RepositoryUrl</code></li>\n<li>通过<code>$ git fetch shortName</code>可获取该远程仓库中的所有信息，但不会合并或修改当前工作区的文件</li>\n<li>通过<code>$ git pull</code>命令获取远程仓库的数据并合并到当前分支，默认情况下，本地的master分支会跟踪远程仓库的master分支。</li>\n<li>通过<code>$ git push remoteName branchName</code>将当前分支推送到指定远程仓库的指定分支上。</li>\n<li>重命名远程仓库可使用<code>$ git remote rename originalName currentName</code></li>\n<li>删除远程仓库可使用<code>$ git remote rm repositoryName</code></li>\n</ul>\n<h2 id=\"5-git分支\"><a href=\"#5-git分支\" class=\"headerlink\" title=\"5. git分支\"></a>5. git分支</h2><p>使用分支可以将开发工作从主线上进行分离，git的默认分支是<strong>master</strong>分支。git使用<strong>HEAD</strong>指针指向当前分支，可看做当前分支的一个别名。</p>\n<h3 id=\"5-1-创建分支\"><a href=\"#5-1-创建分支\" class=\"headerlink\" title=\"5.1 创建分支\"></a>5.1 创建分支</h3><p>创建分支实际上就是创建了一个指向当前项目的指针，通过<code>$ git branch</code>命令可以查看当前分支，<code>$ git branch branchName</code>用于创建分支。</p>\n<h3 id=\"5-2-切换分支\"><a href=\"#5-2-切换分支\" class=\"headerlink\" title=\"5.2 切换分支\"></a>5.2 切换分支</h3><p>命令<code>$ git checkout branchName</code>用于切换分支，切换分支后当前的工作区的文件也会随之改变。<br><strong>git分支是以提交的文件为基础的，一般情况下在修改文件后只有当提交了文件才能切换到另一个分支，但也有特殊情况，以branch1和branch2两个分支为例，若在branch1中添加了新文件，此时切换到branch2分支可以看到该文件，若此时提交则该文件属于branch2分支，再次切回branch1中不会保留该文件</strong></p>\n<h3 id=\"5-3-删除分支\"><a href=\"#5-3-删除分支\" class=\"headerlink\" title=\"5.3 删除分支\"></a>5.3 删除分支</h3><p>通过<code>$ git branch -d branchName</code>可以删除该分支</p>\n<h3 id=\"5-4-分支合并\"><a href=\"#5-4-分支合并\" class=\"headerlink\" title=\"5.4 分支合并\"></a>5.4 分支合并</h3><p>首先通过<code>$ git checkout branchName</code>切换到某一分支，如master分支，接下来执行<code>$ git merge branchName</code>将对应分支合并到master中。<br><strong>合并过程中如果两个分支对同一个文件进行了操作，则会产生冲突，需要手动解决，产生冲突的内容会在工作区中的相应文件中被标记出来，需要自己去判断保留哪一份修改，之后执行提交即可。</strong></p>\n<h3 id=\"5-5-跟踪远程分支\"><a href=\"#5-5-跟踪远程分支\" class=\"headerlink\" title=\"5.5 跟踪远程分支\"></a>5.5 跟踪远程分支</h3><p>若想跟踪远程分支可以通过<code>$ git checkout --track remoteRepository/remoteBranch</code>，也可通过<code>$ git checkout -b branchName remoteRepository/remoteBranch</code>新建分支并跟踪远程分支，两者的不同点只是新建分支的名字不同。<br>若本地已有分支，则可通过<code>$ git branch -u remoteRepository/remoteBranch</code>添加或修改跟踪。<br>通过<code>$ git branch -vv</code>命令可以查看远程分支的跟踪信息。</p>\n<h3 id=\"5-6-删除远程分支\"><a href=\"#5-6-删除远程分支\" class=\"headerlink\" title=\"5.6 删除远程分支\"></a>5.6 删除远程分支</h3><p>命令<code>$ git push remoteRepository --delete remoteBranch</code>可用于删除远程分支。</p>"},{"title":"javascript正则表达式","date":"2016-04-07T16:00:00.000Z","folder":"web/js","en-title":"javascript-regex","_content":"\n正则表达式常用作检索、匹配或者替换文本，它是一种文本模式匹配的方法，在我们对复杂文本进行操作时，使用正则表达式会极大的简化我们的操作。本文将介绍正则表达式对象和匹配规则。\n<!--more-->\n\n## 1. 简介\n正则表达式是一种表示文本模式的方法，常用于匹配文本，例如email地址的验证等等，js中的正则表达式是Perl 5的子集。\n\n正则表达式有两种写法：\n\n```javascript\n    var reg = /abc/;\n    var reg = new RegExp(\"abc\");\n```\n上述两种写法的主要区别在于新建正则表达式的时间，前者是在编译时完成，后者则是在运行时完成。\n\n## 2. 正则表达式对象\n### 2.1 属性\n正则表达式对象的属性主要有5个：\n\n* 与修饰符相关，都返回布尔值并且都是只读属性：\n    * ignoreCase：表示是否设置了i修饰符\n    * global：表示是否设置了g修饰符\n    * multiline：表示是否设置m修饰符\n* 与修饰符无关：\n    * lastIndex：返回下一次开始搜索的位置，**且只在设置了g修饰符时才有意义**。\n    * source：返回正则表达式相应的字符串形式。\n\n### 2.2 方法（正则表达式）\n\n* `test()`\n    * test接收一个字符串用于验证该字符串能否被匹配，结果返回布尔值。\n    * 若正则表达式字符串为空，则能匹配所有字符串。\n\n* `exec()`\n    * exec接收一个字符串并且以数组的形式返回匹配结果，含有每一个匹配成功的子字符串，若匹配失败则返回null。\n    * 返回的数组含有两个属性：\n        * `input`：表示原字符串\n        * `index`：表示模式匹配成功的开始位置\n\n### 2.3 方法（字符串）\n\n* match()：返回一个数组，成员是所有匹配的子字符串。\n    * 该方法与正则表达式的`exec`方法类似\n    * 如果正则表达式带有`g`修饰符，该方法会返回所有匹配的结果，而`exec`则不会。\n    * 设置`lastIndex`属性对其无效。\n* search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。若不匹配则返回-1.（**忽略g修饰符和lastIndex属性**）。\n* replace()：按照给定的正则表达式进行替换，返回替换后的字符串。\n    * 有两个参数，第一个是搜索的模式，第二个是替换的内容。\n    * 搜索模式如果不加g修饰符，则替换第一个匹配的结果，否则替换所有的匹配结果。\n    * 该方法的第二个参数可以使用`$`来指代所替换的内容。\n        * `$&` 指代匹配的子字符串。\n        * `$\\` 指代匹配结果前面的文本。\n        * `$'` 指代匹配结果后面的文本。\n        * `$n` 指代匹配成功的第n组内容，n是从1开始的自然数。\n        * `$$` 指代美元符号$。\n\n\n* split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。\n\n### 2.4 匹配规则\n\n* 字面量字符：字符直接表示其字面的含义，如/a/、/word/。\n* 元字符：表示特殊含义\n    * `.`字符\n        * 能匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。\n        * 但是只能匹配一个字符。\n    * 位置字符\n        * `^`字符：表示字符串的开始位置\n        * `$`字符：表示字符串的结束位置\n    * 选择符\n        * `|`字符：表示关系”或“。**会包括前后的多个字符**\n * 重复类：用于精确设置匹配次数，使用`{}`表示。`{n}`表示重复n次，`{n,}`表示不少于n次，`{m,n}`表示重复m~n次。**只匹配前一个字符**\n* 量词符：用于设置模式匹配的次数，同样只匹配前一个字符：\n    * `?`等同于`{0,1}`\n    * `*`等同于`{0,}`\n    * `+`等同于`{1,}`\n* 贪婪模式：匹配到下一个字符不满足匹配规则为止。\n    * 所有的量词符后面加上`?`即可变为非贪婪模式。\n* 字符类：表示一系列字符中只要匹配一个就可以，所有可供选择的字符都放在方括号中。如`[abc]`：表示匹配a、b、c三个字母中的任意一个。\n    * 脱字符（^）\n        * `[^abc]`：表示除了abc外所有字符都可以匹配。\n        * `[^]`可以匹配所有字符，比`.`匹配更强。\n        * `^`字符只有在字符类的第一个位置才有意义，否则直接就是字面含义。\n    * 连字符（-）\n        * 对于连续序列的字符可用（-）来简写。\n        * `[a-z]`表示所有的小写字母。\n        * `-`字符若不在方括号之中则代表字面含义。\n        * 并且连字符必须在头尾两个字符之间才有特殊含义，否则只是字面含义。\n* 转义符\n    * 在正则表达式中有些特殊含义的字符，如果要匹配它们本身则需要在前面加上反斜杠。\n    * 正则表达式中需要斜杠转义的一共有以下12个字符：`^`、`.`、`[`、`$`、`(`、`)`、`|`、`*`、`+`、`?`、`{`和`\\\\`。\n    * 注意若是通过RegExp构造函数生成正则对象，转义时需要使用双斜杠`\\\\`，因为字符串内部会先转义一次。\n* 修饰符\n    * `g`修饰符\n        * 默认情况下，第一次匹配成功之后正则表达式就停止匹配，若有g修饰符则会匹配所有符合条件的结果，主要用于搜索和替换。\n    * `i`修饰符\n        * 表示忽略大小写。\n    * `m`修饰符\n        * 表示多行模式，会修改`^`、`$`的行为，这两个字符默认情况下是作为位置字符来匹配字符串的开始和结束位置。当加上m修饰符时会匹配行首和行尾，即会识别换行符（\\n）。\n        * `/^bc/m.test(\"a\\nbc\")`返回true。\n* 预定义模式：指常见模式的一些简写方式\n    * `\\d` 匹配0-9之间的任一数字，相当于`[0-9]`。\n    * `\\D` 匹配所有0-9以外的字符，相当于`[^0-9]`。\n    * `\\w` 匹配任意的字母、数字和下划线，相当于`[A-Za-z0-9_]`。\n    * `\\W` 除所有字母、数字和下划线以外的字符，相当于`[^A-Za-z0-9_]`。\n    * `\\s` 匹配空格（包括制表符、空格符、断行符等），相等于`[\\t\\r\\n\\v\\f]`。\n    * `\\S` 匹配非空格的字符，相当于`[^\\t\\r\\n\\v\\f]`。\n    * `\\b` 匹配词的边界，即该词单独存在。\n    * `\\B` 匹配非词边界，即在词的内部。\n* 特殊字符：正则表达式中表示一些不能打印的字符。\n    > \\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。\n    [\\b] 匹配退格键(U+0008)，不要与\\b混淆。\n    \\n 匹配换行键。\n    \\r 匹配回车键。\n    \\t 匹配制表符tab（U+0009）。\n    \\v 匹配垂直制表符（U+000B）。\n    \\f 匹配换页符（U+000C）。\n    \\0 匹配null字符（U+0000）。\n    \\xhh 匹配一个以两位十六进制数表示的字符。\n    \\uhhhh 匹配一个以四位十六进制数表示的unicode字符。\n\n* 组匹配\n    * 正则表达式中通过括号表示分组匹配。\n    * 使用组匹配时不宜同时使用g修饰符，否则match方法不会捕获分组内容。如：`\"abcabc\".match(/(.)b(.)/);//返回['abc', 'a', 'c']`而`\"abcabc\".march(/(.)b(.)/g)返回['abc', 'abc']`。\n    * 组匹配中通过`\\数字`可以引用括号匹配的内容。如：`/(.)b(.)\\1\\2/.test('abcabc') // \\1表示第一个括号匹配结果即a， \\2表示第二个括号匹配结果即c`。\n* 非捕获组\n    * `(?:x)`表示不返回该组匹配的内容，为了不占用组匹配。\n    * 如：`\"abc\".match(/(?:.)b(.)/)`返回[\"abc\", \"c\"]。\n* 先行断言\n    * `x(?=y)`表示x只有在y的前面才匹配，并且匹配结果中不会将y计入。\n    * 如：`\"abc\".match(/b(?=c)/);`返回[\"b\"]。\n* 先行否定断言\n    * x只有不在y前面才会匹配。\n\n\n\n","source":"_posts/javascript-regex.md","raw":"title: javascript正则表达式\n\ncategories:\n- Web开发\n- JS\ntags:\n- Web开发\n- JS\n\ndate: 2016/04/08\nfolder: web/js\nen-title: javascript-regex\n---\n\n正则表达式常用作检索、匹配或者替换文本，它是一种文本模式匹配的方法，在我们对复杂文本进行操作时，使用正则表达式会极大的简化我们的操作。本文将介绍正则表达式对象和匹配规则。\n<!--more-->\n\n## 1. 简介\n正则表达式是一种表示文本模式的方法，常用于匹配文本，例如email地址的验证等等，js中的正则表达式是Perl 5的子集。\n\n正则表达式有两种写法：\n\n```javascript\n    var reg = /abc/;\n    var reg = new RegExp(\"abc\");\n```\n上述两种写法的主要区别在于新建正则表达式的时间，前者是在编译时完成，后者则是在运行时完成。\n\n## 2. 正则表达式对象\n### 2.1 属性\n正则表达式对象的属性主要有5个：\n\n* 与修饰符相关，都返回布尔值并且都是只读属性：\n    * ignoreCase：表示是否设置了i修饰符\n    * global：表示是否设置了g修饰符\n    * multiline：表示是否设置m修饰符\n* 与修饰符无关：\n    * lastIndex：返回下一次开始搜索的位置，**且只在设置了g修饰符时才有意义**。\n    * source：返回正则表达式相应的字符串形式。\n\n### 2.2 方法（正则表达式）\n\n* `test()`\n    * test接收一个字符串用于验证该字符串能否被匹配，结果返回布尔值。\n    * 若正则表达式字符串为空，则能匹配所有字符串。\n\n* `exec()`\n    * exec接收一个字符串并且以数组的形式返回匹配结果，含有每一个匹配成功的子字符串，若匹配失败则返回null。\n    * 返回的数组含有两个属性：\n        * `input`：表示原字符串\n        * `index`：表示模式匹配成功的开始位置\n\n### 2.3 方法（字符串）\n\n* match()：返回一个数组，成员是所有匹配的子字符串。\n    * 该方法与正则表达式的`exec`方法类似\n    * 如果正则表达式带有`g`修饰符，该方法会返回所有匹配的结果，而`exec`则不会。\n    * 设置`lastIndex`属性对其无效。\n* search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。若不匹配则返回-1.（**忽略g修饰符和lastIndex属性**）。\n* replace()：按照给定的正则表达式进行替换，返回替换后的字符串。\n    * 有两个参数，第一个是搜索的模式，第二个是替换的内容。\n    * 搜索模式如果不加g修饰符，则替换第一个匹配的结果，否则替换所有的匹配结果。\n    * 该方法的第二个参数可以使用`$`来指代所替换的内容。\n        * `$&` 指代匹配的子字符串。\n        * `$\\` 指代匹配结果前面的文本。\n        * `$'` 指代匹配结果后面的文本。\n        * `$n` 指代匹配成功的第n组内容，n是从1开始的自然数。\n        * `$$` 指代美元符号$。\n\n\n* split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。\n\n### 2.4 匹配规则\n\n* 字面量字符：字符直接表示其字面的含义，如/a/、/word/。\n* 元字符：表示特殊含义\n    * `.`字符\n        * 能匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。\n        * 但是只能匹配一个字符。\n    * 位置字符\n        * `^`字符：表示字符串的开始位置\n        * `$`字符：表示字符串的结束位置\n    * 选择符\n        * `|`字符：表示关系”或“。**会包括前后的多个字符**\n * 重复类：用于精确设置匹配次数，使用`{}`表示。`{n}`表示重复n次，`{n,}`表示不少于n次，`{m,n}`表示重复m~n次。**只匹配前一个字符**\n* 量词符：用于设置模式匹配的次数，同样只匹配前一个字符：\n    * `?`等同于`{0,1}`\n    * `*`等同于`{0,}`\n    * `+`等同于`{1,}`\n* 贪婪模式：匹配到下一个字符不满足匹配规则为止。\n    * 所有的量词符后面加上`?`即可变为非贪婪模式。\n* 字符类：表示一系列字符中只要匹配一个就可以，所有可供选择的字符都放在方括号中。如`[abc]`：表示匹配a、b、c三个字母中的任意一个。\n    * 脱字符（^）\n        * `[^abc]`：表示除了abc外所有字符都可以匹配。\n        * `[^]`可以匹配所有字符，比`.`匹配更强。\n        * `^`字符只有在字符类的第一个位置才有意义，否则直接就是字面含义。\n    * 连字符（-）\n        * 对于连续序列的字符可用（-）来简写。\n        * `[a-z]`表示所有的小写字母。\n        * `-`字符若不在方括号之中则代表字面含义。\n        * 并且连字符必须在头尾两个字符之间才有特殊含义，否则只是字面含义。\n* 转义符\n    * 在正则表达式中有些特殊含义的字符，如果要匹配它们本身则需要在前面加上反斜杠。\n    * 正则表达式中需要斜杠转义的一共有以下12个字符：`^`、`.`、`[`、`$`、`(`、`)`、`|`、`*`、`+`、`?`、`{`和`\\\\`。\n    * 注意若是通过RegExp构造函数生成正则对象，转义时需要使用双斜杠`\\\\`，因为字符串内部会先转义一次。\n* 修饰符\n    * `g`修饰符\n        * 默认情况下，第一次匹配成功之后正则表达式就停止匹配，若有g修饰符则会匹配所有符合条件的结果，主要用于搜索和替换。\n    * `i`修饰符\n        * 表示忽略大小写。\n    * `m`修饰符\n        * 表示多行模式，会修改`^`、`$`的行为，这两个字符默认情况下是作为位置字符来匹配字符串的开始和结束位置。当加上m修饰符时会匹配行首和行尾，即会识别换行符（\\n）。\n        * `/^bc/m.test(\"a\\nbc\")`返回true。\n* 预定义模式：指常见模式的一些简写方式\n    * `\\d` 匹配0-9之间的任一数字，相当于`[0-9]`。\n    * `\\D` 匹配所有0-9以外的字符，相当于`[^0-9]`。\n    * `\\w` 匹配任意的字母、数字和下划线，相当于`[A-Za-z0-9_]`。\n    * `\\W` 除所有字母、数字和下划线以外的字符，相当于`[^A-Za-z0-9_]`。\n    * `\\s` 匹配空格（包括制表符、空格符、断行符等），相等于`[\\t\\r\\n\\v\\f]`。\n    * `\\S` 匹配非空格的字符，相当于`[^\\t\\r\\n\\v\\f]`。\n    * `\\b` 匹配词的边界，即该词单独存在。\n    * `\\B` 匹配非词边界，即在词的内部。\n* 特殊字符：正则表达式中表示一些不能打印的字符。\n    > \\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。\n    [\\b] 匹配退格键(U+0008)，不要与\\b混淆。\n    \\n 匹配换行键。\n    \\r 匹配回车键。\n    \\t 匹配制表符tab（U+0009）。\n    \\v 匹配垂直制表符（U+000B）。\n    \\f 匹配换页符（U+000C）。\n    \\0 匹配null字符（U+0000）。\n    \\xhh 匹配一个以两位十六进制数表示的字符。\n    \\uhhhh 匹配一个以四位十六进制数表示的unicode字符。\n\n* 组匹配\n    * 正则表达式中通过括号表示分组匹配。\n    * 使用组匹配时不宜同时使用g修饰符，否则match方法不会捕获分组内容。如：`\"abcabc\".match(/(.)b(.)/);//返回['abc', 'a', 'c']`而`\"abcabc\".march(/(.)b(.)/g)返回['abc', 'abc']`。\n    * 组匹配中通过`\\数字`可以引用括号匹配的内容。如：`/(.)b(.)\\1\\2/.test('abcabc') // \\1表示第一个括号匹配结果即a， \\2表示第二个括号匹配结果即c`。\n* 非捕获组\n    * `(?:x)`表示不返回该组匹配的内容，为了不占用组匹配。\n    * 如：`\"abc\".match(/(?:.)b(.)/)`返回[\"abc\", \"c\"]。\n* 先行断言\n    * `x(?=y)`表示x只有在y的前面才匹配，并且匹配结果中不会将y计入。\n    * 如：`\"abc\".match(/b(?=c)/);`返回[\"b\"]。\n* 先行否定断言\n    * x只有不在y前面才会匹配。\n\n\n\n","slug":"javascript-regex","published":1,"updated":"2016-08-19T10:13:15.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis1me2dy0006no744m2cer0w","content":"<p>正则表达式常用作检索、匹配或者替换文本，它是一种文本模式匹配的方法，在我们对复杂文本进行操作时，使用正则表达式会极大的简化我们的操作。本文将介绍正则表达式对象和匹配规则。<br><a id=\"more\"></a></p>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>正则表达式是一种表示文本模式的方法，常用于匹配文本，例如email地址的验证等等，js中的正则表达式是Perl 5的子集。</p>\n<p>正则表达式有两种写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"abc\"</span>);</div></pre></td></tr></table></figure>\n<p>上述两种写法的主要区别在于新建正则表达式的时间，前者是在编译时完成，后者则是在运行时完成。</p>\n<h2 id=\"2-正则表达式对象\"><a href=\"#2-正则表达式对象\" class=\"headerlink\" title=\"2. 正则表达式对象\"></a>2. 正则表达式对象</h2><h3 id=\"2-1-属性\"><a href=\"#2-1-属性\" class=\"headerlink\" title=\"2.1 属性\"></a>2.1 属性</h3><p>正则表达式对象的属性主要有5个：</p>\n<ul>\n<li>与修饰符相关，都返回布尔值并且都是只读属性：<ul>\n<li>ignoreCase：表示是否设置了i修饰符</li>\n<li>global：表示是否设置了g修饰符</li>\n<li>multiline：表示是否设置m修饰符</li>\n</ul>\n</li>\n<li>与修饰符无关：<ul>\n<li>lastIndex：返回下一次开始搜索的位置，<strong>且只在设置了g修饰符时才有意义</strong>。</li>\n<li>source：返回正则表达式相应的字符串形式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-方法（正则表达式）\"><a href=\"#2-2-方法（正则表达式）\" class=\"headerlink\" title=\"2.2 方法（正则表达式）\"></a>2.2 方法（正则表达式）</h3><ul>\n<li><p><code>test()</code></p>\n<ul>\n<li>test接收一个字符串用于验证该字符串能否被匹配，结果返回布尔值。</li>\n<li>若正则表达式字符串为空，则能匹配所有字符串。</li>\n</ul>\n</li>\n<li><p><code>exec()</code></p>\n<ul>\n<li>exec接收一个字符串并且以数组的形式返回匹配结果，含有每一个匹配成功的子字符串，若匹配失败则返回null。</li>\n<li>返回的数组含有两个属性：<ul>\n<li><code>input</code>：表示原字符串</li>\n<li><code>index</code>：表示模式匹配成功的开始位置</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-方法（字符串）\"><a href=\"#2-3-方法（字符串）\" class=\"headerlink\" title=\"2.3 方法（字符串）\"></a>2.3 方法（字符串）</h3><ul>\n<li>match()：返回一个数组，成员是所有匹配的子字符串。<ul>\n<li>该方法与正则表达式的<code>exec</code>方法类似</li>\n<li>如果正则表达式带有<code>g</code>修饰符，该方法会返回所有匹配的结果，而<code>exec</code>则不会。</li>\n<li>设置<code>lastIndex</code>属性对其无效。</li>\n</ul>\n</li>\n<li>search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。若不匹配则返回-1.（<strong>忽略g修饰符和lastIndex属性</strong>）。</li>\n<li>replace()：按照给定的正则表达式进行替换，返回替换后的字符串。<ul>\n<li>有两个参数，第一个是搜索的模式，第二个是替换的内容。</li>\n<li>搜索模式如果不加g修饰符，则替换第一个匹配的结果，否则替换所有的匹配结果。</li>\n<li>该方法的第二个参数可以使用<code>$</code>来指代所替换的内容。<ul>\n<li><code>$&amp;</code> 指代匹配的子字符串。</li>\n<li><code>$\\</code> 指代匹配结果前面的文本。</li>\n<li><code>$&#39;</code> 指代匹配结果后面的文本。</li>\n<li><code>$n</code> 指代匹配成功的第n组内容，n是从1开始的自然数。</li>\n<li><code>$$</code> 指代美元符号$。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>\n</ul>\n<h3 id=\"2-4-匹配规则\"><a href=\"#2-4-匹配规则\" class=\"headerlink\" title=\"2.4 匹配规则\"></a>2.4 匹配规则</h3><ul>\n<li>字面量字符：字符直接表示其字面的含义，如/a/、/word/。</li>\n<li>元字符：表示特殊含义<ul>\n<li><code>.</code>字符<ul>\n<li>能匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。</li>\n<li>但是只能匹配一个字符。</li>\n</ul>\n</li>\n<li>位置字符<ul>\n<li><code>^</code>字符：表示字符串的开始位置</li>\n<li><code>$</code>字符：表示字符串的结束位置</li>\n</ul>\n</li>\n<li>选择符<ul>\n<li><code>|</code>字符：表示关系”或“。<strong>会包括前后的多个字符</strong><ul>\n<li>重复类：用于精确设置匹配次数，使用<code>{}</code>表示。<code>{n}</code>表示重复n次，<code>{n,}</code>表示不少于n次，<code>{m,n}</code>表示重复m~n次。<strong>只匹配前一个字符</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>量词符：用于设置模式匹配的次数，同样只匹配前一个字符：<ul>\n<li><code>?</code>等同于<code>{0,1}</code></li>\n<li><code>*</code>等同于<code>{0,}</code></li>\n<li><code>+</code>等同于<code>{1,}</code></li>\n</ul>\n</li>\n<li>贪婪模式：匹配到下一个字符不满足匹配规则为止。<ul>\n<li>所有的量词符后面加上<code>?</code>即可变为非贪婪模式。</li>\n</ul>\n</li>\n<li>字符类：表示一系列字符中只要匹配一个就可以，所有可供选择的字符都放在方括号中。如<code>[abc]</code>：表示匹配a、b、c三个字母中的任意一个。<ul>\n<li>脱字符（^）<ul>\n<li><code>[^abc]</code>：表示除了abc外所有字符都可以匹配。</li>\n<li><code>[^]</code>可以匹配所有字符，比<code>.</code>匹配更强。</li>\n<li><code>^</code>字符只有在字符类的第一个位置才有意义，否则直接就是字面含义。</li>\n</ul>\n</li>\n<li>连字符（-）<ul>\n<li>对于连续序列的字符可用（-）来简写。</li>\n<li><code>[a-z]</code>表示所有的小写字母。</li>\n<li><code>-</code>字符若不在方括号之中则代表字面含义。</li>\n<li>并且连字符必须在头尾两个字符之间才有特殊含义，否则只是字面含义。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>转义符<ul>\n<li>在正则表达式中有些特殊含义的字符，如果要匹配它们本身则需要在前面加上反斜杠。</li>\n<li>正则表达式中需要斜杠转义的一共有以下12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\\\\</code>。</li>\n<li>注意若是通过RegExp构造函数生成正则对象，转义时需要使用双斜杠<code>\\\\</code>，因为字符串内部会先转义一次。</li>\n</ul>\n</li>\n<li>修饰符<ul>\n<li><code>g</code>修饰符<ul>\n<li>默认情况下，第一次匹配成功之后正则表达式就停止匹配，若有g修饰符则会匹配所有符合条件的结果，主要用于搜索和替换。</li>\n</ul>\n</li>\n<li><code>i</code>修饰符<ul>\n<li>表示忽略大小写。</li>\n</ul>\n</li>\n<li><code>m</code>修饰符<ul>\n<li>表示多行模式，会修改<code>^</code>、<code>$</code>的行为，这两个字符默认情况下是作为位置字符来匹配字符串的开始和结束位置。当加上m修饰符时会匹配行首和行尾，即会识别换行符（\\n）。</li>\n<li><code>/^bc/m.test(&quot;a\\nbc&quot;)</code>返回true。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>预定义模式：指常见模式的一些简写方式<ul>\n<li><code>\\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>\n<li><code>\\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>\n<li><code>\\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>\n<li><code>\\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>\n<li><code>\\s</code> 匹配空格（包括制表符、空格符、断行符等），相等于<code>[\\t\\r\\n\\v\\f]</code>。</li>\n<li><code>\\S</code> 匹配非空格的字符，相当于<code>[^\\t\\r\\n\\v\\f]</code>。</li>\n<li><code>\\b</code> 匹配词的边界，即该词单独存在。</li>\n<li><code>\\B</code> 匹配非词边界，即在词的内部。</li>\n</ul>\n</li>\n<li><p>特殊字符：正则表达式中表示一些不能打印的字符。</p>\n<blockquote>\n<p>\\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。<br>  [\\b] 匹配退格键(U+0008)，不要与\\b混淆。<br>  \\n 匹配换行键。<br>  \\r 匹配回车键。<br>  \\t 匹配制表符tab（U+0009）。<br>  \\v 匹配垂直制表符（U+000B）。<br>  \\f 匹配换页符（U+000C）。<br>  \\0 匹配null字符（U+0000）。<br>  \\xhh 匹配一个以两位十六进制数表示的字符。<br>  \\uhhhh 匹配一个以四位十六进制数表示的unicode字符。</p>\n</blockquote>\n</li>\n<li><p>组匹配</p>\n<ul>\n<li>正则表达式中通过括号表示分组匹配。</li>\n<li>使用组匹配时不宜同时使用g修饰符，否则match方法不会捕获分组内容。如：<code>&quot;abcabc&quot;.match(/(.)b(.)/);//返回[&#39;abc&#39;, &#39;a&#39;, &#39;c&#39;]</code>而<code>&quot;abcabc&quot;.march(/(.)b(.)/g)返回[&#39;abc&#39;, &#39;abc&#39;]</code>。</li>\n<li>组匹配中通过<code>\\数字</code>可以引用括号匹配的内容。如：<code>/(.)b(.)\\1\\2/.test(&#39;abcabc&#39;) // \\1表示第一个括号匹配结果即a， \\2表示第二个括号匹配结果即c</code>。</li>\n</ul>\n</li>\n<li>非捕获组<ul>\n<li><code>(?:x)</code>表示不返回该组匹配的内容，为了不占用组匹配。</li>\n<li>如：<code>&quot;abc&quot;.match(/(?:.)b(.)/)</code>返回[“abc”, “c”]。</li>\n</ul>\n</li>\n<li>先行断言<ul>\n<li><code>x(?=y)</code>表示x只有在y的前面才匹配，并且匹配结果中不会将y计入。</li>\n<li>如：<code>&quot;abc&quot;.match(/b(?=c)/);</code>返回[“b”]。</li>\n</ul>\n</li>\n<li>先行否定断言<ul>\n<li>x只有不在y前面才会匹配。</li>\n</ul>\n</li>\n</ul>\n","excerpt":"<p>正则表达式常用作检索、匹配或者替换文本，它是一种文本模式匹配的方法，在我们对复杂文本进行操作时，使用正则表达式会极大的简化我们的操作。本文将介绍正则表达式对象和匹配规则。<br>","more":"</p>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>正则表达式是一种表示文本模式的方法，常用于匹配文本，例如email地址的验证等等，js中的正则表达式是Perl 5的子集。</p>\n<p>正则表达式有两种写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/abc/</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"abc\"</span>);</div></pre></td></tr></table></figure>\n<p>上述两种写法的主要区别在于新建正则表达式的时间，前者是在编译时完成，后者则是在运行时完成。</p>\n<h2 id=\"2-正则表达式对象\"><a href=\"#2-正则表达式对象\" class=\"headerlink\" title=\"2. 正则表达式对象\"></a>2. 正则表达式对象</h2><h3 id=\"2-1-属性\"><a href=\"#2-1-属性\" class=\"headerlink\" title=\"2.1 属性\"></a>2.1 属性</h3><p>正则表达式对象的属性主要有5个：</p>\n<ul>\n<li>与修饰符相关，都返回布尔值并且都是只读属性：<ul>\n<li>ignoreCase：表示是否设置了i修饰符</li>\n<li>global：表示是否设置了g修饰符</li>\n<li>multiline：表示是否设置m修饰符</li>\n</ul>\n</li>\n<li>与修饰符无关：<ul>\n<li>lastIndex：返回下一次开始搜索的位置，<strong>且只在设置了g修饰符时才有意义</strong>。</li>\n<li>source：返回正则表达式相应的字符串形式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-方法（正则表达式）\"><a href=\"#2-2-方法（正则表达式）\" class=\"headerlink\" title=\"2.2 方法（正则表达式）\"></a>2.2 方法（正则表达式）</h3><ul>\n<li><p><code>test()</code></p>\n<ul>\n<li>test接收一个字符串用于验证该字符串能否被匹配，结果返回布尔值。</li>\n<li>若正则表达式字符串为空，则能匹配所有字符串。</li>\n</ul>\n</li>\n<li><p><code>exec()</code></p>\n<ul>\n<li>exec接收一个字符串并且以数组的形式返回匹配结果，含有每一个匹配成功的子字符串，若匹配失败则返回null。</li>\n<li>返回的数组含有两个属性：<ul>\n<li><code>input</code>：表示原字符串</li>\n<li><code>index</code>：表示模式匹配成功的开始位置</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-方法（字符串）\"><a href=\"#2-3-方法（字符串）\" class=\"headerlink\" title=\"2.3 方法（字符串）\"></a>2.3 方法（字符串）</h3><ul>\n<li>match()：返回一个数组，成员是所有匹配的子字符串。<ul>\n<li>该方法与正则表达式的<code>exec</code>方法类似</li>\n<li>如果正则表达式带有<code>g</code>修饰符，该方法会返回所有匹配的结果，而<code>exec</code>则不会。</li>\n<li>设置<code>lastIndex</code>属性对其无效。</li>\n</ul>\n</li>\n<li>search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。若不匹配则返回-1.（<strong>忽略g修饰符和lastIndex属性</strong>）。</li>\n<li>replace()：按照给定的正则表达式进行替换，返回替换后的字符串。<ul>\n<li>有两个参数，第一个是搜索的模式，第二个是替换的内容。</li>\n<li>搜索模式如果不加g修饰符，则替换第一个匹配的结果，否则替换所有的匹配结果。</li>\n<li>该方法的第二个参数可以使用<code>$</code>来指代所替换的内容。<ul>\n<li><code>$&amp;</code> 指代匹配的子字符串。</li>\n<li><code>$\\</code> 指代匹配结果前面的文本。</li>\n<li><code>$&#39;</code> 指代匹配结果后面的文本。</li>\n<li><code>$n</code> 指代匹配成功的第n组内容，n是从1开始的自然数。</li>\n<li><code>$$</code> 指代美元符号$。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>\n</ul>\n<h3 id=\"2-4-匹配规则\"><a href=\"#2-4-匹配规则\" class=\"headerlink\" title=\"2.4 匹配规则\"></a>2.4 匹配规则</h3><ul>\n<li>字面量字符：字符直接表示其字面的含义，如/a/、/word/。</li>\n<li>元字符：表示特殊含义<ul>\n<li><code>.</code>字符<ul>\n<li>能匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。</li>\n<li>但是只能匹配一个字符。</li>\n</ul>\n</li>\n<li>位置字符<ul>\n<li><code>^</code>字符：表示字符串的开始位置</li>\n<li><code>$</code>字符：表示字符串的结束位置</li>\n</ul>\n</li>\n<li>选择符<ul>\n<li><code>|</code>字符：表示关系”或“。<strong>会包括前后的多个字符</strong><ul>\n<li>重复类：用于精确设置匹配次数，使用<code>{}</code>表示。<code>{n}</code>表示重复n次，<code>{n,}</code>表示不少于n次，<code>{m,n}</code>表示重复m~n次。<strong>只匹配前一个字符</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>量词符：用于设置模式匹配的次数，同样只匹配前一个字符：<ul>\n<li><code>?</code>等同于<code>{0,1}</code></li>\n<li><code>*</code>等同于<code>{0,}</code></li>\n<li><code>+</code>等同于<code>{1,}</code></li>\n</ul>\n</li>\n<li>贪婪模式：匹配到下一个字符不满足匹配规则为止。<ul>\n<li>所有的量词符后面加上<code>?</code>即可变为非贪婪模式。</li>\n</ul>\n</li>\n<li>字符类：表示一系列字符中只要匹配一个就可以，所有可供选择的字符都放在方括号中。如<code>[abc]</code>：表示匹配a、b、c三个字母中的任意一个。<ul>\n<li>脱字符（^）<ul>\n<li><code>[^abc]</code>：表示除了abc外所有字符都可以匹配。</li>\n<li><code>[^]</code>可以匹配所有字符，比<code>.</code>匹配更强。</li>\n<li><code>^</code>字符只有在字符类的第一个位置才有意义，否则直接就是字面含义。</li>\n</ul>\n</li>\n<li>连字符（-）<ul>\n<li>对于连续序列的字符可用（-）来简写。</li>\n<li><code>[a-z]</code>表示所有的小写字母。</li>\n<li><code>-</code>字符若不在方括号之中则代表字面含义。</li>\n<li>并且连字符必须在头尾两个字符之间才有特殊含义，否则只是字面含义。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>转义符<ul>\n<li>在正则表达式中有些特殊含义的字符，如果要匹配它们本身则需要在前面加上反斜杠。</li>\n<li>正则表达式中需要斜杠转义的一共有以下12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\\\\</code>。</li>\n<li>注意若是通过RegExp构造函数生成正则对象，转义时需要使用双斜杠<code>\\\\</code>，因为字符串内部会先转义一次。</li>\n</ul>\n</li>\n<li>修饰符<ul>\n<li><code>g</code>修饰符<ul>\n<li>默认情况下，第一次匹配成功之后正则表达式就停止匹配，若有g修饰符则会匹配所有符合条件的结果，主要用于搜索和替换。</li>\n</ul>\n</li>\n<li><code>i</code>修饰符<ul>\n<li>表示忽略大小写。</li>\n</ul>\n</li>\n<li><code>m</code>修饰符<ul>\n<li>表示多行模式，会修改<code>^</code>、<code>$</code>的行为，这两个字符默认情况下是作为位置字符来匹配字符串的开始和结束位置。当加上m修饰符时会匹配行首和行尾，即会识别换行符（\\n）。</li>\n<li><code>/^bc/m.test(&quot;a\\nbc&quot;)</code>返回true。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>预定义模式：指常见模式的一些简写方式<ul>\n<li><code>\\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>\n<li><code>\\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>\n<li><code>\\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>\n<li><code>\\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>\n<li><code>\\s</code> 匹配空格（包括制表符、空格符、断行符等），相等于<code>[\\t\\r\\n\\v\\f]</code>。</li>\n<li><code>\\S</code> 匹配非空格的字符，相当于<code>[^\\t\\r\\n\\v\\f]</code>。</li>\n<li><code>\\b</code> 匹配词的边界，即该词单独存在。</li>\n<li><code>\\B</code> 匹配非词边界，即在词的内部。</li>\n</ul>\n</li>\n<li><p>特殊字符：正则表达式中表示一些不能打印的字符。</p>\n<blockquote>\n<p>\\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。<br>  [\\b] 匹配退格键(U+0008)，不要与\\b混淆。<br>  \\n 匹配换行键。<br>  \\r 匹配回车键。<br>  \\t 匹配制表符tab（U+0009）。<br>  \\v 匹配垂直制表符（U+000B）。<br>  \\f 匹配换页符（U+000C）。<br>  \\0 匹配null字符（U+0000）。<br>  \\xhh 匹配一个以两位十六进制数表示的字符。<br>  \\uhhhh 匹配一个以四位十六进制数表示的unicode字符。</p>\n</blockquote>\n</li>\n<li><p>组匹配</p>\n<ul>\n<li>正则表达式中通过括号表示分组匹配。</li>\n<li>使用组匹配时不宜同时使用g修饰符，否则match方法不会捕获分组内容。如：<code>&quot;abcabc&quot;.match(/(.)b(.)/);//返回[&#39;abc&#39;, &#39;a&#39;, &#39;c&#39;]</code>而<code>&quot;abcabc&quot;.march(/(.)b(.)/g)返回[&#39;abc&#39;, &#39;abc&#39;]</code>。</li>\n<li>组匹配中通过<code>\\数字</code>可以引用括号匹配的内容。如：<code>/(.)b(.)\\1\\2/.test(&#39;abcabc&#39;) // \\1表示第一个括号匹配结果即a， \\2表示第二个括号匹配结果即c</code>。</li>\n</ul>\n</li>\n<li>非捕获组<ul>\n<li><code>(?:x)</code>表示不返回该组匹配的内容，为了不占用组匹配。</li>\n<li>如：<code>&quot;abc&quot;.match(/(?:.)b(.)/)</code>返回[“abc”, “c”]。</li>\n</ul>\n</li>\n<li>先行断言<ul>\n<li><code>x(?=y)</code>表示x只有在y的前面才匹配，并且匹配结果中不会将y计入。</li>\n<li>如：<code>&quot;abc&quot;.match(/b(?=c)/);</code>返回[“b”]。</li>\n</ul>\n</li>\n<li>先行否定断言<ul>\n<li>x只有不在y前面才会匹配。</li>\n</ul>\n</li>\n</ul>"},{"title":"javascript学习笔记","date":"2016-03-03T16:00:00.000Z","folder":"web/js","en-title":"js-study-notes","_content":"本文是对《javascript权威指南》这本书中的知识点的总结。\n<!-- more -->\n\n## 1. 词法结构\n\n* js标识符必须以字母、下划线（`_`）或美元符（`$`）开始，后续字符可以是字母、数字、下划线或美元符。\n* 当缺少分号时，js并不是在所有换行处填补分号，而是在缺少分号就无法正确解析代码的时候才会填补分号。但有两个例外：\n    * 当`return`、`break`和`continue`语句后面紧接着换行时，js会在换行处添加分号。\n    * 当涉及到`++`和`--`符号时，若运算符作为后缀使用，应和表达式在同一行，若此时换行，js会在行尾填补分号，运算符会作为下一行代码的前缀运算符。\n\n## 2. 类型、值和变量\n\n* 对象、数组属于可变类型，数字、字符串、布尔值、`null`和`undefined`属于不可变类型。\n* 任意js的值都可以转换为布尔值。`undefined`、`null`、`0`、`-0`、`NaN`、`\"\"`会转化成`false`，其他值都会转换成`true`。\n* `null`是一种特殊的对象。`undefined`属于`undefined`类型，变量没有初始化，当查询的对象或数组的属性或元素不存在，如果函数没有返回任何值，引用没有提供实参的函数形参的值都会返回`undefined`。`undefined`是预定义的全局变量，不是关键字。`==`会认为两者相等，`.`和`[]`对两者进行操作时都会产生类型错误。若想将他们赋值给变量、属性或作为参数传入函数建议使用`null`。\n* 不在任何函数内的js代码可以使用关键字`this`来引用全局对象。\n* 在读取字符串、数字和布尔值的属性值时，表现的像对象一样。但如果你给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未被保留下来。\n* 对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，他们也是不相等的。\n* `x + \"\"`等价于`String(x)`，`+x`等价于`Number(x)`，`!!x`等价于`Boolean(x)`。\n* `+`、`==`、`!=`和关系运算符是唯一执行特殊字符串到原始值的转换方式的运算符。\n* 使用`var`语句重复声明变量是合法无害的。若给未声明的变量赋值，js会给全局对象创建一个同名属性。\n* 函数体内，局部变量的优先级高于同名的全局变量。\n* js使用了函数作用域，即在函数内声明的所有变量在函数体内始终是可见的。声明提前：js函数内声明的所有变量都（不包含赋值）被提前至函数体的顶部。\n* 词法作用域：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。\n\n## 3. 表达式和运算符\n\n* 如果表达式后跟一对方括号，则会计算方括号内的表达式的值并将它转换为字符串。只有当属性名称是合法的标识符并且需要知道要访问的属性名时，才能使用`.`来访问属性。\n* 如果函数使用`return`给出一个返回值时，这个返回值就是该表达式的值，否则表达式的值就是`undefined`。\n* 如果对象创建表达式不需要传入任何参数给构造函数的话，那么空圆括号是可以省略的。\n* 构造函数一般不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果该构造函数返回了一个对象值（只能是对象），那么该对象则作为整个表达式的值，而构造函数中新创建的对象就废弃了。\n* js中子表达式的计算过程中的运算顺序不同于运算符的优先级和结合性规定的运算顺序。js总是严格按照从左至右的顺序来计算表达式的。如计算式\n\n    ```\n    var a = 1;\n    var b = (a++) + a;\n    ```\n\n    1. 计算b\n    2. 计算a++（结果记为c），之后a的值增1\n    3. 计算a\n    4. 计算c+a（此时a为2）\n    5. 将结果赋值给b\n\n* 所有无法转换为数字的操作数都转化为`NaN`，若有操作数为`NaN`，此时计算结果也为`NaN`。\n* 求余运算中余数的符号和被除数的符号保持一致。\n* 当`+`与字符串和数字一起使用时，应考虑加法的结合性对运算的影响。\n\n    ```\n    var a = 1 + 2 + \"hello\";//\"3hello\"\n    var b = 1 + (2 + \"hello\");//\"12hello\"\n    ```\n* 位运算符的操作数为整数，且为32位整型，若不是则会强制转换。\n    * 左移（<<）新的一位会用0来补充\n    * 右移（>>）新的一位由操作数的符号决定，正数补0，负数补1。\n    * 无符号右移（>>>）新的一位总是补0.\n* 只有数字和字符串才能真正执行比较操作，除此之外的都将进行类型转换。如果一个操作数是（或转换之后是）`NaN`，则比较结果总为`false`。字符串比较中大写字母总是小于小写字母。\n* in运算符：如果右侧的对象有一个名为左侧操作数的属性名，那么表达式返回`true`。\n* instanceof运算符：左操作数是对象，右操作数是对象的类。若左操作数不是对象，则返回`false`，若右操作数不是函数，则抛出类型错误异常。\n* `&&` 和 `||`的“短路”性质，可用于简写代码：\n\n    ```javascript\n    if (a == b) {\n        stop();\n    }\n\n    (a == b) && stop();\n    ```\n* 带操作符的赋值运算中需要注意：表达式`a op= b`和`a = a op b`的不同点，当a中含有具有副作用的表达式时，两者是不同的。如：\n\n    ```javascript\n    var data = [1, 2 ,3];\n    var i = 0;\n    //data[i++] *= 2;\n    //data[i++] = data[i++] * 2;\n    两者计算结果不同，第一个data = [2, 2, 3]，第二个data = [4, 2, 3]\n    ```\n* `typeof`运算符返回表示操作数类型的字符串，可将数组和对象与函数区分开。\n* `delete`运算符用来删除对象属性或数组元素，删除属性时该属性在对象中不再存在，删除数组元素时，其对应值变为`undefined`。但通过`var`声明的变量和定义的函数都不能被删除。\n* `void`运算符：操作数会照常计算但是忽略计算结果并返回`undefined`。常用于url中。\n\n## 4. 语句\n\n* 全局变量是全局对象的属性，然而和其他全局变量的属性不同的是，var声明的变量是无法通过delete删除的。\n* 函数声明语句和函数定义表达式的不同点：\n    * 函数定义语句中的函数名称和函数体均被显式的提前到脚本或函数的顶部，因此他们在整个脚本和函数内都是可见的。\n    * 使用var声明的函数表达式中只有变量声明被提前了，变量的初始化代码仍在原来的位置。\n* `default`标签可以放在`switch`语句的任何位置，并不会影响结果。\n* `while(true)`和`for(;;)`都表示死循环。\n\n## 5. 对象\n\n* 如果变量x是指向一个对象的引用，那么执行代码`var y = x;变量y也是指向同一个对象的引用，而非这个对象的副本。通过变量y修改这个对象同样会对变量x的值造成影响。\n* 对象的属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。同时属性名也可以是标识符，但若属性名含有非法字符或是关键字则需要带上引号。\n* 用`.`操作对象时，右侧必须是一个以属性名命名的标识符。用`[]`操作对象时，方括号内的表达式必须返回一个字符串或者可以转换为字符串的值。\n* 若要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x，如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者找到一个原型是null的对象为止。\n* 若给对象o的属性x赋值，如果o中已经有了属性x，那么这个赋值操作只改变这个已有属性x的值；如果o中不存在属性x，那么赋值操作给o添加了新属性x；如果之前o继承了属性x，那么这个继承的属性就被新创建的同名属性覆盖了。\n* `delete`只是断开属性和宿主对象的联系，只能删除自有属性而不能删除继承属性，若一定要删除则只能从定义这个属性的原型对象上删除。（但这会影响到所有继承自这个原型的对象）\n* `in`运算符可检测是否含有自有属性和继承属性，`hasOwnProperty`只能检测是否含有自由属性。\n* 可通过`o.x !== undefined`判断是否含有某种属性，效果等同于in运算符。（但此种方法不能区分存在但值为undefined的属性）\n* for/in循环可以遍历对象中所有可枚举的自有属性和继承属性，但不能枚举继承的内置方法。\n* `Object.keys()`返回可枚举的自有属性，`Object.getOwnPropertyNames()`返回所有自有属性。\n* 存取器属性`getter`和`setter`。\n* `Object.getOwnPropertyDescriptor(Object, attributeName)`获得某个对象特定自有属性的属性描述符。\n* `Object.defineProperty(Object, attributeName, descriptorObject)`可以设置属性的特性。\n* 通过对象直接量创建的对象使用`Object.prototype`作为它的原型，通过new创建的对象使用构造函数的prototype属性作为它的原型，通过`Object.create()`创建的对象使用第一个参数作为它的原型。\n* `Object.getPrototypeOf()`可以查询对象的原型。\n* `ObjectA.isPrototypeOf(ObjectB)`检测对象A是否是对象B的原型。\n* 对象的可扩展性表示是否可以给对象添加新属性。`Object.isExtensible()`判断对象是否可扩展；`ObjectPreventExtensions()`将对象转换为不可扩展的，此时再无法将对象转换回可扩展的了，同时这样做只能影响到对象本身的可扩展性，若给一个不可扩展的对象的原型添加属性，则该对象同样会继承这个新属性。\n\n## 6. 数组\n\n* js数组可以是稀疏的，数组元素的索引不一定要连续，他们之间可以有空缺，对于每一个数组都有`length`属性，针对非稀疏数组，该属性就是数组元素的个数，而对于稀疏数组，该属性值比所有元素的索引都要大。\n* 数组直接量的语法允许有可选的结尾的逗号，因此`var a = [, ,]`含有两个`undefined`值而非三个。\n* 数组的索引是**0~2^32-2**之间的整数。\n* 因为数组是对象，因此可以为其创建任意名字的属性，但是如果属性名是数组的索引，数组就会更新它的length属性值。\n* 可以使用负数或者非整数作为数组的索引，此时数值将转换为字符串来作为属性名使用，此时只能作为属性名而非数组索引。同样，如果使用了非负整数的字符串作为数组索引，它就会直接作为数组索引而非对象的属性值。当使用浮点数作为索引时，若浮点数与一个整数相等则同样方式处理。\n* 关于`length`属性：\n    * 如果为一个数组元素赋值，它的索引 **i** 大于或等于现有数组的长度时，length的属性值将设置为 **i+1**\n    * 若设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除。\n\n## 7. 函数\n\n* 函数的定义可以通过函数声明或者函数定义表达式。通过函数声明的方法定义的函数，其名称是必需的部分，函数声明实际上声明了一个变量并把一个函数赋值给它。通过函数定义表达式的方式定义的函数，其名称是可选的，如果它包含名称，函数的局部作用域将会包含一个绑定到该函数对象的名称，函数的名称将成为函数内部的一个局部变量，在比如函数需要递归的情况下是很有用的。\n* 函数声明语句被提前到外部脚本或外部函数作用域的顶部，所以这种方式声明的函数可以被在它定义之前出现的代码所调用。要调用以表达式定义的函数则需要将函数赋值给一个变量，变量的声明会提前但是变量的赋值是不会提前的。\n* 函数声明语句不能出现在循环、条件判断、或者try/catch/finally以及with语句中。函数定义表达式则不受限制。\n* 普通的函数调用中（无论该函数声明是在脚本中还是函数内）的上下文`this`指的是全局对象（严格模式中是undefined），而方法调用中则指的是调用该方法的对象。\n* 构造函数调用创建一个新的空对象，这个对象继承自构造函数的prototype属性，构造函数会试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数中的this指的是这个新创建的对象。\n* 构造函数通常不使用`return`返回值，因为构造函数会显式返回初始化的新对象，如果使用了return返回一个对象，则调用构造函数返回的就是这个对象，若return返回的是其他值则会忽略该返回值。\n* 在函数体内标识符`arguments`是指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标来访问传入函数的实参值。\n* `arguments`和形参指的是同一个值，修改任意一个值都会影响到另一个。\n* 函数不仅是一种语法也是值。\n* 闭包的实现和理解，词法作用域。\n* `call()`方法和`apply()`方法可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。对于call函数来说，第一个调用上下文参数之后的所有参数都是要传入的待调用函数的实参；而apply方法则将实参都放入一个数组当中。两种方法的第一个参数都是一个要调用该函数的对象，该函数中的`this`则指向这个对象。如：\n\n    ```javascript\n    function add(y) {\n        return this.x + y;\n    }\n    var a = {x: 1};\n    add.call(a, 2)//返回3\n    ```\n\n* `bind()`方法将函数绑定至某个对象，并返回一个新的函数。如：\n\n    ```\n    function f(y) {\n        return this.x + y;\n    }\n    var a = {x: 1};\n    var g = f.bind(a);\n    g(2)//返回3\n    上述过程相当于\n    a = {x: 1, f: function(y) {return this.x + y}};\n    g = a.f;\n    ```\n\n* 通过`Function()`构造的函数不使用词法作用域，它的作用域是全局作用域。\n* js在函数式编程中的使用。\n\n## 8. 类和模块\n\n* 定义构造函数即是定义类，因此构造函数名的首字母要大写，而普通的函数和方法名首字母都是小写。\n* 构造函数不必用`return`返回值，当通过`new`关键字来创建新对象时会自动返回该对象。其原型对象的名字为`ClassName.prototype`，这是一个强制命名，通过该构造函数创建的新对象会自动使用该原型对象作为新创建的对象的原型。\n* **原型对象是类的唯一标识**，当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例，而初始化该对象的构造函数则不能作为类的标识，两个构造函数的prototype可能指向同一个原型对象，那么这两个构造函数创建的实例是属于同一个类的。\n* `a instanceof A`并不会检查a是否是由A()构造函数初始化而来，而是检查a是否继承自A.prototype。\n* 在希望用到字符串的地方用到对象的话，js会自动调用`toString`方法，如果没有实现这个方法，类会默认从`Object.prototype`中继承这个方法。\n* 代码的模块化很重要，模块是一个独立的js文件，模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码。\n* 所有模块都尽量定义不超过一个全局变量。\n* 创建模块的过程中，避免污染全局变量的一种方法是使用一个对象作为命名空间。\n\n## 9. 正则表达式的模式匹配\n\n正则表达式部分在我的另一篇博客中有介绍到：[javascri正则表达式]()\n\n## 10. web浏览器中的javascript\n\n* 在html文档里嵌入客户端javascript代码有四种方法：\n    * 内联方式，放置在`<script></script>`标签对之间。\n    * 放置在`<script>`标签的src属性指定的外部文件中。\n    * 放置在html事件处理程序中，如放入onclick的属性值中。\n    * 放在url中，该url使用特殊的\"javascript:\"协议。\n\n* 当使用`src`属性时，`<script></script>`之间的任何内容都会忽略。\n* `script`标记中type属性默认值为\"text/javascript\"，如果没有指定，则使用默认值。若指定的类型是一个不可执行的类型，则不会从该url中下载任何东西。\n* 可以通过`<a href=\"javascript: void doSomethingHere;\">`来执行某些操作并且不会修改当前页面文档。\n* 脚本和事件处理程序在同一时间只能执行一个，没有并发性。\n* javascript的时间线。\n\n## 11. Window对象\n\n* 它是客户端js的全局对象。\n* `Location`对象的`assign()`和`replace()`方法都可以使窗口载入一个指定的url中的文档，后者在载入新文档之前会将当前文档从浏览历史中删除，此时后退操作无效。\n* `Location`对象的`reload()`方法可以让浏览器重新载入当前文档。\n* 直接将url赋值给`location`属性。\n* 片段标识符不会使浏览器载入新的文档，它只会使它滚动到文档中的某个位置。`#id`会使浏览器跳到元素id对应的位置。`#top`如果没有元素id为top的话，则浏览器会跳到文档的开始处。\n* `history`属性包含浏览器的浏览历史信息。\n* `navigator`属性包含浏览器厂商和版本信息。\n* `screen`属性包含窗口大小和可用颜色信息。\n* 浏览器会为了防止广告的弹出而禁用`window.open()`方法，只有当用户手动点击按钮或者链接的时候才会调用。\n* 如果正在事件处理程序中调用`close()`方法，则应指明是Window对象还是Document对象的close方法。\n* 即使一个窗口已经关闭，但是代表它的Window对象仍然存在，它的document会使null，它的方法也不会工作。\n* Window对象的open()方法会返回新创建的窗口的Window对象，而该对象的opener属性则指向打开该窗口的原始窗口的Window对象。\n* 窗体是用`<iframe>`元素创建的，窗体或窗口之间可以互相嵌套，可通过`parent`引用父窗口或窗体的window对象，`top`则可直接引用顶级窗口对象。若获取了iframe元素，可通过`contentWindow`属性获取该窗体的window对象，相反可通过window对象的`frameElement`得到对应的元素。另外，Window对象中还有frames属性可以得到自身包含的子窗口或窗体的引用，frames属性引用的是类数组对象，数组中的元素是Window对象而不是iframe元素，当访问子窗体时也可通过iframe元素的name或id属性来访问。\n\n## 12. 脚本化文档\n\n* `Document`对象表示窗口的内容。\n* 在html的树形结构中，树形的根部是`Document`节点，代表整个文档，代表html元素的是`Element`节点，代表文本的是`Text`节点。这三种节点都是Node的子类。\n* html的`name`属性最初是为了表单元素分配名字，在表单数据提交到服务器时使用该属性的值。name属性的值在html文档中不必唯一，并且该属性仅在表单、表单元素、iframe和img这些元素中有效。（**对于IE浏览器，通过`getElementById()`和`getElementsByName()`均会返回包含对应id和name的元素，因此不应将同样的字符串用作id和name的值**）\n* `document.documentElement`指代文档的根元素，`document.head`和`document.body`分别指代head和body元素。\n* `NodeList`和`HTMLCollection`都是类数组对象，因此不能直接使用Array的方法，但可以通过call和apply来间接调用。\n* `querySelectorAll()`方法是通过css选择器的方式来匹配元素，但是其返回值并不是实时的，不会随着文档的变化而更新。`querySelector()`则是返回匹配的第一个元素。\n* html中的属性名不区分大小写，但是js中的属性名则大小写敏感。因此html中的属性名在js中全部转换为小写，如果属性名包含不只一个单词，则除第一个单词外其余单词的首字母均大写。另外，有些html属性名在js中是保留字，对于这些属性一般是在属性名前加**html**前缀，例如，`for`转换为`htmlFor`，但对于`class`属性则例外，它转换为`className`。\n* 表示html属性的值通常是字符串，但当html属性为布尔值或数字时，js中的属性也是布尔值或者数字。\n* HTML5提供任意以`data-`为前缀的小写的属性名而在元素上绑定一些额外的信息。同时定义了Element对象的dataset属性，该对象的属性对应于上述含前缀的属性。\n* `createElement()`和`createTextNode()`分别用于创建Element节点和Text节点。\n* 如果通过`appendChild()`和`insertBefore()`方法将文档中已经存在的节点插入到文档中，那个节点将会从它当前的位置删除并在新的位置重新插入。\n* `window.pageXOffset`、`window.pageYOffset`、`document.documentElement.scrollTop`、`document.documentElement.scrollLeft`都可以得到滚动条的位置信息。\n* `window.innerWidth`、`window.innerHeight`、`document.documentElement.clientWidth`、`document.documentElement.clientHeight`都可以得到视口的尺寸信息。\n* `getBoundingClientRect()`、`getClientRects()`可以得到一个元素的尺寸和位置。\n\n## 13. 脚本化css\n\n* style属性中的样式覆盖了样式表中的样式，而且文档的样式表中的样式覆盖了浏览器的默认样式。\n* 对于`absolute`和`fixed`定位，可以通过left和right或top和bottom来设置长和宽，若通过含有width或height，则相应的right和bottom将失效。\n* `z-index`属性只对兄弟元素应用堆叠效果。\n* `z-index`属性不适用于非定位元素，但对于非定位元素，它的值为0。\n* 对于定位元素，left和top属性指定了从容器边框内侧到定位元素边框外侧的距离。\n* 如果css属性名包含多个连字符，在js中应将连字符移除并将每个连字符后紧接着的字母大写。如果css属性名在js中属于保留字，则应在该属性名前加上\"css\"前缀，如\"cssFloat\"。\n* 通过js操作元素的style属性时，所有的值都是字符串，并且对于定位属性，其单位也要写上。\n\n## 14. 事件处理\n\n* `event`对象被当作参数传给事件处理函数，该对象的`type`属性确定了事件的类型，`target`属性确定了触发事件的对象。\n* 当按下键盘按键重复产生字符时，在`keyup`事件之前会产生多个`keypress`事件，该事件对象指定的是产生的字符，而不是按键。\n* `addEventListener()`能为同一个对象注册同一事件类型的多个处理程序函数，当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。\n* 使用相同的参数在同一对象上多次调用`addEventListener()`是没用的，处理程序仍然只注册一次，同时重复调用也不会改变调用处理程序的顺序。\n* 对于IE9之前不支持`addEventListener()`、`removeEventListener()`但支持类似的方法，`attachEvent()`和`detachEvent()`。两种方法类似但是存在以下几点不同：\n    * 只有两个参数\n    * 第一个参数使用了带\"on\"前缀的事件处理程序名字字符串。\n    * 当给同一对象注册多个同一事件处理程序，事件发生时，会多次触发事件处理程序。\n    * 通过这种方式注册的事件处理程序中的this指的是全局对象，而其他方式指的是目标对象。\n* 事件的调用顺序：\n    * 通过设置对象属性或html属性注册的处理程序优先调用。\n    * 通过`addEventListener()`注册的处理程序按照它们的注册顺序调用。\n    * 使用`attachEvent()`注册的处理程序可能按照任何顺序调用，代码不应依赖于调用顺序。\n\n## 15. 脚本化http\n* http请求的顺序是：先是请求方法和url，然后是请求头，最后是请求主体。\n\n## 16. jquery类库\n\n* this指的是原生文档参数，而不是jquery对象，若想使用jquery方法，则应该写成`$(this)`。\n* jquery中使用同一个方法既当setter又当getter使用，用作setter时，这些方法会给jquery对象中的每一个元素设置值，当作为getter使用时，这些方法只会查询jquery对象中的第一个元素并给它设置值。\n* `css()`方法返回的是当前样式，即计算样式，该返回值既可能来自style属性也可能来自样式表。\n* `css()`方法不能获取复合样式，但是可以设置复合样式的值，其中的样式名既可以用连字符也可以用驼峰格式。\n* `css()`方法在获取样式值时，会把数值转换成带有单位后缀的字符串返回，在设置样式值时，则会将数值转换成字符串并在必要时添加\"px\"后缀。\n* `offset()`方法返回元素的绝对位置，用相对于文档的坐标来表示。`position()`方法返回相对于元素的`offsetParent()`的偏移量。\n* 获取元素的尺寸可以使用以下几种方法:\n    * `width()`、`height()`返回内容的宽度和高度。\n    * `innerWidth()`、`innerHeight()`返回包含内边距的宽度和高度。\n    * `outerWidth()`、`outerHeight()`返回包含边框的宽度和高度\n    * 若对第三种方法传入参数`true`则返回的是包含元素外边距的宽度和高度。\n* 如果插入的元素已经是文档的一部分，这些元素只会简单的移动而不是复制到新位置。\n* jquery动画只支持数值属性。\n\n## 17. 客户端存储\n\n* 浏览器目前只支持存储字符串类型数据，若要存取其他类型的数据，需要手动进行编码和解码。\n\n## 18. 多媒体和图形编程\n\n* 通过`Image()`构造函数来创建一个图片对象，并将其`src`属性设置为相应的图片的url，这样由于图片元素并没有被添加到文档中，因此它是不可见的，但是浏览器会加载图片并将其缓存起来。当其他部分需要使用到该图片时便可直接从浏览器缓存中获取。\n* 对于音频元素，可通过`new Audio(\"url\")`来构造一个对象，但视频元素没有类似的构造函数。\n* 在用`canvas`绘制图形时，当完成一条路径要绘制另一条路径前应使用`beginPath()`方法，如果没有使用该方法，那么添加的所有子路径都是处于当前路径上，使用`stroke()`和`fill()`方法时会作用在当前路径上的所有子路径。可能会导致重复绘制。\n* 非零绕数原则：判断一个点是否在路径的内部。\n* 每个`canvas`元素只有一个上下文对象，就算多次调用`getContext()`方法也会返回相同的上下文对象。\n* 线段宽度是由`lineWidth`属性和当前坐标系变换决定的，与其他创建路径的方法无关。\n* 文本对齐`textAlign`属性中，属性值`start`和`end`跟文本的方向有关，若文本是从左到右的则`start`和`left`是相同的，否则则相反。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/js-study-notes.md","raw":"title: javascript学习笔记\n\ncategories:\n- Web开发\n- JS\ntags:\n- Web开发\n- JS\n\ndate: 2016/03/04\nfolder: web/js\nen-title: js-study-notes\n---\n本文是对《javascript权威指南》这本书中的知识点的总结。\n<!-- more -->\n\n## 1. 词法结构\n\n* js标识符必须以字母、下划线（`_`）或美元符（`$`）开始，后续字符可以是字母、数字、下划线或美元符。\n* 当缺少分号时，js并不是在所有换行处填补分号，而是在缺少分号就无法正确解析代码的时候才会填补分号。但有两个例外：\n    * 当`return`、`break`和`continue`语句后面紧接着换行时，js会在换行处添加分号。\n    * 当涉及到`++`和`--`符号时，若运算符作为后缀使用，应和表达式在同一行，若此时换行，js会在行尾填补分号，运算符会作为下一行代码的前缀运算符。\n\n## 2. 类型、值和变量\n\n* 对象、数组属于可变类型，数字、字符串、布尔值、`null`和`undefined`属于不可变类型。\n* 任意js的值都可以转换为布尔值。`undefined`、`null`、`0`、`-0`、`NaN`、`\"\"`会转化成`false`，其他值都会转换成`true`。\n* `null`是一种特殊的对象。`undefined`属于`undefined`类型，变量没有初始化，当查询的对象或数组的属性或元素不存在，如果函数没有返回任何值，引用没有提供实参的函数形参的值都会返回`undefined`。`undefined`是预定义的全局变量，不是关键字。`==`会认为两者相等，`.`和`[]`对两者进行操作时都会产生类型错误。若想将他们赋值给变量、属性或作为参数传入函数建议使用`null`。\n* 不在任何函数内的js代码可以使用关键字`this`来引用全局对象。\n* 在读取字符串、数字和布尔值的属性值时，表现的像对象一样。但如果你给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未被保留下来。\n* 对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，他们也是不相等的。\n* `x + \"\"`等价于`String(x)`，`+x`等价于`Number(x)`，`!!x`等价于`Boolean(x)`。\n* `+`、`==`、`!=`和关系运算符是唯一执行特殊字符串到原始值的转换方式的运算符。\n* 使用`var`语句重复声明变量是合法无害的。若给未声明的变量赋值，js会给全局对象创建一个同名属性。\n* 函数体内，局部变量的优先级高于同名的全局变量。\n* js使用了函数作用域，即在函数内声明的所有变量在函数体内始终是可见的。声明提前：js函数内声明的所有变量都（不包含赋值）被提前至函数体的顶部。\n* 词法作用域：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。\n\n## 3. 表达式和运算符\n\n* 如果表达式后跟一对方括号，则会计算方括号内的表达式的值并将它转换为字符串。只有当属性名称是合法的标识符并且需要知道要访问的属性名时，才能使用`.`来访问属性。\n* 如果函数使用`return`给出一个返回值时，这个返回值就是该表达式的值，否则表达式的值就是`undefined`。\n* 如果对象创建表达式不需要传入任何参数给构造函数的话，那么空圆括号是可以省略的。\n* 构造函数一般不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果该构造函数返回了一个对象值（只能是对象），那么该对象则作为整个表达式的值，而构造函数中新创建的对象就废弃了。\n* js中子表达式的计算过程中的运算顺序不同于运算符的优先级和结合性规定的运算顺序。js总是严格按照从左至右的顺序来计算表达式的。如计算式\n\n    ```\n    var a = 1;\n    var b = (a++) + a;\n    ```\n\n    1. 计算b\n    2. 计算a++（结果记为c），之后a的值增1\n    3. 计算a\n    4. 计算c+a（此时a为2）\n    5. 将结果赋值给b\n\n* 所有无法转换为数字的操作数都转化为`NaN`，若有操作数为`NaN`，此时计算结果也为`NaN`。\n* 求余运算中余数的符号和被除数的符号保持一致。\n* 当`+`与字符串和数字一起使用时，应考虑加法的结合性对运算的影响。\n\n    ```\n    var a = 1 + 2 + \"hello\";//\"3hello\"\n    var b = 1 + (2 + \"hello\");//\"12hello\"\n    ```\n* 位运算符的操作数为整数，且为32位整型，若不是则会强制转换。\n    * 左移（<<）新的一位会用0来补充\n    * 右移（>>）新的一位由操作数的符号决定，正数补0，负数补1。\n    * 无符号右移（>>>）新的一位总是补0.\n* 只有数字和字符串才能真正执行比较操作，除此之外的都将进行类型转换。如果一个操作数是（或转换之后是）`NaN`，则比较结果总为`false`。字符串比较中大写字母总是小于小写字母。\n* in运算符：如果右侧的对象有一个名为左侧操作数的属性名，那么表达式返回`true`。\n* instanceof运算符：左操作数是对象，右操作数是对象的类。若左操作数不是对象，则返回`false`，若右操作数不是函数，则抛出类型错误异常。\n* `&&` 和 `||`的“短路”性质，可用于简写代码：\n\n    ```javascript\n    if (a == b) {\n        stop();\n    }\n\n    (a == b) && stop();\n    ```\n* 带操作符的赋值运算中需要注意：表达式`a op= b`和`a = a op b`的不同点，当a中含有具有副作用的表达式时，两者是不同的。如：\n\n    ```javascript\n    var data = [1, 2 ,3];\n    var i = 0;\n    //data[i++] *= 2;\n    //data[i++] = data[i++] * 2;\n    两者计算结果不同，第一个data = [2, 2, 3]，第二个data = [4, 2, 3]\n    ```\n* `typeof`运算符返回表示操作数类型的字符串，可将数组和对象与函数区分开。\n* `delete`运算符用来删除对象属性或数组元素，删除属性时该属性在对象中不再存在，删除数组元素时，其对应值变为`undefined`。但通过`var`声明的变量和定义的函数都不能被删除。\n* `void`运算符：操作数会照常计算但是忽略计算结果并返回`undefined`。常用于url中。\n\n## 4. 语句\n\n* 全局变量是全局对象的属性，然而和其他全局变量的属性不同的是，var声明的变量是无法通过delete删除的。\n* 函数声明语句和函数定义表达式的不同点：\n    * 函数定义语句中的函数名称和函数体均被显式的提前到脚本或函数的顶部，因此他们在整个脚本和函数内都是可见的。\n    * 使用var声明的函数表达式中只有变量声明被提前了，变量的初始化代码仍在原来的位置。\n* `default`标签可以放在`switch`语句的任何位置，并不会影响结果。\n* `while(true)`和`for(;;)`都表示死循环。\n\n## 5. 对象\n\n* 如果变量x是指向一个对象的引用，那么执行代码`var y = x;变量y也是指向同一个对象的引用，而非这个对象的副本。通过变量y修改这个对象同样会对变量x的值造成影响。\n* 对象的属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。同时属性名也可以是标识符，但若属性名含有非法字符或是关键字则需要带上引号。\n* 用`.`操作对象时，右侧必须是一个以属性名命名的标识符。用`[]`操作对象时，方括号内的表达式必须返回一个字符串或者可以转换为字符串的值。\n* 若要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x，如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者找到一个原型是null的对象为止。\n* 若给对象o的属性x赋值，如果o中已经有了属性x，那么这个赋值操作只改变这个已有属性x的值；如果o中不存在属性x，那么赋值操作给o添加了新属性x；如果之前o继承了属性x，那么这个继承的属性就被新创建的同名属性覆盖了。\n* `delete`只是断开属性和宿主对象的联系，只能删除自有属性而不能删除继承属性，若一定要删除则只能从定义这个属性的原型对象上删除。（但这会影响到所有继承自这个原型的对象）\n* `in`运算符可检测是否含有自有属性和继承属性，`hasOwnProperty`只能检测是否含有自由属性。\n* 可通过`o.x !== undefined`判断是否含有某种属性，效果等同于in运算符。（但此种方法不能区分存在但值为undefined的属性）\n* for/in循环可以遍历对象中所有可枚举的自有属性和继承属性，但不能枚举继承的内置方法。\n* `Object.keys()`返回可枚举的自有属性，`Object.getOwnPropertyNames()`返回所有自有属性。\n* 存取器属性`getter`和`setter`。\n* `Object.getOwnPropertyDescriptor(Object, attributeName)`获得某个对象特定自有属性的属性描述符。\n* `Object.defineProperty(Object, attributeName, descriptorObject)`可以设置属性的特性。\n* 通过对象直接量创建的对象使用`Object.prototype`作为它的原型，通过new创建的对象使用构造函数的prototype属性作为它的原型，通过`Object.create()`创建的对象使用第一个参数作为它的原型。\n* `Object.getPrototypeOf()`可以查询对象的原型。\n* `ObjectA.isPrototypeOf(ObjectB)`检测对象A是否是对象B的原型。\n* 对象的可扩展性表示是否可以给对象添加新属性。`Object.isExtensible()`判断对象是否可扩展；`ObjectPreventExtensions()`将对象转换为不可扩展的，此时再无法将对象转换回可扩展的了，同时这样做只能影响到对象本身的可扩展性，若给一个不可扩展的对象的原型添加属性，则该对象同样会继承这个新属性。\n\n## 6. 数组\n\n* js数组可以是稀疏的，数组元素的索引不一定要连续，他们之间可以有空缺，对于每一个数组都有`length`属性，针对非稀疏数组，该属性就是数组元素的个数，而对于稀疏数组，该属性值比所有元素的索引都要大。\n* 数组直接量的语法允许有可选的结尾的逗号，因此`var a = [, ,]`含有两个`undefined`值而非三个。\n* 数组的索引是**0~2^32-2**之间的整数。\n* 因为数组是对象，因此可以为其创建任意名字的属性，但是如果属性名是数组的索引，数组就会更新它的length属性值。\n* 可以使用负数或者非整数作为数组的索引，此时数值将转换为字符串来作为属性名使用，此时只能作为属性名而非数组索引。同样，如果使用了非负整数的字符串作为数组索引，它就会直接作为数组索引而非对象的属性值。当使用浮点数作为索引时，若浮点数与一个整数相等则同样方式处理。\n* 关于`length`属性：\n    * 如果为一个数组元素赋值，它的索引 **i** 大于或等于现有数组的长度时，length的属性值将设置为 **i+1**\n    * 若设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除。\n\n## 7. 函数\n\n* 函数的定义可以通过函数声明或者函数定义表达式。通过函数声明的方法定义的函数，其名称是必需的部分，函数声明实际上声明了一个变量并把一个函数赋值给它。通过函数定义表达式的方式定义的函数，其名称是可选的，如果它包含名称，函数的局部作用域将会包含一个绑定到该函数对象的名称，函数的名称将成为函数内部的一个局部变量，在比如函数需要递归的情况下是很有用的。\n* 函数声明语句被提前到外部脚本或外部函数作用域的顶部，所以这种方式声明的函数可以被在它定义之前出现的代码所调用。要调用以表达式定义的函数则需要将函数赋值给一个变量，变量的声明会提前但是变量的赋值是不会提前的。\n* 函数声明语句不能出现在循环、条件判断、或者try/catch/finally以及with语句中。函数定义表达式则不受限制。\n* 普通的函数调用中（无论该函数声明是在脚本中还是函数内）的上下文`this`指的是全局对象（严格模式中是undefined），而方法调用中则指的是调用该方法的对象。\n* 构造函数调用创建一个新的空对象，这个对象继承自构造函数的prototype属性，构造函数会试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数中的this指的是这个新创建的对象。\n* 构造函数通常不使用`return`返回值，因为构造函数会显式返回初始化的新对象，如果使用了return返回一个对象，则调用构造函数返回的就是这个对象，若return返回的是其他值则会忽略该返回值。\n* 在函数体内标识符`arguments`是指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标来访问传入函数的实参值。\n* `arguments`和形参指的是同一个值，修改任意一个值都会影响到另一个。\n* 函数不仅是一种语法也是值。\n* 闭包的实现和理解，词法作用域。\n* `call()`方法和`apply()`方法可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。对于call函数来说，第一个调用上下文参数之后的所有参数都是要传入的待调用函数的实参；而apply方法则将实参都放入一个数组当中。两种方法的第一个参数都是一个要调用该函数的对象，该函数中的`this`则指向这个对象。如：\n\n    ```javascript\n    function add(y) {\n        return this.x + y;\n    }\n    var a = {x: 1};\n    add.call(a, 2)//返回3\n    ```\n\n* `bind()`方法将函数绑定至某个对象，并返回一个新的函数。如：\n\n    ```\n    function f(y) {\n        return this.x + y;\n    }\n    var a = {x: 1};\n    var g = f.bind(a);\n    g(2)//返回3\n    上述过程相当于\n    a = {x: 1, f: function(y) {return this.x + y}};\n    g = a.f;\n    ```\n\n* 通过`Function()`构造的函数不使用词法作用域，它的作用域是全局作用域。\n* js在函数式编程中的使用。\n\n## 8. 类和模块\n\n* 定义构造函数即是定义类，因此构造函数名的首字母要大写，而普通的函数和方法名首字母都是小写。\n* 构造函数不必用`return`返回值，当通过`new`关键字来创建新对象时会自动返回该对象。其原型对象的名字为`ClassName.prototype`，这是一个强制命名，通过该构造函数创建的新对象会自动使用该原型对象作为新创建的对象的原型。\n* **原型对象是类的唯一标识**，当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例，而初始化该对象的构造函数则不能作为类的标识，两个构造函数的prototype可能指向同一个原型对象，那么这两个构造函数创建的实例是属于同一个类的。\n* `a instanceof A`并不会检查a是否是由A()构造函数初始化而来，而是检查a是否继承自A.prototype。\n* 在希望用到字符串的地方用到对象的话，js会自动调用`toString`方法，如果没有实现这个方法，类会默认从`Object.prototype`中继承这个方法。\n* 代码的模块化很重要，模块是一个独立的js文件，模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码。\n* 所有模块都尽量定义不超过一个全局变量。\n* 创建模块的过程中，避免污染全局变量的一种方法是使用一个对象作为命名空间。\n\n## 9. 正则表达式的模式匹配\n\n正则表达式部分在我的另一篇博客中有介绍到：[javascri正则表达式]()\n\n## 10. web浏览器中的javascript\n\n* 在html文档里嵌入客户端javascript代码有四种方法：\n    * 内联方式，放置在`<script></script>`标签对之间。\n    * 放置在`<script>`标签的src属性指定的外部文件中。\n    * 放置在html事件处理程序中，如放入onclick的属性值中。\n    * 放在url中，该url使用特殊的\"javascript:\"协议。\n\n* 当使用`src`属性时，`<script></script>`之间的任何内容都会忽略。\n* `script`标记中type属性默认值为\"text/javascript\"，如果没有指定，则使用默认值。若指定的类型是一个不可执行的类型，则不会从该url中下载任何东西。\n* 可以通过`<a href=\"javascript: void doSomethingHere;\">`来执行某些操作并且不会修改当前页面文档。\n* 脚本和事件处理程序在同一时间只能执行一个，没有并发性。\n* javascript的时间线。\n\n## 11. Window对象\n\n* 它是客户端js的全局对象。\n* `Location`对象的`assign()`和`replace()`方法都可以使窗口载入一个指定的url中的文档，后者在载入新文档之前会将当前文档从浏览历史中删除，此时后退操作无效。\n* `Location`对象的`reload()`方法可以让浏览器重新载入当前文档。\n* 直接将url赋值给`location`属性。\n* 片段标识符不会使浏览器载入新的文档，它只会使它滚动到文档中的某个位置。`#id`会使浏览器跳到元素id对应的位置。`#top`如果没有元素id为top的话，则浏览器会跳到文档的开始处。\n* `history`属性包含浏览器的浏览历史信息。\n* `navigator`属性包含浏览器厂商和版本信息。\n* `screen`属性包含窗口大小和可用颜色信息。\n* 浏览器会为了防止广告的弹出而禁用`window.open()`方法，只有当用户手动点击按钮或者链接的时候才会调用。\n* 如果正在事件处理程序中调用`close()`方法，则应指明是Window对象还是Document对象的close方法。\n* 即使一个窗口已经关闭，但是代表它的Window对象仍然存在，它的document会使null，它的方法也不会工作。\n* Window对象的open()方法会返回新创建的窗口的Window对象，而该对象的opener属性则指向打开该窗口的原始窗口的Window对象。\n* 窗体是用`<iframe>`元素创建的，窗体或窗口之间可以互相嵌套，可通过`parent`引用父窗口或窗体的window对象，`top`则可直接引用顶级窗口对象。若获取了iframe元素，可通过`contentWindow`属性获取该窗体的window对象，相反可通过window对象的`frameElement`得到对应的元素。另外，Window对象中还有frames属性可以得到自身包含的子窗口或窗体的引用，frames属性引用的是类数组对象，数组中的元素是Window对象而不是iframe元素，当访问子窗体时也可通过iframe元素的name或id属性来访问。\n\n## 12. 脚本化文档\n\n* `Document`对象表示窗口的内容。\n* 在html的树形结构中，树形的根部是`Document`节点，代表整个文档，代表html元素的是`Element`节点，代表文本的是`Text`节点。这三种节点都是Node的子类。\n* html的`name`属性最初是为了表单元素分配名字，在表单数据提交到服务器时使用该属性的值。name属性的值在html文档中不必唯一，并且该属性仅在表单、表单元素、iframe和img这些元素中有效。（**对于IE浏览器，通过`getElementById()`和`getElementsByName()`均会返回包含对应id和name的元素，因此不应将同样的字符串用作id和name的值**）\n* `document.documentElement`指代文档的根元素，`document.head`和`document.body`分别指代head和body元素。\n* `NodeList`和`HTMLCollection`都是类数组对象，因此不能直接使用Array的方法，但可以通过call和apply来间接调用。\n* `querySelectorAll()`方法是通过css选择器的方式来匹配元素，但是其返回值并不是实时的，不会随着文档的变化而更新。`querySelector()`则是返回匹配的第一个元素。\n* html中的属性名不区分大小写，但是js中的属性名则大小写敏感。因此html中的属性名在js中全部转换为小写，如果属性名包含不只一个单词，则除第一个单词外其余单词的首字母均大写。另外，有些html属性名在js中是保留字，对于这些属性一般是在属性名前加**html**前缀，例如，`for`转换为`htmlFor`，但对于`class`属性则例外，它转换为`className`。\n* 表示html属性的值通常是字符串，但当html属性为布尔值或数字时，js中的属性也是布尔值或者数字。\n* HTML5提供任意以`data-`为前缀的小写的属性名而在元素上绑定一些额外的信息。同时定义了Element对象的dataset属性，该对象的属性对应于上述含前缀的属性。\n* `createElement()`和`createTextNode()`分别用于创建Element节点和Text节点。\n* 如果通过`appendChild()`和`insertBefore()`方法将文档中已经存在的节点插入到文档中，那个节点将会从它当前的位置删除并在新的位置重新插入。\n* `window.pageXOffset`、`window.pageYOffset`、`document.documentElement.scrollTop`、`document.documentElement.scrollLeft`都可以得到滚动条的位置信息。\n* `window.innerWidth`、`window.innerHeight`、`document.documentElement.clientWidth`、`document.documentElement.clientHeight`都可以得到视口的尺寸信息。\n* `getBoundingClientRect()`、`getClientRects()`可以得到一个元素的尺寸和位置。\n\n## 13. 脚本化css\n\n* style属性中的样式覆盖了样式表中的样式，而且文档的样式表中的样式覆盖了浏览器的默认样式。\n* 对于`absolute`和`fixed`定位，可以通过left和right或top和bottom来设置长和宽，若通过含有width或height，则相应的right和bottom将失效。\n* `z-index`属性只对兄弟元素应用堆叠效果。\n* `z-index`属性不适用于非定位元素，但对于非定位元素，它的值为0。\n* 对于定位元素，left和top属性指定了从容器边框内侧到定位元素边框外侧的距离。\n* 如果css属性名包含多个连字符，在js中应将连字符移除并将每个连字符后紧接着的字母大写。如果css属性名在js中属于保留字，则应在该属性名前加上\"css\"前缀，如\"cssFloat\"。\n* 通过js操作元素的style属性时，所有的值都是字符串，并且对于定位属性，其单位也要写上。\n\n## 14. 事件处理\n\n* `event`对象被当作参数传给事件处理函数，该对象的`type`属性确定了事件的类型，`target`属性确定了触发事件的对象。\n* 当按下键盘按键重复产生字符时，在`keyup`事件之前会产生多个`keypress`事件，该事件对象指定的是产生的字符，而不是按键。\n* `addEventListener()`能为同一个对象注册同一事件类型的多个处理程序函数，当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。\n* 使用相同的参数在同一对象上多次调用`addEventListener()`是没用的，处理程序仍然只注册一次，同时重复调用也不会改变调用处理程序的顺序。\n* 对于IE9之前不支持`addEventListener()`、`removeEventListener()`但支持类似的方法，`attachEvent()`和`detachEvent()`。两种方法类似但是存在以下几点不同：\n    * 只有两个参数\n    * 第一个参数使用了带\"on\"前缀的事件处理程序名字字符串。\n    * 当给同一对象注册多个同一事件处理程序，事件发生时，会多次触发事件处理程序。\n    * 通过这种方式注册的事件处理程序中的this指的是全局对象，而其他方式指的是目标对象。\n* 事件的调用顺序：\n    * 通过设置对象属性或html属性注册的处理程序优先调用。\n    * 通过`addEventListener()`注册的处理程序按照它们的注册顺序调用。\n    * 使用`attachEvent()`注册的处理程序可能按照任何顺序调用，代码不应依赖于调用顺序。\n\n## 15. 脚本化http\n* http请求的顺序是：先是请求方法和url，然后是请求头，最后是请求主体。\n\n## 16. jquery类库\n\n* this指的是原生文档参数，而不是jquery对象，若想使用jquery方法，则应该写成`$(this)`。\n* jquery中使用同一个方法既当setter又当getter使用，用作setter时，这些方法会给jquery对象中的每一个元素设置值，当作为getter使用时，这些方法只会查询jquery对象中的第一个元素并给它设置值。\n* `css()`方法返回的是当前样式，即计算样式，该返回值既可能来自style属性也可能来自样式表。\n* `css()`方法不能获取复合样式，但是可以设置复合样式的值，其中的样式名既可以用连字符也可以用驼峰格式。\n* `css()`方法在获取样式值时，会把数值转换成带有单位后缀的字符串返回，在设置样式值时，则会将数值转换成字符串并在必要时添加\"px\"后缀。\n* `offset()`方法返回元素的绝对位置，用相对于文档的坐标来表示。`position()`方法返回相对于元素的`offsetParent()`的偏移量。\n* 获取元素的尺寸可以使用以下几种方法:\n    * `width()`、`height()`返回内容的宽度和高度。\n    * `innerWidth()`、`innerHeight()`返回包含内边距的宽度和高度。\n    * `outerWidth()`、`outerHeight()`返回包含边框的宽度和高度\n    * 若对第三种方法传入参数`true`则返回的是包含元素外边距的宽度和高度。\n* 如果插入的元素已经是文档的一部分，这些元素只会简单的移动而不是复制到新位置。\n* jquery动画只支持数值属性。\n\n## 17. 客户端存储\n\n* 浏览器目前只支持存储字符串类型数据，若要存取其他类型的数据，需要手动进行编码和解码。\n\n## 18. 多媒体和图形编程\n\n* 通过`Image()`构造函数来创建一个图片对象，并将其`src`属性设置为相应的图片的url，这样由于图片元素并没有被添加到文档中，因此它是不可见的，但是浏览器会加载图片并将其缓存起来。当其他部分需要使用到该图片时便可直接从浏览器缓存中获取。\n* 对于音频元素，可通过`new Audio(\"url\")`来构造一个对象，但视频元素没有类似的构造函数。\n* 在用`canvas`绘制图形时，当完成一条路径要绘制另一条路径前应使用`beginPath()`方法，如果没有使用该方法，那么添加的所有子路径都是处于当前路径上，使用`stroke()`和`fill()`方法时会作用在当前路径上的所有子路径。可能会导致重复绘制。\n* 非零绕数原则：判断一个点是否在路径的内部。\n* 每个`canvas`元素只有一个上下文对象，就算多次调用`getContext()`方法也会返回相同的上下文对象。\n* 线段宽度是由`lineWidth`属性和当前坐标系变换决定的，与其他创建路径的方法无关。\n* 文本对齐`textAlign`属性中，属性值`start`和`end`跟文本的方向有关，若文本是从左到右的则`start`和`left`是相同的，否则则相反。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"js-study-notes","published":1,"updated":"2016-08-19T10:13:15.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis1me2dy0007no74g65rz5lv","content":"<p>本文是对《javascript权威指南》这本书中的知识点的总结。<br><a id=\"more\"></a></p>\n<h2 id=\"1-词法结构\"><a href=\"#1-词法结构\" class=\"headerlink\" title=\"1. 词法结构\"></a>1. 词法结构</h2><ul>\n<li>js标识符必须以字母、下划线（<code>_</code>）或美元符（<code>$</code>）开始，后续字符可以是字母、数字、下划线或美元符。</li>\n<li>当缺少分号时，js并不是在所有换行处填补分号，而是在缺少分号就无法正确解析代码的时候才会填补分号。但有两个例外：<ul>\n<li>当<code>return</code>、<code>break</code>和<code>continue</code>语句后面紧接着换行时，js会在换行处添加分号。</li>\n<li>当涉及到<code>++</code>和<code>--</code>符号时，若运算符作为后缀使用，应和表达式在同一行，若此时换行，js会在行尾填补分号，运算符会作为下一行代码的前缀运算符。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-类型、值和变量\"><a href=\"#2-类型、值和变量\" class=\"headerlink\" title=\"2. 类型、值和变量\"></a>2. 类型、值和变量</h2><ul>\n<li>对象、数组属于可变类型，数字、字符串、布尔值、<code>null</code>和<code>undefined</code>属于不可变类型。</li>\n<li>任意js的值都可以转换为布尔值。<code>undefined</code>、<code>null</code>、<code>0</code>、<code>-0</code>、<code>NaN</code>、<code>&quot;&quot;</code>会转化成<code>false</code>，其他值都会转换成<code>true</code>。</li>\n<li><code>null</code>是一种特殊的对象。<code>undefined</code>属于<code>undefined</code>类型，变量没有初始化，当查询的对象或数组的属性或元素不存在，如果函数没有返回任何值，引用没有提供实参的函数形参的值都会返回<code>undefined</code>。<code>undefined</code>是预定义的全局变量，不是关键字。<code>==</code>会认为两者相等，<code>.</code>和<code>[]</code>对两者进行操作时都会产生类型错误。若想将他们赋值给变量、属性或作为参数传入函数建议使用<code>null</code>。</li>\n<li>不在任何函数内的js代码可以使用关键字<code>this</code>来引用全局对象。</li>\n<li>在读取字符串、数字和布尔值的属性值时，表现的像对象一样。但如果你给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未被保留下来。</li>\n<li>对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，他们也是不相等的。</li>\n<li><code>x + &quot;&quot;</code>等价于<code>String(x)</code>，<code>+x</code>等价于<code>Number(x)</code>，<code>!!x</code>等价于<code>Boolean(x)</code>。</li>\n<li><code>+</code>、<code>==</code>、<code>!=</code>和关系运算符是唯一执行特殊字符串到原始值的转换方式的运算符。</li>\n<li>使用<code>var</code>语句重复声明变量是合法无害的。若给未声明的变量赋值，js会给全局对象创建一个同名属性。</li>\n<li>函数体内，局部变量的优先级高于同名的全局变量。</li>\n<li>js使用了函数作用域，即在函数内声明的所有变量在函数体内始终是可见的。声明提前：js函数内声明的所有变量都（不包含赋值）被提前至函数体的顶部。</li>\n<li>词法作用域：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。</li>\n</ul>\n<h2 id=\"3-表达式和运算符\"><a href=\"#3-表达式和运算符\" class=\"headerlink\" title=\"3. 表达式和运算符\"></a>3. 表达式和运算符</h2><ul>\n<li>如果表达式后跟一对方括号，则会计算方括号内的表达式的值并将它转换为字符串。只有当属性名称是合法的标识符并且需要知道要访问的属性名时，才能使用<code>.</code>来访问属性。</li>\n<li>如果函数使用<code>return</code>给出一个返回值时，这个返回值就是该表达式的值，否则表达式的值就是<code>undefined</code>。</li>\n<li>如果对象创建表达式不需要传入任何参数给构造函数的话，那么空圆括号是可以省略的。</li>\n<li>构造函数一般不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果该构造函数返回了一个对象值（只能是对象），那么该对象则作为整个表达式的值，而构造函数中新创建的对象就废弃了。</li>\n<li><p>js中子表达式的计算过程中的运算顺序不同于运算符的优先级和结合性规定的运算顺序。js总是严格按照从左至右的顺序来计算表达式的。如计算式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1;</div><div class=\"line\">var b = (a++) + a;</div></pre></td></tr></table></figure>\n<ol>\n<li>计算b</li>\n<li>计算a++（结果记为c），之后a的值增1</li>\n<li>计算a</li>\n<li>计算c+a（此时a为2）</li>\n<li>将结果赋值给b</li>\n</ol>\n</li>\n<li><p>所有无法转换为数字的操作数都转化为<code>NaN</code>，若有操作数为<code>NaN</code>，此时计算结果也为<code>NaN</code>。</p>\n</li>\n<li>求余运算中余数的符号和被除数的符号保持一致。</li>\n<li><p>当<code>+</code>与字符串和数字一起使用时，应考虑加法的结合性对运算的影响。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1 + 2 + &quot;hello&quot;;//&quot;3hello&quot;</div><div class=\"line\">var b = 1 + (2 + &quot;hello&quot;);//&quot;12hello&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>位运算符的操作数为整数，且为32位整型，若不是则会强制转换。</p>\n<ul>\n<li>左移（&lt;&lt;）新的一位会用0来补充</li>\n<li>右移（&gt;&gt;）新的一位由操作数的符号决定，正数补0，负数补1。</li>\n<li>无符号右移（&gt;&gt;&gt;）新的一位总是补0.</li>\n</ul>\n</li>\n<li>只有数字和字符串才能真正执行比较操作，除此之外的都将进行类型转换。如果一个操作数是（或转换之后是）<code>NaN</code>，则比较结果总为<code>false</code>。字符串比较中大写字母总是小于小写字母。</li>\n<li>in运算符：如果右侧的对象有一个名为左侧操作数的属性名，那么表达式返回<code>true</code>。</li>\n<li>instanceof运算符：左操作数是对象，右操作数是对象的类。若左操作数不是对象，则返回<code>false</code>，若右操作数不是函数，则抛出类型错误异常。</li>\n<li><p><code>&amp;&amp;</code> 和 <code>||</code>的“短路”性质，可用于简写代码：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == b) &#123;</div><div class=\"line\">    stop();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">(a == b) &amp;&amp; stop();</div></pre></td></tr></table></figure>\n</li>\n<li><p>带操作符的赋值运算中需要注意：表达式<code>a op= b</code>和<code>a = a op b</code>的不同点，当a中含有具有副作用的表达式时，两者是不同的。如：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = [<span class=\"number\">1</span>, <span class=\"number\">2</span> ,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"comment\">//data[i++] *= 2;</span></div><div class=\"line\"><span class=\"comment\">//data[i++] = data[i++] * 2;</span></div><div class=\"line\">两者计算结果不同，第一个data = [<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]，第二个data = [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>typeof</code>运算符返回表示操作数类型的字符串，可将数组和对象与函数区分开。</p>\n</li>\n<li><code>delete</code>运算符用来删除对象属性或数组元素，删除属性时该属性在对象中不再存在，删除数组元素时，其对应值变为<code>undefined</code>。但通过<code>var</code>声明的变量和定义的函数都不能被删除。</li>\n<li><code>void</code>运算符：操作数会照常计算但是忽略计算结果并返回<code>undefined</code>。常用于url中。</li>\n</ul>\n<h2 id=\"4-语句\"><a href=\"#4-语句\" class=\"headerlink\" title=\"4. 语句\"></a>4. 语句</h2><ul>\n<li>全局变量是全局对象的属性，然而和其他全局变量的属性不同的是，var声明的变量是无法通过delete删除的。</li>\n<li>函数声明语句和函数定义表达式的不同点：<ul>\n<li>函数定义语句中的函数名称和函数体均被显式的提前到脚本或函数的顶部，因此他们在整个脚本和函数内都是可见的。</li>\n<li>使用var声明的函数表达式中只有变量声明被提前了，变量的初始化代码仍在原来的位置。</li>\n</ul>\n</li>\n<li><code>default</code>标签可以放在<code>switch</code>语句的任何位置，并不会影响结果。</li>\n<li><code>while(true)</code>和<code>for(;;)</code>都表示死循环。</li>\n</ul>\n<h2 id=\"5-对象\"><a href=\"#5-对象\" class=\"headerlink\" title=\"5. 对象\"></a>5. 对象</h2><ul>\n<li>如果变量x是指向一个对象的引用，那么执行代码`var y = x;变量y也是指向同一个对象的引用，而非这个对象的副本。通过变量y修改这个对象同样会对变量x的值造成影响。</li>\n<li>对象的属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。同时属性名也可以是标识符，但若属性名含有非法字符或是关键字则需要带上引号。</li>\n<li>用<code>.</code>操作对象时，右侧必须是一个以属性名命名的标识符。用<code>[]</code>操作对象时，方括号内的表达式必须返回一个字符串或者可以转换为字符串的值。</li>\n<li>若要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x，如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者找到一个原型是null的对象为止。</li>\n<li>若给对象o的属性x赋值，如果o中已经有了属性x，那么这个赋值操作只改变这个已有属性x的值；如果o中不存在属性x，那么赋值操作给o添加了新属性x；如果之前o继承了属性x，那么这个继承的属性就被新创建的同名属性覆盖了。</li>\n<li><code>delete</code>只是断开属性和宿主对象的联系，只能删除自有属性而不能删除继承属性，若一定要删除则只能从定义这个属性的原型对象上删除。（但这会影响到所有继承自这个原型的对象）</li>\n<li><code>in</code>运算符可检测是否含有自有属性和继承属性，<code>hasOwnProperty</code>只能检测是否含有自由属性。</li>\n<li>可通过<code>o.x !== undefined</code>判断是否含有某种属性，效果等同于in运算符。（但此种方法不能区分存在但值为undefined的属性）</li>\n<li>for/in循环可以遍历对象中所有可枚举的自有属性和继承属性，但不能枚举继承的内置方法。</li>\n<li><code>Object.keys()</code>返回可枚举的自有属性，<code>Object.getOwnPropertyNames()</code>返回所有自有属性。</li>\n<li>存取器属性<code>getter</code>和<code>setter</code>。</li>\n<li><code>Object.getOwnPropertyDescriptor(Object, attributeName)</code>获得某个对象特定自有属性的属性描述符。</li>\n<li><code>Object.defineProperty(Object, attributeName, descriptorObject)</code>可以设置属性的特性。</li>\n<li>通过对象直接量创建的对象使用<code>Object.prototype</code>作为它的原型，通过new创建的对象使用构造函数的prototype属性作为它的原型，通过<code>Object.create()</code>创建的对象使用第一个参数作为它的原型。</li>\n<li><code>Object.getPrototypeOf()</code>可以查询对象的原型。</li>\n<li><code>ObjectA.isPrototypeOf(ObjectB)</code>检测对象A是否是对象B的原型。</li>\n<li>对象的可扩展性表示是否可以给对象添加新属性。<code>Object.isExtensible()</code>判断对象是否可扩展；<code>ObjectPreventExtensions()</code>将对象转换为不可扩展的，此时再无法将对象转换回可扩展的了，同时这样做只能影响到对象本身的可扩展性，若给一个不可扩展的对象的原型添加属性，则该对象同样会继承这个新属性。</li>\n</ul>\n<h2 id=\"6-数组\"><a href=\"#6-数组\" class=\"headerlink\" title=\"6. 数组\"></a>6. 数组</h2><ul>\n<li>js数组可以是稀疏的，数组元素的索引不一定要连续，他们之间可以有空缺，对于每一个数组都有<code>length</code>属性，针对非稀疏数组，该属性就是数组元素的个数，而对于稀疏数组，该属性值比所有元素的索引都要大。</li>\n<li>数组直接量的语法允许有可选的结尾的逗号，因此<code>var a = [, ,]</code>含有两个<code>undefined</code>值而非三个。</li>\n<li>数组的索引是<strong>0~2^32-2</strong>之间的整数。</li>\n<li>因为数组是对象，因此可以为其创建任意名字的属性，但是如果属性名是数组的索引，数组就会更新它的length属性值。</li>\n<li>可以使用负数或者非整数作为数组的索引，此时数值将转换为字符串来作为属性名使用，此时只能作为属性名而非数组索引。同样，如果使用了非负整数的字符串作为数组索引，它就会直接作为数组索引而非对象的属性值。当使用浮点数作为索引时，若浮点数与一个整数相等则同样方式处理。</li>\n<li>关于<code>length</code>属性：<ul>\n<li>如果为一个数组元素赋值，它的索引 <strong>i</strong> 大于或等于现有数组的长度时，length的属性值将设置为 <strong>i+1</strong></li>\n<li>若设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-函数\"><a href=\"#7-函数\" class=\"headerlink\" title=\"7. 函数\"></a>7. 函数</h2><ul>\n<li>函数的定义可以通过函数声明或者函数定义表达式。通过函数声明的方法定义的函数，其名称是必需的部分，函数声明实际上声明了一个变量并把一个函数赋值给它。通过函数定义表达式的方式定义的函数，其名称是可选的，如果它包含名称，函数的局部作用域将会包含一个绑定到该函数对象的名称，函数的名称将成为函数内部的一个局部变量，在比如函数需要递归的情况下是很有用的。</li>\n<li>函数声明语句被提前到外部脚本或外部函数作用域的顶部，所以这种方式声明的函数可以被在它定义之前出现的代码所调用。要调用以表达式定义的函数则需要将函数赋值给一个变量，变量的声明会提前但是变量的赋值是不会提前的。</li>\n<li>函数声明语句不能出现在循环、条件判断、或者try/catch/finally以及with语句中。函数定义表达式则不受限制。</li>\n<li>普通的函数调用中（无论该函数声明是在脚本中还是函数内）的上下文<code>this</code>指的是全局对象（严格模式中是undefined），而方法调用中则指的是调用该方法的对象。</li>\n<li>构造函数调用创建一个新的空对象，这个对象继承自构造函数的prototype属性，构造函数会试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数中的this指的是这个新创建的对象。</li>\n<li>构造函数通常不使用<code>return</code>返回值，因为构造函数会显式返回初始化的新对象，如果使用了return返回一个对象，则调用构造函数返回的就是这个对象，若return返回的是其他值则会忽略该返回值。</li>\n<li>在函数体内标识符<code>arguments</code>是指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标来访问传入函数的实参值。</li>\n<li><code>arguments</code>和形参指的是同一个值，修改任意一个值都会影响到另一个。</li>\n<li>函数不仅是一种语法也是值。</li>\n<li>闭包的实现和理解，词法作用域。</li>\n<li><p><code>call()</code>方法和<code>apply()</code>方法可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。对于call函数来说，第一个调用上下文参数之后的所有参数都是要传入的待调用函数的实参；而apply方法则将实参都放入一个数组当中。两种方法的第一个参数都是一个要调用该函数的对象，该函数中的<code>this</code>则指向这个对象。如：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;x: <span class=\"number\">1</span>&#125;;</div><div class=\"line\">add.call(a, <span class=\"number\">2</span>)<span class=\"comment\">//返回3</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind()</code>方法将函数绑定至某个对象，并返回一个新的函数。如：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f(y) &#123;</div><div class=\"line\">    return this.x + y;</div><div class=\"line\">&#125;</div><div class=\"line\">var a = &#123;x: 1&#125;;</div><div class=\"line\">var g = f.bind(a);</div><div class=\"line\">g(2)//返回3</div><div class=\"line\">上述过程相当于</div><div class=\"line\">a = &#123;x: 1, f: function(y) &#123;return this.x + y&#125;&#125;;</div><div class=\"line\">g = a.f;</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过<code>Function()</code>构造的函数不使用词法作用域，它的作用域是全局作用域。</p>\n</li>\n<li>js在函数式编程中的使用。</li>\n</ul>\n<h2 id=\"8-类和模块\"><a href=\"#8-类和模块\" class=\"headerlink\" title=\"8. 类和模块\"></a>8. 类和模块</h2><ul>\n<li>定义构造函数即是定义类，因此构造函数名的首字母要大写，而普通的函数和方法名首字母都是小写。</li>\n<li>构造函数不必用<code>return</code>返回值，当通过<code>new</code>关键字来创建新对象时会自动返回该对象。其原型对象的名字为<code>ClassName.prototype</code>，这是一个强制命名，通过该构造函数创建的新对象会自动使用该原型对象作为新创建的对象的原型。</li>\n<li><strong>原型对象是类的唯一标识</strong>，当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例，而初始化该对象的构造函数则不能作为类的标识，两个构造函数的prototype可能指向同一个原型对象，那么这两个构造函数创建的实例是属于同一个类的。</li>\n<li><code>a instanceof A</code>并不会检查a是否是由A()构造函数初始化而来，而是检查a是否继承自A.prototype。</li>\n<li>在希望用到字符串的地方用到对象的话，js会自动调用<code>toString</code>方法，如果没有实现这个方法，类会默认从<code>Object.prototype</code>中继承这个方法。</li>\n<li>代码的模块化很重要，模块是一个独立的js文件，模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码。</li>\n<li>所有模块都尽量定义不超过一个全局变量。</li>\n<li>创建模块的过程中，避免污染全局变量的一种方法是使用一个对象作为命名空间。</li>\n</ul>\n<h2 id=\"9-正则表达式的模式匹配\"><a href=\"#9-正则表达式的模式匹配\" class=\"headerlink\" title=\"9. 正则表达式的模式匹配\"></a>9. 正则表达式的模式匹配</h2><p>正则表达式部分在我的另一篇博客中有介绍到：<a href=\"\">javascri正则表达式</a></p>\n<h2 id=\"10-web浏览器中的javascript\"><a href=\"#10-web浏览器中的javascript\" class=\"headerlink\" title=\"10. web浏览器中的javascript\"></a>10. web浏览器中的javascript</h2><ul>\n<li><p>在html文档里嵌入客户端javascript代码有四种方法：</p>\n<ul>\n<li>内联方式，放置在<code>&lt;script&gt;&lt;/script&gt;</code>标签对之间。</li>\n<li>放置在<code>&lt;script&gt;</code>标签的src属性指定的外部文件中。</li>\n<li>放置在html事件处理程序中，如放入onclick的属性值中。</li>\n<li>放在url中，该url使用特殊的”javascript:”协议。</li>\n</ul>\n</li>\n<li><p>当使用<code>src</code>属性时，<code>&lt;script&gt;&lt;/script&gt;</code>之间的任何内容都会忽略。</p>\n</li>\n<li><code>script</code>标记中type属性默认值为”text/javascript”，如果没有指定，则使用默认值。若指定的类型是一个不可执行的类型，则不会从该url中下载任何东西。</li>\n<li>可以通过<code>&lt;a href=&quot;javascript: void doSomethingHere;&quot;&gt;</code>来执行某些操作并且不会修改当前页面文档。</li>\n<li>脚本和事件处理程序在同一时间只能执行一个，没有并发性。</li>\n<li>javascript的时间线。</li>\n</ul>\n<h2 id=\"11-Window对象\"><a href=\"#11-Window对象\" class=\"headerlink\" title=\"11. Window对象\"></a>11. Window对象</h2><ul>\n<li>它是客户端js的全局对象。</li>\n<li><code>Location</code>对象的<code>assign()</code>和<code>replace()</code>方法都可以使窗口载入一个指定的url中的文档，后者在载入新文档之前会将当前文档从浏览历史中删除，此时后退操作无效。</li>\n<li><code>Location</code>对象的<code>reload()</code>方法可以让浏览器重新载入当前文档。</li>\n<li>直接将url赋值给<code>location</code>属性。</li>\n<li>片段标识符不会使浏览器载入新的文档，它只会使它滚动到文档中的某个位置。<code>#id</code>会使浏览器跳到元素id对应的位置。<code>#top</code>如果没有元素id为top的话，则浏览器会跳到文档的开始处。</li>\n<li><code>history</code>属性包含浏览器的浏览历史信息。</li>\n<li><code>navigator</code>属性包含浏览器厂商和版本信息。</li>\n<li><code>screen</code>属性包含窗口大小和可用颜色信息。</li>\n<li>浏览器会为了防止广告的弹出而禁用<code>window.open()</code>方法，只有当用户手动点击按钮或者链接的时候才会调用。</li>\n<li>如果正在事件处理程序中调用<code>close()</code>方法，则应指明是Window对象还是Document对象的close方法。</li>\n<li>即使一个窗口已经关闭，但是代表它的Window对象仍然存在，它的document会使null，它的方法也不会工作。</li>\n<li>Window对象的open()方法会返回新创建的窗口的Window对象，而该对象的opener属性则指向打开该窗口的原始窗口的Window对象。</li>\n<li>窗体是用<code>&lt;iframe&gt;</code>元素创建的，窗体或窗口之间可以互相嵌套，可通过<code>parent</code>引用父窗口或窗体的window对象，<code>top</code>则可直接引用顶级窗口对象。若获取了iframe元素，可通过<code>contentWindow</code>属性获取该窗体的window对象，相反可通过window对象的<code>frameElement</code>得到对应的元素。另外，Window对象中还有frames属性可以得到自身包含的子窗口或窗体的引用，frames属性引用的是类数组对象，数组中的元素是Window对象而不是iframe元素，当访问子窗体时也可通过iframe元素的name或id属性来访问。</li>\n</ul>\n<h2 id=\"12-脚本化文档\"><a href=\"#12-脚本化文档\" class=\"headerlink\" title=\"12. 脚本化文档\"></a>12. 脚本化文档</h2><ul>\n<li><code>Document</code>对象表示窗口的内容。</li>\n<li>在html的树形结构中，树形的根部是<code>Document</code>节点，代表整个文档，代表html元素的是<code>Element</code>节点，代表文本的是<code>Text</code>节点。这三种节点都是Node的子类。</li>\n<li>html的<code>name</code>属性最初是为了表单元素分配名字，在表单数据提交到服务器时使用该属性的值。name属性的值在html文档中不必唯一，并且该属性仅在表单、表单元素、iframe和img这些元素中有效。（<strong>对于IE浏览器，通过<code>getElementById()</code>和<code>getElementsByName()</code>均会返回包含对应id和name的元素，因此不应将同样的字符串用作id和name的值</strong>）</li>\n<li><code>document.documentElement</code>指代文档的根元素，<code>document.head</code>和<code>document.body</code>分别指代head和body元素。</li>\n<li><code>NodeList</code>和<code>HTMLCollection</code>都是类数组对象，因此不能直接使用Array的方法，但可以通过call和apply来间接调用。</li>\n<li><code>querySelectorAll()</code>方法是通过css选择器的方式来匹配元素，但是其返回值并不是实时的，不会随着文档的变化而更新。<code>querySelector()</code>则是返回匹配的第一个元素。</li>\n<li>html中的属性名不区分大小写，但是js中的属性名则大小写敏感。因此html中的属性名在js中全部转换为小写，如果属性名包含不只一个单词，则除第一个单词外其余单词的首字母均大写。另外，有些html属性名在js中是保留字，对于这些属性一般是在属性名前加<strong>html</strong>前缀，例如，<code>for</code>转换为<code>htmlFor</code>，但对于<code>class</code>属性则例外，它转换为<code>className</code>。</li>\n<li>表示html属性的值通常是字符串，但当html属性为布尔值或数字时，js中的属性也是布尔值或者数字。</li>\n<li>HTML5提供任意以<code>data-</code>为前缀的小写的属性名而在元素上绑定一些额外的信息。同时定义了Element对象的dataset属性，该对象的属性对应于上述含前缀的属性。</li>\n<li><code>createElement()</code>和<code>createTextNode()</code>分别用于创建Element节点和Text节点。</li>\n<li>如果通过<code>appendChild()</code>和<code>insertBefore()</code>方法将文档中已经存在的节点插入到文档中，那个节点将会从它当前的位置删除并在新的位置重新插入。</li>\n<li><code>window.pageXOffset</code>、<code>window.pageYOffset</code>、<code>document.documentElement.scrollTop</code>、<code>document.documentElement.scrollLeft</code>都可以得到滚动条的位置信息。</li>\n<li><code>window.innerWidth</code>、<code>window.innerHeight</code>、<code>document.documentElement.clientWidth</code>、<code>document.documentElement.clientHeight</code>都可以得到视口的尺寸信息。</li>\n<li><code>getBoundingClientRect()</code>、<code>getClientRects()</code>可以得到一个元素的尺寸和位置。</li>\n</ul>\n<h2 id=\"13-脚本化css\"><a href=\"#13-脚本化css\" class=\"headerlink\" title=\"13. 脚本化css\"></a>13. 脚本化css</h2><ul>\n<li>style属性中的样式覆盖了样式表中的样式，而且文档的样式表中的样式覆盖了浏览器的默认样式。</li>\n<li>对于<code>absolute</code>和<code>fixed</code>定位，可以通过left和right或top和bottom来设置长和宽，若通过含有width或height，则相应的right和bottom将失效。</li>\n<li><code>z-index</code>属性只对兄弟元素应用堆叠效果。</li>\n<li><code>z-index</code>属性不适用于非定位元素，但对于非定位元素，它的值为0。</li>\n<li>对于定位元素，left和top属性指定了从容器边框内侧到定位元素边框外侧的距离。</li>\n<li>如果css属性名包含多个连字符，在js中应将连字符移除并将每个连字符后紧接着的字母大写。如果css属性名在js中属于保留字，则应在该属性名前加上”css”前缀，如”cssFloat”。</li>\n<li>通过js操作元素的style属性时，所有的值都是字符串，并且对于定位属性，其单位也要写上。</li>\n</ul>\n<h2 id=\"14-事件处理\"><a href=\"#14-事件处理\" class=\"headerlink\" title=\"14. 事件处理\"></a>14. 事件处理</h2><ul>\n<li><code>event</code>对象被当作参数传给事件处理函数，该对象的<code>type</code>属性确定了事件的类型，<code>target</code>属性确定了触发事件的对象。</li>\n<li>当按下键盘按键重复产生字符时，在<code>keyup</code>事件之前会产生多个<code>keypress</code>事件，该事件对象指定的是产生的字符，而不是按键。</li>\n<li><code>addEventListener()</code>能为同一个对象注册同一事件类型的多个处理程序函数，当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。</li>\n<li>使用相同的参数在同一对象上多次调用<code>addEventListener()</code>是没用的，处理程序仍然只注册一次，同时重复调用也不会改变调用处理程序的顺序。</li>\n<li>对于IE9之前不支持<code>addEventListener()</code>、<code>removeEventListener()</code>但支持类似的方法，<code>attachEvent()</code>和<code>detachEvent()</code>。两种方法类似但是存在以下几点不同：<ul>\n<li>只有两个参数</li>\n<li>第一个参数使用了带”on”前缀的事件处理程序名字字符串。</li>\n<li>当给同一对象注册多个同一事件处理程序，事件发生时，会多次触发事件处理程序。</li>\n<li>通过这种方式注册的事件处理程序中的this指的是全局对象，而其他方式指的是目标对象。</li>\n</ul>\n</li>\n<li>事件的调用顺序：<ul>\n<li>通过设置对象属性或html属性注册的处理程序优先调用。</li>\n<li>通过<code>addEventListener()</code>注册的处理程序按照它们的注册顺序调用。</li>\n<li>使用<code>attachEvent()</code>注册的处理程序可能按照任何顺序调用，代码不应依赖于调用顺序。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"15-脚本化http\"><a href=\"#15-脚本化http\" class=\"headerlink\" title=\"15. 脚本化http\"></a>15. 脚本化http</h2><ul>\n<li>http请求的顺序是：先是请求方法和url，然后是请求头，最后是请求主体。</li>\n</ul>\n<h2 id=\"16-jquery类库\"><a href=\"#16-jquery类库\" class=\"headerlink\" title=\"16. jquery类库\"></a>16. jquery类库</h2><ul>\n<li>this指的是原生文档参数，而不是jquery对象，若想使用jquery方法，则应该写成<code>$(this)</code>。</li>\n<li>jquery中使用同一个方法既当setter又当getter使用，用作setter时，这些方法会给jquery对象中的每一个元素设置值，当作为getter使用时，这些方法只会查询jquery对象中的第一个元素并给它设置值。</li>\n<li><code>css()</code>方法返回的是当前样式，即计算样式，该返回值既可能来自style属性也可能来自样式表。</li>\n<li><code>css()</code>方法不能获取复合样式，但是可以设置复合样式的值，其中的样式名既可以用连字符也可以用驼峰格式。</li>\n<li><code>css()</code>方法在获取样式值时，会把数值转换成带有单位后缀的字符串返回，在设置样式值时，则会将数值转换成字符串并在必要时添加”px”后缀。</li>\n<li><code>offset()</code>方法返回元素的绝对位置，用相对于文档的坐标来表示。<code>position()</code>方法返回相对于元素的<code>offsetParent()</code>的偏移量。</li>\n<li>获取元素的尺寸可以使用以下几种方法:<ul>\n<li><code>width()</code>、<code>height()</code>返回内容的宽度和高度。</li>\n<li><code>innerWidth()</code>、<code>innerHeight()</code>返回包含内边距的宽度和高度。</li>\n<li><code>outerWidth()</code>、<code>outerHeight()</code>返回包含边框的宽度和高度</li>\n<li>若对第三种方法传入参数<code>true</code>则返回的是包含元素外边距的宽度和高度。</li>\n</ul>\n</li>\n<li>如果插入的元素已经是文档的一部分，这些元素只会简单的移动而不是复制到新位置。</li>\n<li>jquery动画只支持数值属性。</li>\n</ul>\n<h2 id=\"17-客户端存储\"><a href=\"#17-客户端存储\" class=\"headerlink\" title=\"17. 客户端存储\"></a>17. 客户端存储</h2><ul>\n<li>浏览器目前只支持存储字符串类型数据，若要存取其他类型的数据，需要手动进行编码和解码。</li>\n</ul>\n<h2 id=\"18-多媒体和图形编程\"><a href=\"#18-多媒体和图形编程\" class=\"headerlink\" title=\"18. 多媒体和图形编程\"></a>18. 多媒体和图形编程</h2><ul>\n<li>通过<code>Image()</code>构造函数来创建一个图片对象，并将其<code>src</code>属性设置为相应的图片的url，这样由于图片元素并没有被添加到文档中，因此它是不可见的，但是浏览器会加载图片并将其缓存起来。当其他部分需要使用到该图片时便可直接从浏览器缓存中获取。</li>\n<li>对于音频元素，可通过<code>new Audio(&quot;url&quot;)</code>来构造一个对象，但视频元素没有类似的构造函数。</li>\n<li>在用<code>canvas</code>绘制图形时，当完成一条路径要绘制另一条路径前应使用<code>beginPath()</code>方法，如果没有使用该方法，那么添加的所有子路径都是处于当前路径上，使用<code>stroke()</code>和<code>fill()</code>方法时会作用在当前路径上的所有子路径。可能会导致重复绘制。</li>\n<li>非零绕数原则：判断一个点是否在路径的内部。</li>\n<li>每个<code>canvas</code>元素只有一个上下文对象，就算多次调用<code>getContext()</code>方法也会返回相同的上下文对象。</li>\n<li>线段宽度是由<code>lineWidth</code>属性和当前坐标系变换决定的，与其他创建路径的方法无关。</li>\n<li>文本对齐<code>textAlign</code>属性中，属性值<code>start</code>和<code>end</code>跟文本的方向有关，若文本是从左到右的则<code>start</code>和<code>left</code>是相同的，否则则相反。</li>\n</ul>\n","excerpt":"<p>本文是对《javascript权威指南》这本书中的知识点的总结。<br>","more":"</p>\n<h2 id=\"1-词法结构\"><a href=\"#1-词法结构\" class=\"headerlink\" title=\"1. 词法结构\"></a>1. 词法结构</h2><ul>\n<li>js标识符必须以字母、下划线（<code>_</code>）或美元符（<code>$</code>）开始，后续字符可以是字母、数字、下划线或美元符。</li>\n<li>当缺少分号时，js并不是在所有换行处填补分号，而是在缺少分号就无法正确解析代码的时候才会填补分号。但有两个例外：<ul>\n<li>当<code>return</code>、<code>break</code>和<code>continue</code>语句后面紧接着换行时，js会在换行处添加分号。</li>\n<li>当涉及到<code>++</code>和<code>--</code>符号时，若运算符作为后缀使用，应和表达式在同一行，若此时换行，js会在行尾填补分号，运算符会作为下一行代码的前缀运算符。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-类型、值和变量\"><a href=\"#2-类型、值和变量\" class=\"headerlink\" title=\"2. 类型、值和变量\"></a>2. 类型、值和变量</h2><ul>\n<li>对象、数组属于可变类型，数字、字符串、布尔值、<code>null</code>和<code>undefined</code>属于不可变类型。</li>\n<li>任意js的值都可以转换为布尔值。<code>undefined</code>、<code>null</code>、<code>0</code>、<code>-0</code>、<code>NaN</code>、<code>&quot;&quot;</code>会转化成<code>false</code>，其他值都会转换成<code>true</code>。</li>\n<li><code>null</code>是一种特殊的对象。<code>undefined</code>属于<code>undefined</code>类型，变量没有初始化，当查询的对象或数组的属性或元素不存在，如果函数没有返回任何值，引用没有提供实参的函数形参的值都会返回<code>undefined</code>。<code>undefined</code>是预定义的全局变量，不是关键字。<code>==</code>会认为两者相等，<code>.</code>和<code>[]</code>对两者进行操作时都会产生类型错误。若想将他们赋值给变量、属性或作为参数传入函数建议使用<code>null</code>。</li>\n<li>不在任何函数内的js代码可以使用关键字<code>this</code>来引用全局对象。</li>\n<li>在读取字符串、数字和布尔值的属性值时，表现的像对象一样。但如果你给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未被保留下来。</li>\n<li>对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，他们也是不相等的。</li>\n<li><code>x + &quot;&quot;</code>等价于<code>String(x)</code>，<code>+x</code>等价于<code>Number(x)</code>，<code>!!x</code>等价于<code>Boolean(x)</code>。</li>\n<li><code>+</code>、<code>==</code>、<code>!=</code>和关系运算符是唯一执行特殊字符串到原始值的转换方式的运算符。</li>\n<li>使用<code>var</code>语句重复声明变量是合法无害的。若给未声明的变量赋值，js会给全局对象创建一个同名属性。</li>\n<li>函数体内，局部变量的优先级高于同名的全局变量。</li>\n<li>js使用了函数作用域，即在函数内声明的所有变量在函数体内始终是可见的。声明提前：js函数内声明的所有变量都（不包含赋值）被提前至函数体的顶部。</li>\n<li>词法作用域：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。</li>\n</ul>\n<h2 id=\"3-表达式和运算符\"><a href=\"#3-表达式和运算符\" class=\"headerlink\" title=\"3. 表达式和运算符\"></a>3. 表达式和运算符</h2><ul>\n<li>如果表达式后跟一对方括号，则会计算方括号内的表达式的值并将它转换为字符串。只有当属性名称是合法的标识符并且需要知道要访问的属性名时，才能使用<code>.</code>来访问属性。</li>\n<li>如果函数使用<code>return</code>给出一个返回值时，这个返回值就是该表达式的值，否则表达式的值就是<code>undefined</code>。</li>\n<li>如果对象创建表达式不需要传入任何参数给构造函数的话，那么空圆括号是可以省略的。</li>\n<li>构造函数一般不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果该构造函数返回了一个对象值（只能是对象），那么该对象则作为整个表达式的值，而构造函数中新创建的对象就废弃了。</li>\n<li><p>js中子表达式的计算过程中的运算顺序不同于运算符的优先级和结合性规定的运算顺序。js总是严格按照从左至右的顺序来计算表达式的。如计算式</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1;</div><div class=\"line\">var b = (a++) + a;</div></pre></td></tr></table></figure>\n<ol>\n<li>计算b</li>\n<li>计算a++（结果记为c），之后a的值增1</li>\n<li>计算a</li>\n<li>计算c+a（此时a为2）</li>\n<li>将结果赋值给b</li>\n</ol>\n</li>\n<li><p>所有无法转换为数字的操作数都转化为<code>NaN</code>，若有操作数为<code>NaN</code>，此时计算结果也为<code>NaN</code>。</p>\n</li>\n<li>求余运算中余数的符号和被除数的符号保持一致。</li>\n<li><p>当<code>+</code>与字符串和数字一起使用时，应考虑加法的结合性对运算的影响。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1 + 2 + &quot;hello&quot;;//&quot;3hello&quot;</div><div class=\"line\">var b = 1 + (2 + &quot;hello&quot;);//&quot;12hello&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>位运算符的操作数为整数，且为32位整型，若不是则会强制转换。</p>\n<ul>\n<li>左移（&lt;&lt;）新的一位会用0来补充</li>\n<li>右移（&gt;&gt;）新的一位由操作数的符号决定，正数补0，负数补1。</li>\n<li>无符号右移（&gt;&gt;&gt;）新的一位总是补0.</li>\n</ul>\n</li>\n<li>只有数字和字符串才能真正执行比较操作，除此之外的都将进行类型转换。如果一个操作数是（或转换之后是）<code>NaN</code>，则比较结果总为<code>false</code>。字符串比较中大写字母总是小于小写字母。</li>\n<li>in运算符：如果右侧的对象有一个名为左侧操作数的属性名，那么表达式返回<code>true</code>。</li>\n<li>instanceof运算符：左操作数是对象，右操作数是对象的类。若左操作数不是对象，则返回<code>false</code>，若右操作数不是函数，则抛出类型错误异常。</li>\n<li><p><code>&amp;&amp;</code> 和 <code>||</code>的“短路”性质，可用于简写代码：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (a == b) &#123;</div><div class=\"line\">    stop();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">(a == b) &amp;&amp; stop();</div></pre></td></tr></table></figure>\n</li>\n<li><p>带操作符的赋值运算中需要注意：表达式<code>a op= b</code>和<code>a = a op b</code>的不同点，当a中含有具有副作用的表达式时，两者是不同的。如：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = [<span class=\"number\">1</span>, <span class=\"number\">2</span> ,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"comment\">//data[i++] *= 2;</span></div><div class=\"line\"><span class=\"comment\">//data[i++] = data[i++] * 2;</span></div><div class=\"line\">两者计算结果不同，第一个data = [<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]，第二个data = [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>typeof</code>运算符返回表示操作数类型的字符串，可将数组和对象与函数区分开。</p>\n</li>\n<li><code>delete</code>运算符用来删除对象属性或数组元素，删除属性时该属性在对象中不再存在，删除数组元素时，其对应值变为<code>undefined</code>。但通过<code>var</code>声明的变量和定义的函数都不能被删除。</li>\n<li><code>void</code>运算符：操作数会照常计算但是忽略计算结果并返回<code>undefined</code>。常用于url中。</li>\n</ul>\n<h2 id=\"4-语句\"><a href=\"#4-语句\" class=\"headerlink\" title=\"4. 语句\"></a>4. 语句</h2><ul>\n<li>全局变量是全局对象的属性，然而和其他全局变量的属性不同的是，var声明的变量是无法通过delete删除的。</li>\n<li>函数声明语句和函数定义表达式的不同点：<ul>\n<li>函数定义语句中的函数名称和函数体均被显式的提前到脚本或函数的顶部，因此他们在整个脚本和函数内都是可见的。</li>\n<li>使用var声明的函数表达式中只有变量声明被提前了，变量的初始化代码仍在原来的位置。</li>\n</ul>\n</li>\n<li><code>default</code>标签可以放在<code>switch</code>语句的任何位置，并不会影响结果。</li>\n<li><code>while(true)</code>和<code>for(;;)</code>都表示死循环。</li>\n</ul>\n<h2 id=\"5-对象\"><a href=\"#5-对象\" class=\"headerlink\" title=\"5. 对象\"></a>5. 对象</h2><ul>\n<li>如果变量x是指向一个对象的引用，那么执行代码`var y = x;变量y也是指向同一个对象的引用，而非这个对象的副本。通过变量y修改这个对象同样会对变量x的值造成影响。</li>\n<li>对象的属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。同时属性名也可以是标识符，但若属性名含有非法字符或是关键字则需要带上引号。</li>\n<li>用<code>.</code>操作对象时，右侧必须是一个以属性名命名的标识符。用<code>[]</code>操作对象时，方括号内的表达式必须返回一个字符串或者可以转换为字符串的值。</li>\n<li>若要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x，如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者找到一个原型是null的对象为止。</li>\n<li>若给对象o的属性x赋值，如果o中已经有了属性x，那么这个赋值操作只改变这个已有属性x的值；如果o中不存在属性x，那么赋值操作给o添加了新属性x；如果之前o继承了属性x，那么这个继承的属性就被新创建的同名属性覆盖了。</li>\n<li><code>delete</code>只是断开属性和宿主对象的联系，只能删除自有属性而不能删除继承属性，若一定要删除则只能从定义这个属性的原型对象上删除。（但这会影响到所有继承自这个原型的对象）</li>\n<li><code>in</code>运算符可检测是否含有自有属性和继承属性，<code>hasOwnProperty</code>只能检测是否含有自由属性。</li>\n<li>可通过<code>o.x !== undefined</code>判断是否含有某种属性，效果等同于in运算符。（但此种方法不能区分存在但值为undefined的属性）</li>\n<li>for/in循环可以遍历对象中所有可枚举的自有属性和继承属性，但不能枚举继承的内置方法。</li>\n<li><code>Object.keys()</code>返回可枚举的自有属性，<code>Object.getOwnPropertyNames()</code>返回所有自有属性。</li>\n<li>存取器属性<code>getter</code>和<code>setter</code>。</li>\n<li><code>Object.getOwnPropertyDescriptor(Object, attributeName)</code>获得某个对象特定自有属性的属性描述符。</li>\n<li><code>Object.defineProperty(Object, attributeName, descriptorObject)</code>可以设置属性的特性。</li>\n<li>通过对象直接量创建的对象使用<code>Object.prototype</code>作为它的原型，通过new创建的对象使用构造函数的prototype属性作为它的原型，通过<code>Object.create()</code>创建的对象使用第一个参数作为它的原型。</li>\n<li><code>Object.getPrototypeOf()</code>可以查询对象的原型。</li>\n<li><code>ObjectA.isPrototypeOf(ObjectB)</code>检测对象A是否是对象B的原型。</li>\n<li>对象的可扩展性表示是否可以给对象添加新属性。<code>Object.isExtensible()</code>判断对象是否可扩展；<code>ObjectPreventExtensions()</code>将对象转换为不可扩展的，此时再无法将对象转换回可扩展的了，同时这样做只能影响到对象本身的可扩展性，若给一个不可扩展的对象的原型添加属性，则该对象同样会继承这个新属性。</li>\n</ul>\n<h2 id=\"6-数组\"><a href=\"#6-数组\" class=\"headerlink\" title=\"6. 数组\"></a>6. 数组</h2><ul>\n<li>js数组可以是稀疏的，数组元素的索引不一定要连续，他们之间可以有空缺，对于每一个数组都有<code>length</code>属性，针对非稀疏数组，该属性就是数组元素的个数，而对于稀疏数组，该属性值比所有元素的索引都要大。</li>\n<li>数组直接量的语法允许有可选的结尾的逗号，因此<code>var a = [, ,]</code>含有两个<code>undefined</code>值而非三个。</li>\n<li>数组的索引是<strong>0~2^32-2</strong>之间的整数。</li>\n<li>因为数组是对象，因此可以为其创建任意名字的属性，但是如果属性名是数组的索引，数组就会更新它的length属性值。</li>\n<li>可以使用负数或者非整数作为数组的索引，此时数值将转换为字符串来作为属性名使用，此时只能作为属性名而非数组索引。同样，如果使用了非负整数的字符串作为数组索引，它就会直接作为数组索引而非对象的属性值。当使用浮点数作为索引时，若浮点数与一个整数相等则同样方式处理。</li>\n<li>关于<code>length</code>属性：<ul>\n<li>如果为一个数组元素赋值，它的索引 <strong>i</strong> 大于或等于现有数组的长度时，length的属性值将设置为 <strong>i+1</strong></li>\n<li>若设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"7-函数\"><a href=\"#7-函数\" class=\"headerlink\" title=\"7. 函数\"></a>7. 函数</h2><ul>\n<li>函数的定义可以通过函数声明或者函数定义表达式。通过函数声明的方法定义的函数，其名称是必需的部分，函数声明实际上声明了一个变量并把一个函数赋值给它。通过函数定义表达式的方式定义的函数，其名称是可选的，如果它包含名称，函数的局部作用域将会包含一个绑定到该函数对象的名称，函数的名称将成为函数内部的一个局部变量，在比如函数需要递归的情况下是很有用的。</li>\n<li>函数声明语句被提前到外部脚本或外部函数作用域的顶部，所以这种方式声明的函数可以被在它定义之前出现的代码所调用。要调用以表达式定义的函数则需要将函数赋值给一个变量，变量的声明会提前但是变量的赋值是不会提前的。</li>\n<li>函数声明语句不能出现在循环、条件判断、或者try/catch/finally以及with语句中。函数定义表达式则不受限制。</li>\n<li>普通的函数调用中（无论该函数声明是在脚本中还是函数内）的上下文<code>this</code>指的是全局对象（严格模式中是undefined），而方法调用中则指的是调用该方法的对象。</li>\n<li>构造函数调用创建一个新的空对象，这个对象继承自构造函数的prototype属性，构造函数会试图初始化这个新创建的对象，并将这个对象用作其调用上下文，因此构造函数中的this指的是这个新创建的对象。</li>\n<li>构造函数通常不使用<code>return</code>返回值，因为构造函数会显式返回初始化的新对象，如果使用了return返回一个对象，则调用构造函数返回的就是这个对象，若return返回的是其他值则会忽略该返回值。</li>\n<li>在函数体内标识符<code>arguments</code>是指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标来访问传入函数的实参值。</li>\n<li><code>arguments</code>和形参指的是同一个值，修改任意一个值都会影响到另一个。</li>\n<li>函数不仅是一种语法也是值。</li>\n<li>闭包的实现和理解，词法作用域。</li>\n<li><p><code>call()</code>方法和<code>apply()</code>方法可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。对于call函数来说，第一个调用上下文参数之后的所有参数都是要传入的待调用函数的实参；而apply方法则将实参都放入一个数组当中。两种方法的第一个参数都是一个要调用该函数的对象，该函数中的<code>this</code>则指向这个对象。如：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = &#123;x: <span class=\"number\">1</span>&#125;;</div><div class=\"line\">add.call(a, <span class=\"number\">2</span>)<span class=\"comment\">//返回3</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><code>bind()</code>方法将函数绑定至某个对象，并返回一个新的函数。如：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f(y) &#123;</div><div class=\"line\">    return this.x + y;</div><div class=\"line\">&#125;</div><div class=\"line\">var a = &#123;x: 1&#125;;</div><div class=\"line\">var g = f.bind(a);</div><div class=\"line\">g(2)//返回3</div><div class=\"line\">上述过程相当于</div><div class=\"line\">a = &#123;x: 1, f: function(y) &#123;return this.x + y&#125;&#125;;</div><div class=\"line\">g = a.f;</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过<code>Function()</code>构造的函数不使用词法作用域，它的作用域是全局作用域。</p>\n</li>\n<li>js在函数式编程中的使用。</li>\n</ul>\n<h2 id=\"8-类和模块\"><a href=\"#8-类和模块\" class=\"headerlink\" title=\"8. 类和模块\"></a>8. 类和模块</h2><ul>\n<li>定义构造函数即是定义类，因此构造函数名的首字母要大写，而普通的函数和方法名首字母都是小写。</li>\n<li>构造函数不必用<code>return</code>返回值，当通过<code>new</code>关键字来创建新对象时会自动返回该对象。其原型对象的名字为<code>ClassName.prototype</code>，这是一个强制命名，通过该构造函数创建的新对象会自动使用该原型对象作为新创建的对象的原型。</li>\n<li><strong>原型对象是类的唯一标识</strong>，当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例，而初始化该对象的构造函数则不能作为类的标识，两个构造函数的prototype可能指向同一个原型对象，那么这两个构造函数创建的实例是属于同一个类的。</li>\n<li><code>a instanceof A</code>并不会检查a是否是由A()构造函数初始化而来，而是检查a是否继承自A.prototype。</li>\n<li>在希望用到字符串的地方用到对象的话，js会自动调用<code>toString</code>方法，如果没有实现这个方法，类会默认从<code>Object.prototype</code>中继承这个方法。</li>\n<li>代码的模块化很重要，模块是一个独立的js文件，模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码。</li>\n<li>所有模块都尽量定义不超过一个全局变量。</li>\n<li>创建模块的过程中，避免污染全局变量的一种方法是使用一个对象作为命名空间。</li>\n</ul>\n<h2 id=\"9-正则表达式的模式匹配\"><a href=\"#9-正则表达式的模式匹配\" class=\"headerlink\" title=\"9. 正则表达式的模式匹配\"></a>9. 正则表达式的模式匹配</h2><p>正则表达式部分在我的另一篇博客中有介绍到：<a href=\"\">javascri正则表达式</a></p>\n<h2 id=\"10-web浏览器中的javascript\"><a href=\"#10-web浏览器中的javascript\" class=\"headerlink\" title=\"10. web浏览器中的javascript\"></a>10. web浏览器中的javascript</h2><ul>\n<li><p>在html文档里嵌入客户端javascript代码有四种方法：</p>\n<ul>\n<li>内联方式，放置在<code>&lt;script&gt;&lt;/script&gt;</code>标签对之间。</li>\n<li>放置在<code>&lt;script&gt;</code>标签的src属性指定的外部文件中。</li>\n<li>放置在html事件处理程序中，如放入onclick的属性值中。</li>\n<li>放在url中，该url使用特殊的”javascript:”协议。</li>\n</ul>\n</li>\n<li><p>当使用<code>src</code>属性时，<code>&lt;script&gt;&lt;/script&gt;</code>之间的任何内容都会忽略。</p>\n</li>\n<li><code>script</code>标记中type属性默认值为”text/javascript”，如果没有指定，则使用默认值。若指定的类型是一个不可执行的类型，则不会从该url中下载任何东西。</li>\n<li>可以通过<code>&lt;a href=&quot;javascript: void doSomethingHere;&quot;&gt;</code>来执行某些操作并且不会修改当前页面文档。</li>\n<li>脚本和事件处理程序在同一时间只能执行一个，没有并发性。</li>\n<li>javascript的时间线。</li>\n</ul>\n<h2 id=\"11-Window对象\"><a href=\"#11-Window对象\" class=\"headerlink\" title=\"11. Window对象\"></a>11. Window对象</h2><ul>\n<li>它是客户端js的全局对象。</li>\n<li><code>Location</code>对象的<code>assign()</code>和<code>replace()</code>方法都可以使窗口载入一个指定的url中的文档，后者在载入新文档之前会将当前文档从浏览历史中删除，此时后退操作无效。</li>\n<li><code>Location</code>对象的<code>reload()</code>方法可以让浏览器重新载入当前文档。</li>\n<li>直接将url赋值给<code>location</code>属性。</li>\n<li>片段标识符不会使浏览器载入新的文档，它只会使它滚动到文档中的某个位置。<code>#id</code>会使浏览器跳到元素id对应的位置。<code>#top</code>如果没有元素id为top的话，则浏览器会跳到文档的开始处。</li>\n<li><code>history</code>属性包含浏览器的浏览历史信息。</li>\n<li><code>navigator</code>属性包含浏览器厂商和版本信息。</li>\n<li><code>screen</code>属性包含窗口大小和可用颜色信息。</li>\n<li>浏览器会为了防止广告的弹出而禁用<code>window.open()</code>方法，只有当用户手动点击按钮或者链接的时候才会调用。</li>\n<li>如果正在事件处理程序中调用<code>close()</code>方法，则应指明是Window对象还是Document对象的close方法。</li>\n<li>即使一个窗口已经关闭，但是代表它的Window对象仍然存在，它的document会使null，它的方法也不会工作。</li>\n<li>Window对象的open()方法会返回新创建的窗口的Window对象，而该对象的opener属性则指向打开该窗口的原始窗口的Window对象。</li>\n<li>窗体是用<code>&lt;iframe&gt;</code>元素创建的，窗体或窗口之间可以互相嵌套，可通过<code>parent</code>引用父窗口或窗体的window对象，<code>top</code>则可直接引用顶级窗口对象。若获取了iframe元素，可通过<code>contentWindow</code>属性获取该窗体的window对象，相反可通过window对象的<code>frameElement</code>得到对应的元素。另外，Window对象中还有frames属性可以得到自身包含的子窗口或窗体的引用，frames属性引用的是类数组对象，数组中的元素是Window对象而不是iframe元素，当访问子窗体时也可通过iframe元素的name或id属性来访问。</li>\n</ul>\n<h2 id=\"12-脚本化文档\"><a href=\"#12-脚本化文档\" class=\"headerlink\" title=\"12. 脚本化文档\"></a>12. 脚本化文档</h2><ul>\n<li><code>Document</code>对象表示窗口的内容。</li>\n<li>在html的树形结构中，树形的根部是<code>Document</code>节点，代表整个文档，代表html元素的是<code>Element</code>节点，代表文本的是<code>Text</code>节点。这三种节点都是Node的子类。</li>\n<li>html的<code>name</code>属性最初是为了表单元素分配名字，在表单数据提交到服务器时使用该属性的值。name属性的值在html文档中不必唯一，并且该属性仅在表单、表单元素、iframe和img这些元素中有效。（<strong>对于IE浏览器，通过<code>getElementById()</code>和<code>getElementsByName()</code>均会返回包含对应id和name的元素，因此不应将同样的字符串用作id和name的值</strong>）</li>\n<li><code>document.documentElement</code>指代文档的根元素，<code>document.head</code>和<code>document.body</code>分别指代head和body元素。</li>\n<li><code>NodeList</code>和<code>HTMLCollection</code>都是类数组对象，因此不能直接使用Array的方法，但可以通过call和apply来间接调用。</li>\n<li><code>querySelectorAll()</code>方法是通过css选择器的方式来匹配元素，但是其返回值并不是实时的，不会随着文档的变化而更新。<code>querySelector()</code>则是返回匹配的第一个元素。</li>\n<li>html中的属性名不区分大小写，但是js中的属性名则大小写敏感。因此html中的属性名在js中全部转换为小写，如果属性名包含不只一个单词，则除第一个单词外其余单词的首字母均大写。另外，有些html属性名在js中是保留字，对于这些属性一般是在属性名前加<strong>html</strong>前缀，例如，<code>for</code>转换为<code>htmlFor</code>，但对于<code>class</code>属性则例外，它转换为<code>className</code>。</li>\n<li>表示html属性的值通常是字符串，但当html属性为布尔值或数字时，js中的属性也是布尔值或者数字。</li>\n<li>HTML5提供任意以<code>data-</code>为前缀的小写的属性名而在元素上绑定一些额外的信息。同时定义了Element对象的dataset属性，该对象的属性对应于上述含前缀的属性。</li>\n<li><code>createElement()</code>和<code>createTextNode()</code>分别用于创建Element节点和Text节点。</li>\n<li>如果通过<code>appendChild()</code>和<code>insertBefore()</code>方法将文档中已经存在的节点插入到文档中，那个节点将会从它当前的位置删除并在新的位置重新插入。</li>\n<li><code>window.pageXOffset</code>、<code>window.pageYOffset</code>、<code>document.documentElement.scrollTop</code>、<code>document.documentElement.scrollLeft</code>都可以得到滚动条的位置信息。</li>\n<li><code>window.innerWidth</code>、<code>window.innerHeight</code>、<code>document.documentElement.clientWidth</code>、<code>document.documentElement.clientHeight</code>都可以得到视口的尺寸信息。</li>\n<li><code>getBoundingClientRect()</code>、<code>getClientRects()</code>可以得到一个元素的尺寸和位置。</li>\n</ul>\n<h2 id=\"13-脚本化css\"><a href=\"#13-脚本化css\" class=\"headerlink\" title=\"13. 脚本化css\"></a>13. 脚本化css</h2><ul>\n<li>style属性中的样式覆盖了样式表中的样式，而且文档的样式表中的样式覆盖了浏览器的默认样式。</li>\n<li>对于<code>absolute</code>和<code>fixed</code>定位，可以通过left和right或top和bottom来设置长和宽，若通过含有width或height，则相应的right和bottom将失效。</li>\n<li><code>z-index</code>属性只对兄弟元素应用堆叠效果。</li>\n<li><code>z-index</code>属性不适用于非定位元素，但对于非定位元素，它的值为0。</li>\n<li>对于定位元素，left和top属性指定了从容器边框内侧到定位元素边框外侧的距离。</li>\n<li>如果css属性名包含多个连字符，在js中应将连字符移除并将每个连字符后紧接着的字母大写。如果css属性名在js中属于保留字，则应在该属性名前加上”css”前缀，如”cssFloat”。</li>\n<li>通过js操作元素的style属性时，所有的值都是字符串，并且对于定位属性，其单位也要写上。</li>\n</ul>\n<h2 id=\"14-事件处理\"><a href=\"#14-事件处理\" class=\"headerlink\" title=\"14. 事件处理\"></a>14. 事件处理</h2><ul>\n<li><code>event</code>对象被当作参数传给事件处理函数，该对象的<code>type</code>属性确定了事件的类型，<code>target</code>属性确定了触发事件的对象。</li>\n<li>当按下键盘按键重复产生字符时，在<code>keyup</code>事件之前会产生多个<code>keypress</code>事件，该事件对象指定的是产生的字符，而不是按键。</li>\n<li><code>addEventListener()</code>能为同一个对象注册同一事件类型的多个处理程序函数，当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。</li>\n<li>使用相同的参数在同一对象上多次调用<code>addEventListener()</code>是没用的，处理程序仍然只注册一次，同时重复调用也不会改变调用处理程序的顺序。</li>\n<li>对于IE9之前不支持<code>addEventListener()</code>、<code>removeEventListener()</code>但支持类似的方法，<code>attachEvent()</code>和<code>detachEvent()</code>。两种方法类似但是存在以下几点不同：<ul>\n<li>只有两个参数</li>\n<li>第一个参数使用了带”on”前缀的事件处理程序名字字符串。</li>\n<li>当给同一对象注册多个同一事件处理程序，事件发生时，会多次触发事件处理程序。</li>\n<li>通过这种方式注册的事件处理程序中的this指的是全局对象，而其他方式指的是目标对象。</li>\n</ul>\n</li>\n<li>事件的调用顺序：<ul>\n<li>通过设置对象属性或html属性注册的处理程序优先调用。</li>\n<li>通过<code>addEventListener()</code>注册的处理程序按照它们的注册顺序调用。</li>\n<li>使用<code>attachEvent()</code>注册的处理程序可能按照任何顺序调用，代码不应依赖于调用顺序。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"15-脚本化http\"><a href=\"#15-脚本化http\" class=\"headerlink\" title=\"15. 脚本化http\"></a>15. 脚本化http</h2><ul>\n<li>http请求的顺序是：先是请求方法和url，然后是请求头，最后是请求主体。</li>\n</ul>\n<h2 id=\"16-jquery类库\"><a href=\"#16-jquery类库\" class=\"headerlink\" title=\"16. jquery类库\"></a>16. jquery类库</h2><ul>\n<li>this指的是原生文档参数，而不是jquery对象，若想使用jquery方法，则应该写成<code>$(this)</code>。</li>\n<li>jquery中使用同一个方法既当setter又当getter使用，用作setter时，这些方法会给jquery对象中的每一个元素设置值，当作为getter使用时，这些方法只会查询jquery对象中的第一个元素并给它设置值。</li>\n<li><code>css()</code>方法返回的是当前样式，即计算样式，该返回值既可能来自style属性也可能来自样式表。</li>\n<li><code>css()</code>方法不能获取复合样式，但是可以设置复合样式的值，其中的样式名既可以用连字符也可以用驼峰格式。</li>\n<li><code>css()</code>方法在获取样式值时，会把数值转换成带有单位后缀的字符串返回，在设置样式值时，则会将数值转换成字符串并在必要时添加”px”后缀。</li>\n<li><code>offset()</code>方法返回元素的绝对位置，用相对于文档的坐标来表示。<code>position()</code>方法返回相对于元素的<code>offsetParent()</code>的偏移量。</li>\n<li>获取元素的尺寸可以使用以下几种方法:<ul>\n<li><code>width()</code>、<code>height()</code>返回内容的宽度和高度。</li>\n<li><code>innerWidth()</code>、<code>innerHeight()</code>返回包含内边距的宽度和高度。</li>\n<li><code>outerWidth()</code>、<code>outerHeight()</code>返回包含边框的宽度和高度</li>\n<li>若对第三种方法传入参数<code>true</code>则返回的是包含元素外边距的宽度和高度。</li>\n</ul>\n</li>\n<li>如果插入的元素已经是文档的一部分，这些元素只会简单的移动而不是复制到新位置。</li>\n<li>jquery动画只支持数值属性。</li>\n</ul>\n<h2 id=\"17-客户端存储\"><a href=\"#17-客户端存储\" class=\"headerlink\" title=\"17. 客户端存储\"></a>17. 客户端存储</h2><ul>\n<li>浏览器目前只支持存储字符串类型数据，若要存取其他类型的数据，需要手动进行编码和解码。</li>\n</ul>\n<h2 id=\"18-多媒体和图形编程\"><a href=\"#18-多媒体和图形编程\" class=\"headerlink\" title=\"18. 多媒体和图形编程\"></a>18. 多媒体和图形编程</h2><ul>\n<li>通过<code>Image()</code>构造函数来创建一个图片对象，并将其<code>src</code>属性设置为相应的图片的url，这样由于图片元素并没有被添加到文档中，因此它是不可见的，但是浏览器会加载图片并将其缓存起来。当其他部分需要使用到该图片时便可直接从浏览器缓存中获取。</li>\n<li>对于音频元素，可通过<code>new Audio(&quot;url&quot;)</code>来构造一个对象，但视频元素没有类似的构造函数。</li>\n<li>在用<code>canvas</code>绘制图形时，当完成一条路径要绘制另一条路径前应使用<code>beginPath()</code>方法，如果没有使用该方法，那么添加的所有子路径都是处于当前路径上，使用<code>stroke()</code>和<code>fill()</code>方法时会作用在当前路径上的所有子路径。可能会导致重复绘制。</li>\n<li>非零绕数原则：判断一个点是否在路径的内部。</li>\n<li>每个<code>canvas</code>元素只有一个上下文对象，就算多次调用<code>getContext()</code>方法也会返回相同的上下文对象。</li>\n<li>线段宽度是由<code>lineWidth</code>属性和当前坐标系变换决定的，与其他创建路径的方法无关。</li>\n<li>文本对齐<code>textAlign</code>属性中，属性值<code>start</code>和<code>end</code>跟文本的方向有关，若文本是从左到右的则<code>start</code>和<code>left</code>是相同的，否则则相反。</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cis1me2dj0002no74zcyspcsk","category_id":"cis1me2ee0009no743fbnon77","_id":"cis1me2et000eno74ibx0r8yd"},{"post_id":"cis1me2dy0007no74g65rz5lv","category_id":"cis1me2dy0005no74cc86y5ar","_id":"cis1me2et000kno74dw3ueyic"},{"post_id":"cis1me2dy0007no74g65rz5lv","category_id":"cis1me2et000fno74zqa4un4e","_id":"cis1me2et000nno74a4py4rvg"},{"post_id":"cis1me2d30000no740lj7hkfc","category_id":"cis1me2dy0005no74cc86y5ar","_id":"cis1me2et000qno74bctfnyt1"},{"post_id":"cis1me2d30000no740lj7hkfc","category_id":"cis1me2et000jno742jsa10wk","_id":"cis1me2et000sno742yza7ulr"},{"post_id":"cis1me2dy0006no744m2cer0w","category_id":"cis1me2dy0005no74cc86y5ar","_id":"cis1me2et000uno74wpcvh5sj"},{"post_id":"cis1me2dy0006no744m2cer0w","category_id":"cis1me2et000fno74zqa4un4e","_id":"cis1me2et000vno74vf21dzyr"}],"PostTag":[{"post_id":"cis1me2d30000no740lj7hkfc","tag_id":"cis1me2dj0004no74u25n2fhl","_id":"cis1me2ee000cno74l4b9mnx0"},{"post_id":"cis1me2d30000no740lj7hkfc","tag_id":"cis1me2ee0008no749qcc816d","_id":"cis1me2ee000dno7465pjhxte"},{"post_id":"cis1me2dj0002no74zcyspcsk","tag_id":"cis1me2ee000ano74jxpoyzuu","_id":"cis1me2et000hno747h56dtq9"},{"post_id":"cis1me2dy0006no744m2cer0w","tag_id":"cis1me2dj0004no74u25n2fhl","_id":"cis1me2et000ono743yy6kot5"},{"post_id":"cis1me2dy0006no744m2cer0w","tag_id":"cis1me2et000ino74g8dfs634","_id":"cis1me2et000pno74q10ipavo"},{"post_id":"cis1me2dy0007no74g65rz5lv","tag_id":"cis1me2dj0004no74u25n2fhl","_id":"cis1me2et000rno74e9r3f5ff"},{"post_id":"cis1me2dy0007no74g65rz5lv","tag_id":"cis1me2et000ino74g8dfs634","_id":"cis1me2et000tno74fh48mklu"}],"Tag":[{"name":"Web开发","_id":"cis1me2dj0004no74u25n2fhl"},{"name":"CSS","_id":"cis1me2ee0008no749qcc816d"},{"name":"Git","_id":"cis1me2ee000ano74jxpoyzuu"},{"name":"JS","_id":"cis1me2et000ino74g8dfs634"}]}}